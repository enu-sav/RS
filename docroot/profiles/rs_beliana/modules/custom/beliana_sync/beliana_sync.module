<?php

/**
 * @file
 * Beliana sync main file.
 */

use GuzzleHttp\Client;

/**
 * Implements hook_menu().
 */
function beliana_sync_menu() {
  return [
    'sync-test' => [
      'page callback' => 'drupal_get_form',
      'page arguments' => ['beliana_sync_test_form'],
      'access arguments' => ['access content'],
    ],
  ];
}

/**
 * Implements hook_node_insert().
 *
 * We are extracting links from `Heslo` nodes.
 *
 * {@inheritdoc}
 */
function beliana_sync_node_insert($node) {
  if (in_array($node->type, ['heslo', 'importovane_heslo'])) {
    // Extract links.
    beliana_sync_process_links($node->nid, $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
  }
}

/**
 * Implements hook_node_update().
 *
 * We are extracting links from `Heslo` nodes.
 *
 * {@inheritdoc}
 */
function beliana_sync_node_update($node) {
  if (in_array($node->type, ['heslo', 'importovane_heslo'])) {
    // Remove links to old node.
    db_delete('beliana_links')
      ->condition('origin', $node->nid)
      ->execute();
    // Extract links.
    beliana_sync_process_links($node->nid, $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
  }
}

/**
 * Extract links from node and insert them into beliana_links table.
 *
 * @param $nid
 */
function beliana_sync_process_links($nid, $text, $replace = FALSE) {
  // Extract links from field_text_hesla.
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = $links->length - 1; $i >= 0; $i--) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      if (!url_is_external($target)) {
        // Get rid of leading slash.
        if ($target[0] === '/') {
          $target = substr($target, 1);
        }
        // Get non-alias path, so we can get nid from it.
        $path = drupal_get_normal_path($target);
        $path_elements = explode('/', $path);
        // If alias belong to node, then insert record into beliana_links table.
        if ($path_elements[0] === 'node' && is_numeric($path_elements[1]) && !$replace) {
          $link = db_select('beliana_links', 'l')
            ->fields('l', ['origin'])
            ->condition('origin', $nid)
            ->condition('target', $path_elements[1])
            ->execute()
            ->fetchCol(0);
          // We insert new item only if it already doesn't exist.
          if (empty($link)) {
            db_insert('beliana_links')
              ->fields([
                'origin' => $nid,
                'target' => $path_elements[1],
              ])
              ->execute();
          }
        }

        if ($replace) {
          $remote_id = db_select('beliana_sync', 's')
            ->fields('s', ['remote'])
            ->condition('local', $path_elements[1])
            ->execute()
            ->fetchCol(0);
          if (!empty($remote_id)) {
            // If was synced, then replace href to remote site.
            $remote_id = reset($remote_id);
            $item->setAttribute('href', '/node/' . $remote_id);
          }
          else {
            // If not synced, then remove link completely.
            $lnkText = $item->textContent;
            $newTxtNode = $dom->createTextNode($lnkText);
            $item->parentNode->replaceChild($newTxtNode, $item);
          }
        }
      }
    }
  }

  if ($replace) {
    $fragment = '';
    foreach ($dom->getElementsByTagName('body')->item(0)->childNodes as $node) {
      $fragment .= $dom->saveHtml($node);
    }
    return $fragment;
  }
}

// display error message
function il_error($node, $ilu_node, $msg) {
  watchdog('sync', 'Chyba prenosu hesla "@title": ilustrácia "@ilu_title" ' . $msg, [
    '@title' => $node->title,
    '@ilu_title' => $ilu_node->title,
  ], WATCHDOG_ERROR);
  return 'Chyba prenosu hesla <a href ="' . $node->path['source'] . '">' . $node->title . '</a>: ilustrácia <strong><a href="' . $ilu_node->path['source'] .'">' . $ilu_node->title . '</a></strong> ' . $msg . '.';
}

function beliana_sync_sync($nid, &$context) {
  $skip = FALSE;
  // Make sure to only initialize the results the first time.
  if (!isset($context['results']['success'])) {
    $context['results']['messages'] = [];
    $context['results']['success'] = $context['results']['error'] = 0;
  }
  // Calculate Authorization header.
  $login = variable_get('beliana_web_login');
  $pass = variable_get('beliana_password_login');
  $auth_header = 'Basic ' . base64_encode($login . ':' . $pass);

  // Create client object.
  $client = new Client([
    'base_uri' => variable_get('beliana_web_uri'),
    'headers' => [
      'Content-Type' => 'application/json',
      'Accept' => 'application/json',
      'Authorization' => $auth_header,
    ],
    'query' => ['_format' => 'json'],
  ]);
  $generic_node = node_load($nid);
  $node = workbench_moderation_node_current_load($generic_node);
  $illustrations = [];
  $skip = FALSE;
  foreach ($node->field_ilustracia[LANGUAGE_NONE] as $illustration) {
    $ilu_generic_node = node_load($illustration['target_id']);
    $ilu_node = workbench_moderation_node_current_load($ilu_generic_node);
    // if there are images, but 'field_pouzit' (use) is not set, break processing
    // this is a very rare situation
    $auxsub = isset($ilu_node->field_subor_ilustracie[LANGUAGE_NONE]);
    $auxobr = isset($ilu_node->field_obrazok_navrh_[LANGUAGE_NONE]);
    $auxodk = isset($ilu_node->field_obrazok_odkaz[LANGUAGE_NONE]);
    $auxpou = !isset($ilu_node->field_pouzit[LANGUAGE_NONE]);
    // this works
    if(($auxsub or $auxobr or $auxodk) and $auxpou) {
    // this does not work. Looks like magic
    //if( (isset($ilu_node->field_subor_ilustracie[LANGUAGE_NONE]) or 
       //isset($ilu_node->field_obrazok_navrh[LANGUAGE_NONE]) or
       //isset($ilu_node->field_obrazok_odkaz[LANGUAGE_NONE])) and 
       //!isset($ilu_node->field_pouzit[LANGUAGE_NONE])) left curly brace here
      $context['results']['error']++;
      $context['results']['messages'][] = il_error($node, $ilu_node, 'nemá nastavený spôsob použitia');
      $skip = TRUE;
      break;
    }

    // not executed if field_pouzit is not set
    if (_display_on_web($ilu_node->field_pouzit[LANGUAGE_NONE])) {
      // Check if illustration has image attached.
      if (!(isset($ilu_node->field_subor_ilustracie[LANGUAGE_NONE]) or isset($ilu_node->field_obrazok_odkaz[LANGUAGE_NONE])) && !$skip) {
        $context['results']['error']++;
        $context['results']['messages'][] = il_error($node, $ilu_node, 'nemá priložený súbor a ani určený odkaz');
        $skip = TRUE;
        break;
      }
      // Check if illustration is in correct WB status.
      if (!in_array($ilu_node->workbench_moderation['current']->state, [
          'ilustracia_na_zverejnenie',
          'publikovane_na_webe',
        ]) && !$skip
      ) {
        $context['results']['error']++;
        $context['results']['messages'][] = il_error($node, $ilu_node, 'sa nenachádza v stave "Ilustrácia na zverejnenie"');
        $skip = TRUE;
        break;
      }
      // Check if illustration has correct license.
      if ((!isset($ilu_node->field_zdroj_ilustracie['und']) || $ilu_node->field_zdroj_ilustracie['und'][0]['value'] === 'Zatiaľ neurčený') && !$skip) {
        $context['results']['error']++;
        $context['results']['messages'][] = il_error($node, $ilu_node, 'nemá určený platný typ ilustrácie');
        $skip = TRUE;
        break;
      }
      // Check if alternative text is correct
      $plen = strlen($ilu_node->field_popis['und'][0]['value'])>130;
      if (!isset($ilu_node->field_alternativny_text['und']) && $plen && !$skip) {
        $context['results']['error']++;
        $context['results']['messages'][] = il_error($node, $ilu_node, 'má popis dlhší ako 130 znakov a nemá určený Alternatívny text.');
        $skip = TRUE;
        break;
      }
      if (!$skip) {
        // we synchronize linked image, if it is specified
        if (isset($ilu_node->field_obrazok_odkaz[LANGUAGE_NONE])) {
          $image_url_web = $ilu_node->field_obrazok_odkaz[LANGUAGE_NONE][0]['value'];
        } else {
          $image_url_local = _extract_image($ilu_node->field_subor_ilustracie[LANGUAGE_NONE]);
          if (is_null($image_url_local)) {
            $context['results']['error']++;
            $context['results']['messages'][] = il_error($node, $ilu_node, "nemá priradenú ilustráciu vhodného typu (svg, png, jpg)");
            $skip = TRUE;
            break;
          }
        }

        $license = _extract_license($ilu_node);
        if (empty($license)) {
          $context['results']['error']++;
          $context['results']['messages'][] = il_error($node, $ilu_node, 'má neplatný typ ilustrácie');
          $skip = TRUE;
          break;
        }
        $illustrations[] = [
          'nid' => $ilu_node->nid,
          //'uri' => $image_url_local,
          'title' => $ilu_node->title,
          'description' => $ilu_node->field_popis[LANGUAGE_NONE][0]['value'],
          'license' => $license,
        ];
        if( isset($image_url_local) )
          $illustrations[0]['image_url_local'] = $image_url_local;
        if( isset($image_url_web) )
          $illustrations[0]['image_url_web'] = $image_url_web;
        if( isset($ilu_node->field_meno_autora_diela[LANGUAGE_NONE]) )
          $illustrations[0]['meno_autora_diela'] = $ilu_node->field_meno_autora_diela[LANGUAGE_NONE][0]['value'];
        if( isset($ilu_node->field_meno_autora_snimky_diela[LANGUAGE_NONE]) ) 
          $illustrations[0]['meno_autora_snimky_diela'] = $ilu_node->field_meno_autora_snimky_diela[LANGUAGE_NONE][0]['value'];
        if( isset($ilu_node->field_nazov_diela[LANGUAGE_NONE]) ) 
          $illustrations[0]['nazov_diela'] = $ilu_node->field_nazov_diela[LANGUAGE_NONE][0]['value'];
        if( isset($ilu_node->field_institucia[LANGUAGE_NONE]) ) 
          $illustrations[0]['institucia'] = $ilu_node->field_institucia[LANGUAGE_NONE][0]['value'];
        if( isset($ilu_node->field_url_diela_l[LANGUAGE_NONE]) ) 
          $illustrations[0]['url_diela_l'] = $ilu_node->field_url_diela_l[LANGUAGE_NONE][0]['url'];
        if( isset($ilu_node->field_url_autora_diela_l[LANGUAGE_NONE]) ) 
          $illustrations[0]['url_autora_diela_l'] = $ilu_node->field_url_autora_diela_l[LANGUAGE_NONE][0]['url'];
        if( isset($ilu_node->field_url_textu_licencie_l[LANGUAGE_NONE]) ) 
          $illustrations[0]['url_textu_licencie_l'] = $ilu_node->field_url_textu_licencie_l[LANGUAGE_NONE][0]['url'];

        if( isset($ilu_node->field_alternativny_text[LANGUAGE_NONE]) ) { 
          $illustrations[0]['alternativny_text'] = $ilu_node->field_alternativny_text[LANGUAGE_NONE][0]['value'];
        } else {
          // remove eventual formatting (only strong and em are eventually still here), copy just 125 characters
          $atext = preg_replace('/<[^>]*>/', '',  $ilu_node->field_popis[LANGUAGE_NONE][0]['value']);
          $illustrations[0]['alternativny_text'] = substr($atext, 0, 125);
        }
      }
    }
  }
  if (!$skip) {
    $dates = [];
    if (isset($node->field_datum[LANGUAGE_NONE])) {
      foreach ($node->field_datum['und'] as $item) {
        $only_date = date('Y-m-d', strtotime($item['value']));
        $dates[] = $only_date;
      }
    }

    // Load node and form object to be sent over.
    $body = beliana_sync_process_links($nid, $node->field_text_hesla[LANGUAGE_NONE][0]['value'], TRUE);
    $remote_node_object = [
      'title' => $node->title,
      'body' => $body,
      'images' => $illustrations,
      'sort' => $node->field_na_zoradenie['und'][0]['value'],
      'dates' => $dates,
      'info_published' => _extract_published_info($node)._extract_updated_info($node),
    ];
    // Use POST for creating new items and PATCH for updating existing items.
    $remote_id = db_select('beliana_sync', 's')
      ->fields('s', ['remote'])
      ->condition('local', $nid)
      ->execute()
      ->fetchCol(0);
    // if not empty and not equal to '0' 
    // '0' have postponed pure link articles with unresolved link, not yet transfered to web, but already published
    if (!empty($remote_id) && $remote_id[0] != '0') {
      $remote_id = reset($remote_id);
      $response = $client->request('PATCH', '/rs/api/' . $remote_id, ['body' => json_encode($remote_node_object)]);
      db_update('beliana_sync')
        ->fields(['updated' => time()])
        ->condition('local', $nid)
        ->execute();
    } else {
      // postpone transfer of articles which are pure link articles with unresolved link
      // list them in the beliana_sync table, so that they will be transferred to web automatically 
      // as soon as the target is published

      // first delete synchronization info for the earlier postponed articles
      if (!empty($remote_id) && $remote_id[0] == '0') {
        db_delete('beliana_sync')
          ->condition('local', $nid)
          ->execute();
      }	

      // the articles to be postponed contain neither the '—' character, nor the '<a >' tag
      if (!(strpos($body, '—') == false && strpos($body, '<a ') == false)) {
        $response = $client->request('POST', '/rs/api', ['body' => json_encode($remote_node_object)]);
        // If new node was created on remote, insert its nid to beliana_sync table.
        if ($response->getStatusCode() === 201) {
          $remote_id = (int) json_decode($response->getBody());
          db_insert('beliana_sync')
            ->fields([
              'local' => $nid,
              'remote' => $remote_id,
              'updated' => time()
            ])
            ->execute();
        } else {
        }
      } else {
          // insert the postponed articles into the table of synchronized articles, but with id '0'
          db_insert('beliana_sync')
            ->fields([
              'local' => $nid,
              'remote' => 0,
              'updated' => time()
            ])
            ->execute();
      }
    }
    // Change workbench status for node and attached illustrations.
    workbench_moderation_moderate($node, 'publikovane_na_webe');
    foreach ($illustrations as $illustration) {
      $ilu_generic_node = node_load($illustration['nid']);
      $ilu_node = workbench_moderation_node_current_load($ilu_generic_node);
      workbench_moderation_moderate($ilu_node, 'publikovane_na_webe');
    }
    watchdog('sync', 'Heslo "@title" bolo úspešne prenesené.', [
      '@title' => $node->title,
    ], WATCHDOG_INFO);
    $context['results']['success']++;

    // save the date of first publication to web here
    if (!isset($node->field_datum_prveho_zverejnenia[LANGUAGE_NONE][0]['value'])) {
      $node->field_datum_prveho_zverejnenia[LANGUAGE_NONE][0]['value'] = date("Y/m/d - H:i");
      node_save($node);
    }
  }
}

function _display_on_web($values) {
  foreach ($values as $value) {
    if ($value['value'] === 'Zobrazit_na_webe') {
      return TRUE;
    }
  }
  return FALSE;
}

function get_order($source, $source_links) {
  $dest = [];
  $i = 0;
  $limit = pow(sizeof($source), 2) + 1;
  $moved = [];
  while (!empty($source)) {
    $current = array_shift($source);
    $links = $source_links[$current];
    $i++;
    if ($i % $limit === 0) {
      $dest[] = $current;
      $moved[] = $current;
      continue;
    }
    if (!empty($links)) {
      $found = FALSE;
      foreach ($links as $link) {
        if (in_array($link, $source)) {
          $found = TRUE;
          $source[] = $current;
          break;
        }
      }
      if (!$found) {
        $dest[] = $current;
      }
    }
    else {
      $dest[] = $current;
    }
  }

  $dest = array_merge($dest, $moved);
  return $dest;
}

function beliana_sync_prepare_queue($source) {
  $source_links = [];
  $back_links = [];
  $back_links_links = [];
  $operations = [];
  foreach ($source as $item) {
    $links = db_select('beliana_links', 'l')
      ->fields('l', ['target'])
      ->condition('origin', $item)
      ->execute()
      ->fetchCol(0);
    $source_links[$item] = $links;

    $item_back_links_query = db_select('beliana_links', 'l');
    $item_back_links_query->join('beliana_sync', 's', 'l.origin=s.local');
    $item_back_links = $item_back_links_query->fields('l', ['origin'])
      ->isNotNull('s.local')
      ->condition('l.target', $item)
      ->distinct()
      ->execute()
      ->fetchCol(0);

    foreach ($item_back_links as $item_back_link) {
      if (!isset($back_links_links[$item_back_link])) {
        $back_links_local_links = db_select('beliana_links', 'l')
          ->fields('l', ['target'])
          ->condition('origin', $item_back_link)
          ->execute()
          ->fetchCol(0);
        $back_links_links[$item_back_link] = $back_links_local_links;
      }
    }

    $back_links = array_merge($back_links, $item_back_links);
  }
  $back_links = array_unique($back_links);
  $sync_queue = get_order($source, $source_links);
  $back_links_queue = get_order($back_links, $back_links_links);
  $sync_queue = array_merge($sync_queue, $back_links_queue);

  foreach ($sync_queue as $item) {
    $operations[] = [
      'beliana_sync_sync',
      [$item],
    ];
  }

  $batch = array(
    'title' => t('Publishing content to web version...'),
    'operations' => $operations,
    'finished' => 'beliana_sync_sync_finished',
    'init_message' => t('Publishing is starting ...'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('An error occurred during processing'),
  );

  batch_set($batch);
}

function beliana_sync_sync_finished($success, $results, $operations) {
  drupal_set_message('Synchronizácia bola ukončená - ' . $results['success'] . ' úspešne, ' . $results['error'] . ' - neúspešne');
  foreach ($results['messages'] as $message) {
    drupal_set_message($message, 'error');
  }
  return '';
}

// select image in the order svg, png, jpg
function _extract_image(array $images) {
  foreach ($images as $image) {
    if (strpos($image['filemime'], 'svg')) {
      return file_create_url($image['uri']);
    }
  }
  foreach ($images as $image) {
    if (strpos($image['filemime'], 'png')) {
      return file_create_url($image['uri']);
    }
  }
  foreach ($images as $image) {
    if (strpos($image['filemime'], 'jpeg')) {
      return file_create_url($image['uri']);
    }
  }
  return NULL;
}

function _extract_license($node) {
  $formatted_license = '';
  $raw_license = $node->field_zdroj_ilustracie[LANGUAGE_NONE][0]['value'];
  //license names ('Creative Commons ...') must be exactly the same as in the 'Licencie' taxonomy in the web version 
  switch ($raw_license) {
    case 'Vlastná ilustrácia':
      $formatted_license = 'Creative Commons BY-SA';
      break;
    case 'Public domain':
      $formatted_license = 'Voľné dielo';
      break;
    case 'CC licencia':
      switch ($node->field_licencia1[LANGUAGE_NONE][0]['value']) {
      case 'CC BY-ND':
        $formatted_license = 'Creative Commons BY-ND';
        break;
      case 'CC BY-NC':
        $formatted_license = 'Creative Commons BY-NC';
        break;
      case 'CC BY-SA':
        $formatted_license = 'Creative Commons BY-SA';
        break;
      case 'CC BY-NC-ND':
        $formatted_license = 'Creative Commons BY-NC-ND';
        break;
      case 'CC BY-NC-SA':
        $formatted_license = 'Creative Commons BY-NC-SA';
        break;
      case 'CC BY':
        $formatted_license = 'Creative Commons BY';
        break;
      case 'IVL':
        $formatted_license = 'Iná verejná licencia';
        break;
      case 'CC0':
        $formatted_license = 'Creative Commons CC0';
        break;
      }
      break;
    case 'Získané na základe zmluvy':
    case 'Muzeálny objekt':
    case 'Autorské dielo':
    case 'Iná licencia':
      $formatted_license = 'Všetky práva vyhradené';
      break;
  }
  return $formatted_license;
}

/*
*  extract information regarding the date of first publishing.
*  Different for the 'Importovane heslo' and 'Heslo' types  
*/
function _extract_published_info($node) {
  // Set the publishing date according to the article name
  // the key in the $bands array is a first string in the next band 
  $bands = array (
    "bell" => "Vydané v auguste 1999",
    "czzzz" => "Vydané v júli 2001",
    "eh" => "Vydané v máji 2003",
    "galb" => "Vydané v júli 2005",
    "his" => "Vydané vo februári 2008",
    "in" => "Vydané v apríli 2010",
    "kam" => "Vydané v novembri 2013",
    "koks" => "Vydané v marci 2017",
  );

  setlocale(LC_COLLATE, 'sk_SK.utf8');
  if ( $node->type ==  'importovane_heslo' ){
    // get name of article, specified in node->field_taxsubor 
    $vocabulary = taxonomy_vocabulary_machine_name_load('subory');
    $collections = taxonomy_get_tree($vocabulary->vid);
    foreach ($collections as $term) {
      if ($term->tid == $node->field_taxsubor['und'][0]['tid']) {
        $collection = $term->name;
        break;
      }
    }

    # get publication year info
    foreach ($bands as $key => $txt) {
      $publishedinfo = $txt;
      if (strcoll($collection, $key) < 0 ) {
	# $publishedinfo is not set for the first band
        #if (!isset($publishedinfo))
          #$publishedinfo = $txt;
        break;
      }
    }
  } else { // the Heslo type
    // if already published, the 'field_datum_prveho_zverejnenia' is set 
    // the field is set elsewhere, after a successfull transfer to web
    if (isset($node->field_datum_prveho_zverejnenia[LANGUAGE_NONE][0]['value'])) {
      $publishedinfo = " Vydané " .  _form_date2($node->field_datum_prveho_zverejnenia[LANGUAGE_NONE][0]['value']);
    } else {
      $publishedinfo = " Vydané " .  _form_date2(date("d.m.Y"));
    }
  }
  return $publishedinfo . ".";
}

function _extract_updated_info($node) {
  if (isset($node->field_datum_aktualizacie[LANGUAGE_NONE][0]['value'])) {
    return " Aktualizované " .  _form_date2($node->field_datum_aktualizacie[LANGUAGE_NONE][0]['value']) . ".";
  } else {
    return("");
  }
}

/*
 * replaces month abbrevoation with inflected full name in genitive 
 */
function _form_date2($utime) {
  setlocale(LC_TIME, 'sk_SK.utf8');
  $fdate = strftime("%e. %b %Y", strtotime($utime));
  $fdate = str_replace("jan","januára",$fdate);
  $fdate = str_replace("feb","februára",$fdate);
  $fdate = str_replace("mar","marca",$fdate);
  $fdate = str_replace("apr","apríla",$fdate);
  $fdate = str_replace("máj","mája",$fdate);
  $fdate = str_replace("jún","júna",$fdate);
  $fdate = str_replace("júl","júla",$fdate);
  $fdate = str_replace("aug","augusta",$fdate);
  $fdate = str_replace("sep","septembra",$fdate);
  $fdate = str_replace("okt","októbra",$fdate);
  $fdate = str_replace("nov","novembra",$fdate);
  $fdate = str_replace("dec","decembra",$fdate);
  return $fdate;
}

/*
 * replaces month abbrevoation with inflected full name in local with preposition 
 */
function _form_date6() {
  setlocale(LC_TIME, 'sk_SK.utf8');
  $fdate = strftime("%b %Y");
  $fdate = str_replace("jan","v januári",$fdate);
  $fdate = str_replace("feb","vo februári",$fdate);
  $fdate = str_replace("mar","v marci",$fdate);
  $fdate = str_replace("apr","v apríli",$fdate);
  $fdate = str_replace("máj","v máji",$fdate);
  $fdate = str_replace("jún","v júni",$fdate);
  $fdate = str_replace("júl","v júli",$fdate);
  $fdate = str_replace("aug","v auguste",$fdate);
  $fdate = str_replace("sep","v septembri",$fdate);
  $fdate = str_replace("okt","v októbri",$fdate);
  $fdate = str_replace("nov","v novembri",$fdate);
  $fdate = str_replace("dec","v decembri",$fdate);
  return $fdate;
}
