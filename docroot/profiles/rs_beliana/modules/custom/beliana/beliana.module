<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana module.
 */

/**
 * Implements hook_menu().
 *
 * @inheritdoc
 */
function beliana_menu() {
  $items = array();
  $items['admin/users-list'] = array(
    'title' => 'Users list',
    'page callback' => 'beliana_users_list',
    'access arguments' => array('bypass node access'),
  );

  $items['admin/group-list'] = array(
    'title' => 'Group list',
    'page callback' => 'beliana_group_list',
    'access arguments' => array('bypass node access'),
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * @inheritdoc
 */
function beliana_menu_alter(&$items) {
  if (isset($items['admin/workbench/sections'])) {
    unset($items['admin/workbench/sections']);
  }

  if (isset($items['node/%node/draft'])) {
    unset($items['node/%node/draft']);
  }

  if (isset($items['node/%node/revisions'])) {
    unset($items['node/%node/revisions']);
  }

  /* get rid of the 'Index' item in the menu */
  if (isset($items['admin/index'])) {
    unset($items['admin/index']);
  }

  /* get rid of the create/forum item in the menu */
  /* not a good idea - blocks the possibility to create topics */
  //if (isset($items['node/add/forum'])) {
  //unset($items['node/add/forum']);
  //}
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * @inheritdoc
 */
function beliana_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  if (isset($data['tabs'][0]['output'])) {
    foreach ($data['tabs'][0]['output'] as $i => $tab) {
      if (in_array($tab['#link']['path'], array(
            'admin/tasks',
            'admin/index',
          ))) {
        unset($data['tabs'][0]['output'][$i]);
      }
    }
  }
}

function beliana_workbench_access_check($op, $type, $access_ids, $account_access) {
  global $user;

  if ($op == 'view') {
    return TRUE;
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * @inheritdoc
 */
function beliana_field_formatter_info() {
  return array(
    'beliana_external_image' => array(
      'label' => t('External image'),
      'field types' => array('url'),
      'settings' => array(
        'size' => 'medium',
        'link' => 0
      )
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function beliana_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  $element['size'] = array(
    '#type' => 'select',
    '#title' => t('Image style'),
    '#default_value' => $settings['size'],
  );

  $element['link'] = array(
    '#type' => 'select',
    '#title' => t('Link'),
    '#default_value' => $settings['link'],
    '#options' => array(t('No'), t('Yes')),
  );

  foreach (image_styles() as $key => $style) {
    $element['size']['#options'][$key] = $style['label'];
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function beliana_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $styles = image_styles();
  $options = array(t('No'), t('Yes'));

  return t('Image style: @size, Link: @link', array('@size' => $styles[$settings['size']]['label'], '@link' => $options[$settings['link']]));
}

/**
 * Implements hook_field_formatter_view().
 *
 * @inheritdoc
 */
function beliana_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  if ($display['type'] == 'beliana_external_image') {
    $width = 100;
    $styles = image_styles();

    foreach ($styles[$settings['size']]['effects'] as $effect) {
      if ($effect['name'] == 'image_scale') {
        $width = $effect['data']['width'];
      }
    }

    foreach ($items as $delta => $item) {
      $img = '<img src="' . $item['value'] . '" width="' . $width . '" />';

      $element[$delta] = array('#markup' => $img);
      if ($settings['link'] > 0) {
        $element[$delta]['#markup'] = l($img, $item['value'], array('html' => TRUE, 'external' => TRUE));
      }
    }
  }

  return $element;
}

/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */
function beliana_group_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    if ($term->depth == 0) {
      $output .= '<h1>' . $term->name . '</h1>';
    }
    else {
      //$output .= '<h3> Lexikálna skupina: <em>' . $term->name . '</em></h3>';
      $output .= '<strong>' . $term->name . '</strong>';
      $output .= '<ul>';
      foreach ($users as $user) {
        if (isset($user->workbench_access[$term->tid])) {
          $output .= '<li>'
              . $user->name . ', '
              . $user->field_meno['und'][0][value] . ', '
              . $user->field_priezvisko['und'][0][value] . ', '
              . $user->field_autorska_zmluva['und'][0][value] . ', '
              . $user->mail //. ', '
              //. $term->name
              . '</li>';
        }
      }
      //$output .= '</ul><br><br>';
      $output .= '</ul>';
    }
  }
  return $output;
}

/**
 * Menu callback for `admin/users-list` path.
 *
 * We are printing users with group assigned to users.
 *
 * @return string
 *   HTML output of all users with their groups.
 */
function beliana_users_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($users as $user) {
    $output .= '<div>';
    $output .= '<h3> Lexikálne skupiny používateľa <em>' . $user->name . '</em></h3>';
    $output .= '<ul>';
    foreach ($terms as $t) {
      if (isset($user->workbench_access[$t->tid])) {
        $output .= '<li>' . $t->name . '</li>';
      }
    }
    $output .= '</ul><br><br></div>';
  }
  return $output;
}

/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_action_info() {
  return array(
    'beliana_merge' => array(
      'type' => 'entity',
      'label' => t('Merge'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'beliana_assign_author' => array(
      'type' => 'entity',
      //'label' => t('Určiť autora a priradiť autorovi'),
      'label' => t('Specify author and assign to author'),
      'configurable' => TRUE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'beliana_assign_corrector' => array(
      'type' => 'entity',
      //'label' => t('Určiť autora a priradiť redaktorovi'),
      'label' => t('Specify author and assign to editor'),
      'configurable' => TRUE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie'),
      'label' => t('Mark for publishing (editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_senior_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (VR)'),
      'label' => t('Mark for publishing (senior editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_proofreader' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (JR)'),
      'label' => t('Mark for publishing (proofreader)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'update_dates' => array(
      'type' => 'entity',
      //'label' => t('Aktualizovať dátumy'),
      'label' => t('Update dates'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'check_path_attributes' => array(
      'type' => 'entity',
      'label' => t('Check link'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Callback for 'importovane_publish_editor' action.
 *
 * changes workflow status to 'importovane_u_jr2'
 *
 * @inheritdoc
 */
function importovane_publish_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane') {
    $skip = false;
    if (!_check_links($node)) {
      $skip = true;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = true;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "importovane_u_jr2");
    }
  }
}

/**
 * Callback for 'importovane_publish_proofreader' action.
 *
 * changes workflow status to 'importovane_u_vr'
 *
 * @inheritdoc
 */
function importovane_publish_proofreader(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_jr2') {
    if (_check_links($node)) {
      workbench_moderation_moderate($node, "importovane_u_vr");
    }
  }
}

/**
 * Callback for 'importovane_publish_senior_editor' action.
 *
 * changes workflow status to 'na_zalomenie'
 *
 * @inheritdoc
 */
function importovane_publish_senior_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_vr') {
    if (_check_links($node)) {
      workbench_moderation_moderate($node, "na_zalomenie");
    }
  }
}

/**
 * Configuration form for `beliana_assign_author` action.
 *
 * @inheritdoc
 */
function beliana_assign_author_form($form, &$form_state) {
  return _beliana_assign_user_form();
}

/**
 * Validation for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state);
}

/**
 * Submit function for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'u_autora');
}

/**
 * Callback for `beliana_assign_author` action.
 *
 * Assigns selected user as node author and
 * changes workflow status to `u_autora`.
 *
 * @inheritdoc
 */
function beliana_assign_author(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Configuration form for `beliana_assign_corrector` action.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_form($form, &$form_state) {
  return _beliana_assign_user_form();
}

/**
 * Validation for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state);
}

/**
 * Submit function for for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'needs_review');
}

/**
 * Callback function for `beliana_assign_corrector` action.
 *
 * Assigns selected user as node author and
 * change workflow status to `needs_review`.
 *
 * @inheritdoc
 */
function beliana_assign_corrector(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Callback function for `update_dates` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function update_dates(&$entity, $context = array()) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    // get dates from article text
    $dates = get_header_dates($entity->field_text_hesla[LANGUAGE_NONE][0]['value']);
    if (count($dates) > 0) {
      // unset date fields first
      for ($i = 2; $i >= 0; $i--) {
        if( isset($entity->field_datum[LANGUAGE_NONE][$i]['value']))
          unset($entity->field_datum[LANGUAGE_NONE][$i]['value']);
      }
      for ($i = 0; $i < count($dates); $i++) {
        // set the field
        $entity->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
      }
      node_save($entity);
    }
  }
}

/**
 * Callback function for `check_path_attributes` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function check_path_attributes(&$entity, $context = array()) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    $alias = drupal_get_path_alias('node/' . $entity->nid);

    if (strpos($alias, '_') === false) {
      $entity->field_atributy = array(LANGUAGE_NONE => array(array('value' => 'odkazOK')));
      node_save($entity);
    }
  }
}

/**
 * Callback function for `beliana_merge` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function beliana_merge(&$entity, $context = array()) {
  // If current entity is the first one,
  // create new entity `Heslo` and store its nid into session.
  if ($context['progress']['current'] === 1) {
    $master = new stdClass();
    $master->type = 'heslo';
    node_object_prepare($master);
    $master->title = $entity->title;
    $master->field_text_hesla = array(
      LANGUAGE_NONE => array(
        array(
          'value' => '',
          'format' => 'filtered_html',
        ),
      ),
    );
    $master->field_taxsubor = $entity->field_taxsubor;
    $master->language = 'sk';
    node_save($master);
    $_SESSION['master'] = $master->nid;
  }

  // Load master entity from session.
  $master = node_load($_SESSION['master']);

  // If master entity found, copy fields from current entity into it.
  if ($master != FALSE) {
    // Merge field_lexikalna_skupina.
    foreach ($entity->field_lexikalna_skupina[LANGUAGE_NONE] as $ls) {
      // find the top most parent (set to editor name) 
      $parents = taxonomy_get_parents_all($ls['tid']);
      foreach ($parents as $parent) {
        if (count(taxonomy_get_parents_all($parent->tid)) == 1) {
          $top_parent = $parent;
        }
      }

      // store the top most parent (editor name) to field_redaktori_zluceneho
      $found = FALSE;
      if (isset($master->field_redaktori_zluceneho[LANGUAGE_NONE])) {
        foreach ($master->field_redaktori_zluceneho[LANGUAGE_NONE] as $tid) {
          if ($tid['tid'] === $top_parent->tid) {
            $found = TRUE;
          }
        }
      }
      if (!$found) {
        $master->field_redaktori_zluceneho[LANGUAGE_NONE][]['tid'] = $top_parent->tid;
      }
      // We want to preserve the original taxonomy values in further processing.
      $master->field_povodne_lexikalne_skupiny[LANGUAGE_NONE][]['tid'] = $ls;
    }

    // Merge field_komentar_instrukcie, use "\n" as separator.
    if (isset($entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) || empty($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_hesla, use "</p>\n<p>" as separator.
    if (!isset($master->field_text_hesla[LANGUAGE_NONE][0]['value']) || empty($master->field_text_hesla[LANGUAGE_NONE][0]['value'])) {
      $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
    }
    else {
      // special requirement: in merging put GEO articles in front of others
      if ($top_parent->tid === "390") {  // "390" is Lubica Krajcovicova, editor of GEO articles. 
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'] . "<p>&nbsp;/p>" . $master->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] .= "<p>&nbsp;br></p>" . $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_z_gh, use "\n" as separator.
    if (isset($entity->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_text_z_gh[LANGUAGE_NONE][0]['value']) || empty($master->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] = $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_ilustracia.
    if (!empty($entity->field_ilustracia)) {
      foreach ($entity->field_ilustracia[LANGUAGE_NONE] as $img) {
        $master->field_ilustracia[LANGUAGE_NONE][] = $img;
      }
    }

    // Merge field_atributy, use "\n" as separator.
    if (isset($entity->field_atributy[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_atributy[LANGUAGE_NONE][0]['value']) || empty($master->field_atributy[LANGUAGE_NONE][0]['value'])) {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] = $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] .= "," . $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
    }

    $master->field_zlucene_z[LANGUAGE_NONE][]['target_id'] = $entity->nid;
    node_save($master);

    $entity->field_zlucene_do[LANGUAGE_NONE][0]['target_id'] = $_SESSION['master'];
    // Empty alias for original entity.
    //$entity->path['alias'] = '';
    // Set automatic alias creation to FALSE.
    //$entity->path['pathauto'] = FALSE;
    node_save($entity);
    workbench_moderation_moderate($entity, 'ukoncenezluene');
  }

  // If current entity is the last, make workflow transition.
  if ($context['progress']['current'] === $context['progress']['total']) {
    $master = node_load($_SESSION['master']);
    // Reset fields.
    $master->field_vyplatit = NULL;
    $master->field_errta = NULL;
    $master->field_datum = NULL;
    // Set automatic alias creation to FALSE.
    $master->path['pathauto'] = FALSE;
    // Set field_lexikalna_skupina to `Zlúčené heslo`.
    $term = array_shift(taxonomy_get_term_by_name('Zlúčené heslo', 'lexikalne_skupiny'));
    $master->field_lexikalna_skupina[LANGUAGE_NONE][]['tid'] = $term->tid;
    node_save($master);
    workbench_moderation_moderate($master, 'zlucene');
    $_SESSION['master'] = NULL;
  }
}

/**
 * Implements hook_node_presave().
 *
 * @inheritdoc
 */
function beliana_node_presave($node) {
  # do not execute in the case of workbench moderation state transitions
  # execute only on node saving
  # on node creation $node->workbench_moderation does not exist
  if (isset($node->workbench_moderation_state_new)  and 
        isset($node->workbench_moderation) and 
        $node->workbench_moderation['current']->state != $node->workbench_moderation_state_new) {
    return;
  }
  setlocale(LC_COLLATE, 'sk_SK.utf8');
  // fix field_na_zoradenie if necessary
  $rebuild_sort = !isset($node->field_na_zoradenie['und'][0]['value']);
  if (!$rebuild_sort) {
    // are there funny characters in sort string (field_na_zoradenie)?
    $rebuild_sort = preg_match('/[^a-zA-ZŠšČčŽž_0-9]/', $node->field_na_zoradenie['und'][0]['value']);
    //is there comma in title by not '_' in sort string (field_na_zoradenie)? - fixes missing '_' between surname and name
    $rebuild_sort = $rebuild_sort ||
        (strpos($node->title, ",") and // comma in title
        ! strpos($node->field_na_zoradenie['und'][0]['value'], "_") and // no "_" in sort string
        ! preg_match("/^[0-9]/", $node->title) and // not starting with number (in chemistry, like 1,3-butadien)
        $node->type == 'importovane_heslo' // only 'importovane_heslo' 'heslo' is sorted in a different way
        );
  }
  if ($rebuild_sort) {
    $transliterated = preg_replace("/\(^ad-|al-|af |d’ |d’|de |da |z |ze |del |\)./", '', $node->title);
    $transliterated = _beliana_remove_accents($transliterated);
    $transliterated = str_replace(",", "_", $transliterated);
    $transliterated = preg_replace('/[^a-zA-ZŠšČčŽž_0-9]/', '', $transliterated);
    $transliterated = strtolower($transliterated);
    $transliterated = str_replace("Š", "š", $transliterated); // not changed by strtolower
    $transliterated = str_replace("Č", "č", $transliterated);
    $transliterated = str_replace("Ž", "ž", $transliterated);
    $node->field_na_zoradenie['und'][0]['value'] = substr($transliterated, 0, 50);
  }

  // set field_taxsubor using the value of field_na_zoradenie 
  $vocabulary = taxonomy_vocabulary_machine_name_load('subory');
  //$subory = taxonomy_term_load_multiple(array(), array('vid' => $vocabulary->vid)); //default sort instead of Slovak
  $subory = taxonomy_get_tree($vocabulary->vid);
  foreach ($subory as $term) {
    // ignore items starting with digit, such as '1. subor'
    if (!ctype_digit(substr($term->name, 0, 1)) && strcoll($term->name, $node->field_na_zoradenie['und'][0]['value']) >= 0) {
      $node->field_taxsubor['und'][0]['tid'] = $term->tid;
      break;
    }
  }

  if ($node->type != "heslo" && $node->type != 'importovane_heslo') {
    return;
  }

  // update field_datum according to the text
  $dates = get_header_dates($node->field_text_hesla[LANGUAGE_NONE][0]['value']);
  if (count($dates) > 0) {
    // unset date fields first
    for ($i = 2; $i >= 0; $i--) {
      if( isset($node->field_datum[LANGUAGE_NONE][$i]['value']))
        unset($node->field_datum[LANGUAGE_NONE][$i]['value']);
    }
    for ($i = 0; $i < count($dates); $i++) {
      $node->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
    }
  }

  // find links pointing to articles in Ukončené/Zlúčené (ukoncenezluene) state and replace them
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($node->field_text_hesla[LANGUAGE_NONE][0]['value'], 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  foreach ($links as $item) {
    $target = substr($item->getAttribute('href'), 1); // we do not need the leading slash /
    $path = drupal_get_normal_path($target);
    $parts = explode("/", $path);
    if ($parts[0] === 'node') {
      $lnode = node_load($parts[1]); // the linked node
      if ($lnode->workbench_moderation['current']->state == 'ukoncenezluene') {
        // $znode: the node $lnode is merged to
        $znode = node_load($lnode->field_zlucene_do[LANGUAGE_NONE][0]['target_id']);
        $newpath = $znode->path['alias'];
        // replace including the closing '"' to make the replacement string unique
        $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = str_replace($target . '"', $newpath . '"', $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
        watchdog('aktualizovany odkaz', 'Heslo "' . $node->title . '": aktualizovaný odkaz na zlúčené heslo (z <a href="/' . $target . '">' . $target . '</a> na <a href="/' . $newpath . '">' . $newpath . '</a>)');
      }
    }
  }

  // remove unnecessary tags
  $html = beliana_clean_tags($node);

  //remove formatted space (non-breakable space fixed too)
  $html = str_replace("<em> </em>", " ", $html);
  $html = str_replace("<em> </em>", " ", $html);
  $html = str_replace("<strong> </strong>", " ", $html);
  $html = str_replace("<strong> </strong>", " ", $html);

  // remove empty lines at start and end

  // CKeditor inserts as empty line "<p> </p>" with non-breakable space 
  // nonbreakable space: " " here
  $html = preg_replace('#^(<p> </p>[\r\n]*)*#', '', $html);
  $html = preg_replace('#[\r\n]*$#', '', $html);
  $html = preg_replace('#([\r\n]*<p> </p>)*$#', '', $html);
  // the same with (repeated) normal space
  $html = preg_replace('#^(<p> *</p>[\r\n]*)*#', '', $html);
  $html = preg_replace('#[\r\n]*$#', '', $html);
  $html = preg_replace('#([\r\n]*<p> *</p>)*$#', '', $html);

  $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = $html;
}

/**
 * Implements hook_form_alter().
 * If user is 'nepriradený' (uid 719) and state is `zaradene`,
 * we remove option 'u_autora' and 'u redaktora' (needs_review) from possible next states.
 * This forces editor to use the view "Priradit autora" to assign article to and author
 *
 * @inheritdoc
 */
function beliana_form_alter(&$form, &$form_state, $form_id) {
  //'workbench_moderation_moderate_form': the form displaying a node 'view' or similar
  //$form['node']['#value'] is not set if user cannot modify a node
  if (isset($form['node']['#value']) && $form_id === 'workbench_moderation_moderate_form') {
    if ($form['node']['#value']->workbench_moderation['current']->state === 'zaradene' && $form['node']['#value']->uid == 719) {
      foreach ($form['state']['#options'] as $k => $v) {
        if (in_array($k, array('needs_review', 'u_autora'))) {
          unset($form['state']['#options'][$k]);
        }
      }
    }

    // Add custom submit handler.
    $form['#submit'][] = 'beliana_workflow_reaction';
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 * @inheritdoc
 */
function beliana_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  $form['#attached']['js'][] = drupal_get_path('module', 'beliana') . '/js/editor.js';
  drupal_add_js(array('beliana' => array('current_user' => array('id' => $user->uid, 'name' => $user->name))), array('type' => 'setting'));
}

/**
 * Callback function for `workbench_moderation_moderate_form` submit.
 *
 * @inheritdoc
 */
function beliana_workflow_reaction(&$form, &$form_state) {
  $values = $form_state['values'];
  if (!isset($values['node']->workbench_moderation['current']->state))
    return;

  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;

  // item is merged from other items
  if (isset($values['node']->field_zlucene_z['und'])) {
    // starting '1_korektura:' copy editor names to field_spravit_1_korekturu
    if (($cur_state === 'na_jazykovu_korekturu' && $new_state === '1_korektura'))
      _start_korektura($values);

    // transition 1_korektura >> u_vyst_redaktora_3 
    if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3')
      _transition_korektura($values, "1_korektura");

    $run_as_1_korektura = true;  // choose between two ways how to run 2_korekt_ra - FIXME needs workflow change 
    if ($run_as_1_korektura) { // 2_korekt_ra: the same procedure as 1_korektura
      // starting 'korektura': copy editor names to field_spravit_1_korekturu
      if (($cur_state === 'u_vyst_redaktora_3' && $new_state === '2_korekt_ra'))
        _start_korektura($values);

      // transition 2_korekt_ra >> u_vyst_redaktora_4 
      if ($cur_state === '2_korekt_ra' && $new_state === 'u_vyst_redaktora_4')
        _transition_korektura($values, "2_korekt_ra");
    }
    else // korekt_ra: version with only one editor selected
      _run_2_korektura_single($values);
    node_save($values['node']);
    return;
  }

  // check types heslo and importovane_heslo
  // check links
  if ($values['node']->type === 'importovane_heslo' or $values['node']->type === 'heslo') {
    // Check link correctness
    if (!_check_links($values['node'])) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // check illustration state on transition of 'importovane_heslo' to state 'importovane_u_jr2'
  if ($values['node']->type === 'importovane_heslo' and $new_state == 'importovane_u_jr2') {
    $skip = false;
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    $skip = !check_ill_at_node_transition($values['node'], $ok_states, 'state change');
    if ($skip) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // check illustrations
  if ($values['node']->type === 'ilustracia') {
    $skip = FALSE;
    if ($cur_state == 'ilustracia_u_redaktora' and $new_state == 'ilustracia_u_vyst_redaktora_5') {
      $ilu_node = $values['node'];

      if (!_check_ilu_attached($ilu_node, 'state change')) {
        $skip = TRUE;
      }

      //if (!_check_field_pouzit($ilu_node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // ignore illustrations, which are not intended for web
      if (il_display_on_web($ilu_node)) {
        if (is_null(_check_illustration_web($ilu_node, $ilu_node, 'state change'))) {
          $skip = TRUE;
        }
      }
    }

    // a problem with illustration, keep the current state
    if ($skip) {
      drupal_set_message('<strong>Stav ilustrácie nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }
}

function _check_ilu_attached(&$ilu_node, $category) {
  $query = new EntityFieldQuery();
  $query
      ->entityCondition('entity_type', "node")
      ->fieldCondition('field_ilustracia', 'target_id', $ilu_node->nid, "=");
  $result = $query->execute();
  if (isset($result['node'])) {
    return true;
  }
  else {
    il_error($ilu_node, $ilu_node, 'nie je priradená k žiadnemu heslu', $category);
    return false;
  }
}

/*
 * $ok_states: list of required illustration states 
 * return true if OK
 */

function check_ill_at_node_transition(&$node, $ok_states, $category) {
  $skip = false;
  if (isset($node->field_ilustracia[LANGUAGE_NONE])) {
    foreach ($node->field_ilustracia[LANGUAGE_NONE] as $illustration) {
      $ilu_generic_node = node_load($illustration['target_id']);
      $ilu_node = workbench_moderation_node_current_load($ilu_generic_node);

      //if (!_check_field_pouzit($node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // check illustrations, which are intended for web
      if (il_display_on_web($ilu_node)) {
        $illustration_data = _check_illustration_web($node, $ilu_node, 'state change');
        if (is_null($illustration_data)) {
          $skip = TRUE;
        }

        // Check if illustration is in correct WB status.
        if (!in_array($ilu_node->workbench_moderation['current']->state, $ok_states)) {
          il_error($node, $ilu_node, 'má byť zverejnená na webe, ale nie je v žiadnom z požadovaných stavov: [' . implode(", ", $ok_states) . ']', 'state change');
          $skip = TRUE;
        }
      }
    }
  }
  return !$skip;
}

/**
 * Extract links from node and check their validity
 *
 * @param $nid
 */
function _check_links(&$node) {
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  $text = $node->field_text_hesla['und'][0]['value'];
  $retvalue = true;
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = 0; $i < $links->length; $i++) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      // no external lins allowed
      if (url_is_external($target)) {
        drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
        $retvalue = false;
      }
      else {
        if (preg_match('?^/heslo/[^/]*?', $target)) {
          // form OK, check if it exists
          // Get non-alias path, so we can get nid from it.
          $path = drupal_get_normal_path(substr($target, 1));
          $parts = explode("/", $path);
          if ($parts[0] !== 'node') {
            drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkazované heslo neexistuje)', 'error');
            $retvalue = false;
          }
          else {
            $generic_node = node_load($parts[1]);
            $auxnode = workbench_moderation_node_current_load($generic_node);
            // linked article must be a normal one, not a pure reference article (i.e. must contain the "—" character)
            if (strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "—") === false and
                strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "➔") !== false) {
              drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkaz na odkazové alebo nesprávne formátované heslo (chýba "—" )', 'error');
              $retvalue = false;
            }
          }
        }
        else {
          // not in the form '/heslo/alias'
          drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
          $retvalue = false;
        }
      }
    }
  }
  return $retvalue;
}

/**
 * Helper function: start 'korektura'
 */
function _start_korektura(&$values) {
  // copy editor names to field_spravit_1_korekturu
  foreach ($values['node']->field_redaktori_zluceneho['und'] as $redaktor)
    $values['node']->field_spravit_1_korekturu['und'][]['tid'] = $redaktor['tid'];
  // take the next editor
  $values['node']->field_lexikalna_skupina['und'] = array();
  $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_korektura(&$values, $korektura) {
  if (!empty($values['node']->field_spravit_1_korekturu['und'])) {
    // return back to '$korektura'
    $values['node']->workbench_moderation_state_new = $korektura;
    // take the next editor
    $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
  }
  else {
    // we are done, restore the initial status
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function: transition to 2_korekt_ra
 */
function _run_2_korektura_single(&$values) {
  if ($values['state'] === '2_korekt_ra') {
    if (count($values['node']->field_lexikalna_skupina['und']) != 1) {
      //MS drupal_set_message('Ako lexikálnu skupinu zadajte meno požadovaného redaktora.', 'error');
      drupal_set_message('Heslo je zlúčené a má viacero lexikálnych skupín. Pri odosielaní na 2. korektúru však heslo môže mať len jednu lexikálnu skupinu.', 'error');
      drupal_set_message('Lexikálne skupiny upravte, heslo uložte a potom odošlite na 2. korektúru ešte raz. Po návrate z 2. korektúry sa lexikálne skupiny vrátia do pôvodného stavu.', 'error');
      $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
    }
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_vyst_redaktora_4' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U výstupného redaktora 4. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_jaz_redaktora_2' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U jazykového redaktora 2. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  if ($values['node']->workbench_moderation['current']->state === '2_korekt_ra' && $values['state'] === 'u_vyst_redaktora_3') {
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function to get user autocomplete form.
 *
 * @return array
 *   Array with form element.
 */
function _beliana_assign_user_form() {
  $form = array();
  $form['user'] = array(
    '#type' => 'textfield',
    '#title' => t('Vyberte autora, ktorému chcete heslo priradiť'),
    '#required' => TRUE,
    '#autocomplete_path' => 'user/autocomplete',
  );
  return $form;
}

/**
 * Helper function for user autocomplete form validation.
 *
 * @param array $form_state
 *   Array with form values.
 */
function _beliana_validate_assign_user_form(&$form_state) {
  if (user_load_by_name($form_state['values']['user']) === FALSE) {
    form_set_error('user', t('You need to choose existing user'));
  }
}

/**
 * Helper function for processing user autocomplete form submit.
 *
 * @param array $form_state
 *   Array with form values.
 * @param string $state
 *   New status for node.
 *
 * @return array
 *   Keyed array with user nd status.
 */
function _beliana_submit_assign_user_form($form_state, $state) {
  $return = array();
  $return['user'] = $form_state['values']['user'];
  $return['status'] = $state;
  return $return;
}

/**
 * Helper function changing node author and workflow status.
 *
 * @param object $node
 *   Object of node.
 * @param array $context
 *   Array of context.
 *
 * @throws \Exception
 *
 * @return FALSE
 *   Return FALSE if assigning of the new group failed.
 */
function _beliana_assign_user(&$node, $context) {
  $user = user_load_by_name($context['user']);
  if ($user !== FALSE) {
    if (!isset($user->workbench_access[reset($node->workbench_access)])) {
      drupal_set_message($node->title . ' sa nepodarilo priradiť autorovi, pretože nemá zodpovedajúcu lexikálnu skupinu.', 'error');
      return FALSE;
    }
    $node->uid = $user->uid;
    node_save($node);
    workbench_moderation_moderate($node, $context['status']);
  }
}

/**
 * Helper function removing accents.
 *
 * @param string $text
 *   String we want to remove accents from.
 *
 * @return string
 *   String without accents.
 */
function _beliana_remove_accents($text) {
  $trans = array(
    'À' => 'A',
    'Á' => 'A',
    'Â' => 'A',
    'Ã' => 'A',
    'Ä' => 'A',
    'Å' => 'A',
    'Ç' => 'C',
    'È' => 'E',
    'É' => 'E',
    'Ê' => 'E',
    'Ë' => 'E',
    'Ì' => 'I',
    'Í' => 'I',
    'Î' => 'I',
    'Ï' => 'I',
    'Ñ' => 'N',
    'Ò' => 'O',
    'Ó' => 'O',
    'Ô' => 'O',
    'Õ' => 'O',
    'Ö' => 'O',
    'Ø' => 'O',
    'Ù' => 'U',
    'Ú' => 'U',
    'Û' => 'U',
    'Ü' => 'U',
    'Ý' => 'Y',
    'à' => 'a',
    'æ' => 'ae',
    'Æ' => 'ae',
    'á' => 'a',
    'â' => 'a',
    'ã' => 'a',
    'ä' => 'a',
    'å' => 'a',
    'ç' => 'c',
    'è' => 'e',
    'é' => 'e',
    'ê' => 'e',
    'ë' => 'e',
    'ì' => 'i',
    'í' => 'i',
    'î' => 'i',
    'ï' => 'i',
    'ñ' => 'n',
    'ò' => 'o',
    'ó' => 'o',
    'ô' => 'o',
    'õ' => 'o',
    'ö' => 'o',
    'ø' => 'o',
    'ù' => 'u',
    'ú' => 'u',
    'û' => 'u',
    'ü' => 'u',
    'ý' => 'y',
    'ÿ' => 'y',
    'Ā' => 'A',
    'ā' => 'a',
    'Ă' => 'A',
    'ă' => 'a',
    'Ą' => 'A',
    'ą' => 'a',
    'Ć' => 'C',
    'ć' => 'c',
    'Ĉ' => 'C',
    'ĉ' => 'c',
    'Ċ' => 'C',
    'ċ' => 'c',
    'Ď' => 'D',
    'ď' => 'd',
    'Đ' => 'D',
    'đ' => 'd',
    'Ē' => 'E',
    'ē' => 'e',
    'Ĕ' => 'E',
    'ĕ' => 'e',
    'Ė' => 'E',
    'ė' => 'e',
    'Ę' => 'E',
    'ę' => 'e',
    'Ě' => 'E',
    'ě' => 'e',
    'Ĝ' => 'G',
    'ĝ' => 'g',
    'Ğ' => 'G',
    'ğ' => 'g',
    'Ġ' => 'G',
    'ġ' => 'g',
    'Ģ' => 'G',
    'ģ' => 'g',
    'Ĥ' => 'H',
    'ĥ' => 'h',
    'Ħ' => 'H',
    'ħ' => 'h',
    'Ĩ' => 'I',
    'ĩ' => 'i',
    'Ī' => 'I',
    'ī' => 'i',
    'Ĭ' => 'I',
    'ĭ' => 'i',
    'Į' => 'I',
    'į' => 'i',
    'İ' => 'I',
    'ı' => 'i',
    'Ĵ' => 'J',
    'ĵ' => 'j',
    'Ķ' => 'K',
    'ķ' => 'k',
    'Ĺ' => 'L',
    'ĺ' => 'l',
    'Ļ' => 'L',
    'ļ' => 'l',
    'Ľ' => 'L',
    'ľ' => 'l',
    'Ŀ' => 'L',
    'ŀ' => 'l',
    'Ł' => 'L',
    'ł' => 'l',
    'Ń' => 'N',
    'ń' => 'n',
    'Ņ' => 'N',
    'ņ' => 'n',
    'Ň' => 'N',
    'ň' => 'n',
    'ŉ' => 'n',
    'Ō' => 'O',
    'ō' => 'o',
    'Ŏ' => 'O',
    'ŏ' => 'o',
    'Ő' => 'O',
    'ő' => 'o',
    'Ŕ' => 'R',
    'ŕ' => 'r',
    'Ŗ' => 'R',
    'ŗ' => 'r',
    'Ř' => 'R',
    'ř' => 'r',
    'Ś' => 'S',
    'ś' => 's',
    'Ŝ' => 'S',
    'ŝ' => 's',
    'Ş' => 'S',
    'ş' => 's',
    'Ţ' => 'T',
    'ţ' => 't',
    'Ť' => 'T',
    'ť' => 't',
    'Ŧ' => 'T',
    'ŧ' => 't',
    'Ũ' => 'U',
    'ũ' => 'u',
    'Ū' => 'U',
    'ū' => 'u',
    'Ŭ' => 'U',
    'ŭ' => 'u',
    'Ů' => 'U',
    'ů' => 'u',
    'Ű' => 'U',
    'ű' => 'u',
    'Ų' => 'U',
    'ų' => 'u',
    'Ŵ' => 'W',
    'ŵ' => 'w',
    'Ŷ' => 'Y',
    'ŷ' => 'y',
    'Ÿ' => 'Y',
    'Ź' => 'Z',
    'ź' => 'z',
    'Ż' => 'Z',
    'ż' => 'z',
    'ƀ' => 'b',
    'Ɓ' => 'B',
    'Ƃ' => 'B',
    'ƃ' => 'b',
    'Ƈ' => 'C',
    'ƈ' => 'c',
    'Ɗ' => 'D',
    'Ƌ' => 'D',
    'ƌ' => 'd',
    'Ƒ' => 'F',
    'ƒ' => 'f',
    'Ɠ' => 'G',
    'Ɨ' => 'I',
    'Ƙ' => 'K',
    'ƙ' => 'k',
    'ƚ' => 'l',
    'Ɲ' => 'N',
    'ƞ' => 'n',
    'Ɵ' => 'O',
    'Ơ' => 'O',
    'ơ' => 'o',
    'Ƥ' => 'P',
    'ƥ' => 'p',
    'ƫ' => 't',
    'Ƭ' => 'T',
    'ƭ' => 't',
    'Ʈ' => 'T',
    'Ư' => 'U',
    'ư' => 'u',
    'Ʋ' => 'V',
    'Ƴ' => 'Y',
    'ƴ' => 'y',
    'Ƶ' => 'Z',
    'ƶ' => 'z',
    'ǅ' => 'D',
    'ǈ' => 'L',
    'ǋ' => 'N',
    'Ǎ' => 'A',
    'ǎ' => 'a',
    'Ǐ' => 'I',
    'ǐ' => 'i',
    'Ǒ' => 'O',
    'ǒ' => 'o',
    'Ǔ' => 'U',
    'ǔ' => 'u',
    'Ǖ' => 'U',
    'ǖ' => 'u',
    'Ǘ' => 'U',
    'ǘ' => 'u',
    'Ǚ' => 'U',
    'ǚ' => 'u',
    'Ǜ' => 'U',
    'ǜ' => 'u',
    'Ǟ' => 'A',
    'ǟ' => 'a',
    'Ǡ' => 'A',
    'ǡ' => 'a',
    'Ǥ' => 'G',
    'ǥ' => 'g',
    'Ǧ' => 'G',
    'ǧ' => 'g',
    'Ǩ' => 'K',
    'ǩ' => 'k',
    'Ǫ' => 'O',
    'ǫ' => 'o',
    'Ǭ' => 'O',
    'ǭ' => 'o',
    'ǰ' => 'j',
    'ǲ' => 'D',
    'Ǵ' => 'G',
    'ǵ' => 'g',
    'Ǹ' => 'N',
    'ǹ' => 'n',
    'Ǻ' => 'A',
    'ǻ' => 'a',
    'Ǿ' => 'O',
    'ǿ' => 'o',
    'Ȁ' => 'A',
    'ȁ' => 'a',
    'Ȃ' => 'A',
    'ȃ' => 'a',
    'Ȅ' => 'E',
    'ȅ' => 'e',
    'Ȇ' => 'E',
    'ȇ' => 'e',
    'Ȉ' => 'I',
    'ȉ' => 'i',
    'Ȋ' => 'I',
    'ȋ' => 'i',
    'Ȍ' => 'O',
    'ȍ' => 'o',
    'Ȏ' => 'O',
    'ȏ' => 'o',
    'Ȑ' => 'R',
    'ȑ' => 'r',
    'Ȓ' => 'R',
    'ȓ' => 'r',
    'Ȕ' => 'U',
    'ȕ' => 'u',
    'Ȗ' => 'U',
    'ȗ' => 'u',
    'Ș' => 'S',
    'ș' => 's',
    'Ț' => 'T',
    'ț' => 't',
    'Ȟ' => 'H',
    'ȟ' => 'h',
    'Ƞ' => 'N',
    'ȡ' => 'd',
    'Ȥ' => 'Z',
    'ȥ' => 'z',
    'Ȧ' => 'A',
    'ȧ' => 'a',
    'Ȩ' => 'E',
    'ȩ' => 'e',
    'Ȫ' => 'O',
    'ȫ' => 'o',
    'Ȭ' => 'O',
    'ȭ' => 'o',
    'Ȯ' => 'O',
    'ȯ' => 'o',
    'Ȱ' => 'O',
    'ȱ' => 'o',
    'Ȳ' => 'Y',
    'ȳ' => 'y',
    'ȴ' => 'l',
    'ȵ' => 'n',
    'ȶ' => 't',
    'ȷ' => 'j',
    'Ⱥ' => 'A',
    'Ȼ' => 'C',
    'ȼ' => 'c',
    'Ƚ' => 'L',
    'Ⱦ' => 'T',
    'ȿ' => 's',
    'ɀ' => 'z',
    'Ƀ' => 'B',
    'Ʉ' => 'U',
    'Ɇ' => 'E',
    'ɇ' => 'e',
    'Ɉ' => 'J',
    'ɉ' => 'j',
    'ɋ' => 'q',
    'Ɍ' => 'R',
    'ɍ' => 'r',
    'Ɏ' => 'Y',
    'ɏ' => 'y',
    'ɓ' => 'b',
    'ɕ' => 'c',
    'ɖ' => 'd',
    'ɗ' => 'd',
    'ɟ' => 'j',
    'ɠ' => 'g',
    'ɦ' => 'h',
    'ɨ' => 'i',
    'ɫ' => 'l',
    'ɬ' => 'l',
    'ɭ' => 'l',
    'ɱ' => 'm',
    'ɲ' => 'n',
    'ɳ' => 'n',
    'ɵ' => 'o',
    'ɼ' => 'r',
    'ɽ' => 'r',
    'ɾ' => 'r',
    'ʂ' => 's',
    'ʄ' => 'j',
    'ʈ' => 't',
    'ʉ' => 'u',
    'ʋ' => 'v',
    'ʐ' => 'z',
    'ʑ' => 'z',
    'ʝ' => 'j',
    'ʠ' => 'q',
    'ͣ' => 'a',
    'ͤ' => 'e',
    'ͥ' => 'i',
    'ͦ' => 'o',
    'ͧ' => 'u',
    'ͨ' => 'c',
    'ͩ' => 'd',
    'ͪ' => 'h',
    'ͫ' => 'm',
    'ͬ' => 'r',
    'ͭ' => 't',
    'ͮ' => 'v',
    'ͯ' => 'x',
    'ᵢ' => 'i',
    'ᵣ' => 'r',
    'ᵤ' => 'u',
    'ᵥ' => 'v',
    'ᵬ' => 'b',
    'ᵭ' => 'd',
    'ᵮ' => 'f',
    'ᵯ' => 'm',
    'ᵰ' => 'n',
    'ᵱ' => 'p',
    'ᵲ' => 'r',
    'ᵳ' => 'r',
    'ᵴ' => 's',
    'ᵵ' => 't',
    'ᵶ' => 'z',
    'ᵻ' => 'i',
    'ᵽ' => 'p',
    'ᵾ' => 'u',
    'ᶀ' => 'b',
    'ᶁ' => 'd',
    'ᶂ' => 'f',
    'ᶃ' => 'g',
    'ᶄ' => 'k',
    'ᶅ' => 'l',
    'ᶆ' => 'm',
    'ᶇ' => 'n',
    'ᶈ' => 'p',
    'ᶉ' => 'r',
    'ᶊ' => 's',
    'ᶌ' => 'v',
    'ᶍ' => 'x',
    'ᶎ' => 'z',
    'ᶏ' => 'a',
    'ᶑ' => 'd',
    'ᶒ' => 'e',
    'ᶖ' => 'i',
    'ᶙ' => 'u',
    '᷊' => 'r',
    'ᷗ' => 'c',
    'ᷚ' => 'g',
    'ᷜ' => 'k',
    'ᷝ' => 'l',
    'ᷠ' => 'n',
    'ᷣ' => 'r',
    'ᷤ' => 's',
    'ᷦ' => 'z',
    'Ḁ' => 'A',
    'ḁ' => 'a',
    'Ḃ' => 'B',
    'ḃ' => 'b',
    'Ḅ' => 'B',
    'ḅ' => 'b',
    'Ḇ' => 'B',
    'ḇ' => 'b',
    'Ḉ' => 'C',
    'ḉ' => 'c',
    'Ḋ' => 'D',
    'ḋ' => 'd',
    'Ḍ' => 'D',
    'ḍ' => 'd',
    'Ḏ' => 'D',
    'ḏ' => 'd',
    'Ḑ' => 'D',
    'ḑ' => 'd',
    'Ḓ' => 'D',
    'ḓ' => 'd',
    'Ḕ' => 'E',
    'ḕ' => 'e',
    'Ḗ' => 'E',
    'ḗ' => 'e',
    'Ḙ' => 'E',
    'ḙ' => 'e',
    'Ḛ' => 'E',
    'ḛ' => 'e',
    'Ḝ' => 'E',
    'ḝ' => 'e',
    'Ḟ' => 'F',
    'ḟ' => 'f',
    'Ḡ' => 'G',
    'ḡ' => 'g',
    'Ḣ' => 'H',
    'ḣ' => 'h',
    'Ḥ' => 'H',
    'ḥ' => 'h',
    'Ḧ' => 'H',
    'ḧ' => 'h',
    'Ḩ' => 'H',
    'ḩ' => 'h',
    'Ḫ' => 'H',
    'ḫ' => 'h',
    'Ḭ' => 'I',
    'ḭ' => 'i',
    'Ḯ' => 'I',
    'ḯ' => 'i',
    'Ḱ' => 'K',
    'ḱ' => 'k',
    'Ḳ' => 'K',
    'ḳ' => 'k',
    'Ḵ' => 'K',
    'ḵ' => 'k',
    'Ḷ' => 'L',
    'ḷ' => 'l',
    'Ḹ' => 'L',
    'ḹ' => 'l',
    'Ḻ' => 'L',
    'ḻ' => 'l',
    'Ḽ' => 'L',
    'ḽ' => 'l',
    'Ḿ' => 'M',
    'ḿ' => 'm',
    'Ṁ' => 'M',
    'ṁ' => 'm',
    'Ṃ' => 'M',
    'ṃ' => 'm',
    'Ṅ' => 'N',
    'ṅ' => 'n',
    'Ṇ' => 'N',
    'ṇ' => 'n',
    'Ṉ' => 'N',
    'ṉ' => 'n',
    'Ṋ' => 'N',
    'ṋ' => 'n',
    'Ṍ' => 'O',
    'ṍ' => 'o',
    'Ṏ' => 'O',
    'ṏ' => 'o',
    'Ṑ' => 'O',
    'ṑ' => 'o',
    'Ṓ' => 'O',
    'ṓ' => 'o',
    'Ṕ' => 'P',
    'ṕ' => 'p',
    'Ṗ' => 'P',
    'ṗ' => 'p',
    'Ṙ' => 'R',
    'ṙ' => 'r',
    'Ṛ' => 'R',
    'ṛ' => 'r',
    'Ṝ' => 'R',
    'ṝ' => 'r',
    'Ṟ' => 'R',
    'ṟ' => 'r',
    'Ṡ' => 'S',
    'ṡ' => 's',
    'Ṣ' => 'S',
    'ṣ' => 's',
    'Ṥ' => 'S',
    'ṥ' => 's',
    'Ṧ' => 'S',
    'ṧ' => 's',
    'Ṩ' => 'S',
    'ṩ' => 's',
    'Ṫ' => 'T',
    'ṫ' => 't',
    'Ṭ' => 'T',
    'ṭ' => 't',
    'Ṯ' => 'T',
    'ṯ' => 't',
    'Ṱ' => 'T',
    'ṱ' => 't',
    'Ṳ' => 'U',
    'ṳ' => 'u',
    'Ṵ' => 'U',
    'ṵ' => 'u',
    'Ṷ' => 'U',
    'ṷ' => 'u',
    'Ṹ' => 'U',
    'ṹ' => 'u',
    'Ṻ' => 'U',
    'ṻ' => 'u',
    'Ṽ' => 'V',
    'ṽ' => 'v',
    'Ṿ' => 'V',
    'ṿ' => 'v',
    'Ẁ' => 'W',
    'ẁ' => 'w',
    'Ẃ' => 'W',
    'ẃ' => 'w',
    'Ẅ' => 'W',
    'ẅ' => 'w',
    'Ẇ' => 'W',
    'ẇ' => 'w',
    'Ẉ' => 'W',
    'ẉ' => 'w',
    'Ẋ' => 'X',
    'ẋ' => 'x',
    'Ẍ' => 'X',
    'ẍ' => 'x',
    'Ẏ' => 'Y',
    'ẏ' => 'y',
    'Ẑ' => 'Z',
    'ẑ' => 'z',
    'Ẓ' => 'Z',
    'ẓ' => 'z',
    'Ẕ' => 'Z',
    'ẕ' => 'z',
    'ẖ' => 'h',
    'ẗ' => 't',
    'ẘ' => 'w',
    'ẙ' => 'y',
    'ẚ' => 'a',
    'Ạ' => 'A',
    'ạ' => 'a',
    'Ả' => 'A',
    'ả' => 'a',
    'Ấ' => 'A',
    'ấ' => 'a',
    'Ầ' => 'A',
    'ầ' => 'a',
    'Ẩ' => 'A',
    'ẩ' => 'a',
    'Ẫ' => 'A',
    'ẫ' => 'a',
    'Ậ' => 'A',
    'ậ' => 'a',
    'Ắ' => 'A',
    'ắ' => 'a',
    'Ằ' => 'A',
    'ằ' => 'a',
    'Ẳ' => 'A',
    'ẳ' => 'a',
    'Ẵ' => 'A',
    'ẵ' => 'a',
    'Ặ' => 'A',
    'ặ' => 'a',
    'Ẹ' => 'E',
    'ẹ' => 'e',
    'Ẻ' => 'E',
    'ẻ' => 'e',
    'Ẽ' => 'E',
    'ẽ' => 'e',
    'Ế' => 'E',
    'ế' => 'e',
    'Ề' => 'E',
    'ề' => 'e',
    'Ể' => 'E',
    'ể' => 'e',
    'Ễ' => 'E',
    'ễ' => 'e',
    'Ệ' => 'E',
    'ệ' => 'e',
    'Ỉ' => 'I',
    'ỉ' => 'i',
    'Ị' => 'I',
    'ị' => 'i',
    'Ọ' => 'O',
    'ọ' => 'o',
    'Ỏ' => 'O',
    'ỏ' => 'o',
    'Ố' => 'O',
    'ố' => 'o',
    'Ồ' => 'O',
    'ồ' => 'o',
    'Ổ' => 'O',
    'ổ' => 'o',
    'Ỗ' => 'O',
    'ỗ' => 'o',
    'Ộ' => 'O',
    'ộ' => 'o',
    'Ớ' => 'O',
    'ớ' => 'o',
    'Ờ' => 'O',
    'ờ' => 'o',
    'Ở' => 'O',
    'ở' => 'o',
    'Ỡ' => 'O',
    'ỡ' => 'o',
    'Ợ' => 'O',
    'ợ' => 'o',
    'Ụ' => 'U',
    'ụ' => 'u',
    'Ủ' => 'U',
    'ủ' => 'u',
    'Ứ' => 'U',
    'ứ' => 'u',
    'Ừ' => 'U',
    'ừ' => 'u',
    'Ử' => 'U',
    'ử' => 'u',
    'Ữ' => 'U',
    'ữ' => 'u',
    'Ự' => 'U',
    'ự' => 'u',
    'Ỳ' => 'Y',
    'ỳ' => 'y',
    'Ỵ' => 'Y',
    'ỵ' => 'y',
    'Ỷ' => 'Y',
    'ỷ' => 'y',
    'Ỹ' => 'Y',
    'ỹ' => 'y',
    'Ỿ' => 'Y',
    'ỿ' => 'y',
    'ⁱ' => 'i',
    'ⁿ' => 'n',
    'ₐ' => 'a',
    'ₑ' => 'e',
    'ₒ' => 'o',
    'ₓ' => 'x',
    '⒜' => 'a',
    '⒝' => 'b',
    '⒞' => 'c',
    '⒟' => 'd',
    '⒠' => 'e',
    '⒡' => 'f',
    '⒢' => 'g',
    '⒣' => 'h',
    '⒤' => 'i',
    '⒥' => 'j',
    '⒦' => 'k',
    '⒧' => 'l',
    '⒨' => 'm',
    '⒩' => 'n',
    '⒪' => 'o',
    '⒫' => 'p',
    '⒬' => 'q',
    '⒭' => 'r',
    '⒮' => 's',
    '⒯' => 't',
    '⒰' => 'u',
    '⒱' => 'v',
    '⒲' => 'w',
    '⒳' => 'x',
    '⒴' => 'y',
    '⒵' => 'z',
    'Ⓐ' => 'A',
    'Ⓑ' => 'B',
    'Ⓒ' => 'C',
    'Ⓓ' => 'D',
    'Ⓔ' => 'E',
    'Ⓕ' => 'F',
    'Ⓖ' => 'G',
    'Ⓗ' => 'H',
    'Ⓘ' => 'I',
    'Ⓙ' => 'J',
    'Ⓚ' => 'K',
    'Ⓛ' => 'L',
    'Ⓜ' => 'M',
    'Ⓝ' => 'N',
    'Ⓞ' => 'O',
    'Ⓟ' => 'P',
    'Ⓠ' => 'Q',
    'Ⓡ' => 'R',
    'Ⓢ' => 'S',
    'Ⓣ' => 'T',
    'Ⓤ' => 'U',
    'Ⓥ' => 'V',
    'Ⓦ' => 'W',
    'Ⓧ' => 'X',
    'Ⓨ' => 'Y',
    'Ⓩ' => 'Z',
    'ⓐ' => 'a',
    'ⓑ' => 'b',
    'ⓒ' => 'c',
    'ⓓ' => 'd',
    'ⓔ' => 'e',
    'ⓕ' => 'f',
    'ⓖ' => 'g',
    'ⓗ' => 'h',
    'ⓘ' => 'i',
    'ⓙ' => 'j',
    'ⓚ' => 'k',
    'ⓛ' => 'l',
    'ⓜ' => 'm',
    'ⓝ' => 'n',
    'ⓞ' => 'o',
    'ⓟ' => 'p',
    'ⓠ' => 'q',
    'ⓡ' => 'r',
    'ⓢ' => 's',
    'ⓣ' => 't',
    'ⓤ' => 'u',
    'ⓥ' => 'v',
    'ⓦ' => 'w',
    'ⓧ' => 'x',
    'ⓨ' => 'y',
    'ⓩ' => 'z',
    'Ⱡ' => 'L',
    'ⱡ' => 'l',
    'Ɫ' => 'L',
    'Ᵽ' => 'P',
    'Ɽ' => 'R',
    'ⱥ' => 'a',
    'ⱦ' => 't',
    'Ⱨ' => 'H',
    'ⱨ' => 'h',
    'Ⱪ' => 'K',
    'ⱪ' => 'k',
    'Ⱬ' => 'Z',
    'ⱬ' => 'z',
    'Ɱ' => 'M',
    'ⱱ' => 'v',
    'Ⱳ' => 'W',
    'ⱳ' => 'w',
    'ⱴ' => 'v',
    'ⱸ' => 'e',
    'ⱺ' => 'o',
    'ⱼ' => 'j',
    'Ꝁ' => 'K',
    'ꝁ' => 'k',
    'Ꝃ' => 'K',
    'ꝃ' => 'k',
    'Ꝅ' => 'K',
    'ꝅ' => 'k',
    'Ꝉ' => 'L',
    'ꝉ' => 'l',
    'Ꝋ' => 'O',
    'ꝋ' => 'o',
    'Ꝍ' => 'O',
    'ꝍ' => 'o',
    'Ꝑ' => 'P',
    'ꝑ' => 'p',
    'Ꝓ' => 'P',
    'ꝓ' => 'p',
    'Ꝕ' => 'P',
    'ꝕ' => 'p',
    'Ꝗ' => 'Q',
    'ꝗ' => 'q',
    'Ꝙ' => 'Q',
    'ꝙ' => 'q',
    'Ꝛ' => 'R',
    'ꝛ' => 'r',
    'Ꝟ' => 'V',
    'ꝟ' => 'v',
    'Ａ' => 'A',
    'Ｂ' => 'B',
    'Ｃ' => 'C',
    'Ｄ' => 'D',
    'Ｅ' => 'E',
    'Ｆ' => 'F',
    'Ｇ' => 'G',
    'Ｈ' => 'H',
    'Ｉ' => 'I',
    'Ｊ' => 'J',
    'Ｋ' => 'K',
    'Ｌ' => 'L',
    'Ｍ' => 'M',
    'Ｎ' => 'N',
    'Ｏ' => 'O',
    'Ｐ' => 'P',
    'Ｑ' => 'Q',
    'Ｒ' => 'R',
    'Ｓ' => 'S',
    'Ｔ' => 'T',
    'Ｕ' => 'U',
    'Ｖ' => 'V',
    'Ｗ' => 'W',
    'Ｘ' => 'X',
    'Ｙ' => 'Y',
    'Ｚ' => 'Z',
    'ａ' => 'a',
    'ｂ' => 'b',
    'ｃ' => 'c',
    'ｄ' => 'd',
    'ｅ' => 'e',
    'ｆ' => 'f',
    'ｇ' => 'g',
    'ｈ' => 'h',
    'ｉ' => 'i',
    'ｊ' => 'j',
    'ｋ' => 'k',
    'ｌ' => 'l',
    'ｍ' => 'm',
    'ｎ' => 'n',
    'ｏ' => 'o',
    'ｐ' => 'p',
    'ｑ' => 'q',
    'ｒ' => 'r',
    'ｓ' => 's',
    'ｔ' => 't',
    'ｕ' => 'u',
    'ｖ' => 'v',
    'ｗ' => 'w',
    'ｘ' => 'x',
    'ｙ' => 'y',
    'ｚ' => 'z',
  );
  return strtr($text, $trans);
}

/**
 * Helper function to extract dates from an article header
 *
 * @param string $text
 *   String with the article text (field_text_hesla)
 *
 * @return array
 *   Array of dates to be stored in field_datum, may be empty
 */
function get_header_dates($text) {
  $dates = array();

  # ignore pure reference articles  (they do not contain em dash "—")
  $exploded = explode("—", $text);
  if (count($exploded) > 1) {
    // $header = $exploded[0];
    // remove tags first
    $header = preg_replace('/<[^>]*>/', '', $exploded[0]);
    # find all dates in header
    $pattern = "/ (\d{1,2}. \d{1,2}. \d{4} )/";
    preg_match_all($pattern, $header, $matches);

    # convert dates to importable form and save them to 'dates'
    foreach ($matches[0] as $mt) {
      sscanf($mt, "%d. %d. %d", $d, $m, $y);
      if ($y > 999) { # drupal does not like dates prior to 1000
        $odate = sprintf("%d-%02d-%02dT00:00:00", $y, $m, $d);
        array_push($dates, $odate);
      }
    }
  }
  return $dates;
}

// delete unnecessary tags from node text
function beliana_clean_tags($node)
{ 
  $text = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
  $internalErrorsState = libxml_use_internal_errors(true); 
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));

  // handle errors locally
  $errors = libxml_get_errors();
  if ($errors) {
    # clear errors and restore error loging status
    foreach ($errors as $error) {
      html_error($node, $error, "Chyba HTML syntaxe (clean save)"); 
    }
    libxml_clear_errors();
    libxml_use_internal_errors($internalErrorsState);   
    # return unchanged text
    return $text;
  }
  # clear errors and restore error loging status
  libxml_clear_errors();
  libxml_use_internal_errors($internalErrorsState); 

  $xpath = new DOMXPath($dom);

  // remove tags completely: <ins>, <span>, ....
  $rmtags=array(
  '//ins[not(@*)]',
  '//span[not(@*)]',
  '//span[@style="background-color:null"]',
  '//span[@style="background-color:#ffffff"]',
  '//span[@style="background-color:white"]',
  '//td/p',
  );
  foreach ($rmtags as $tag) {
  //_remove_node($xpath, $tag);
  // Move all tag node content to its parent node just before it.
  foreach ($xpath->query($tag) as $node) {
    while ($node->hasChildNodes()) {
      $child = $node->removeChild($node->firstChild);
      $node->parentNode->insertBefore($child, $node);
    }
    // Remove the tag node.
    $node->parentNode->removeChild($node);
    }
  }

  // remove tag attributes
  $cltags=array(
    array("a","style"),
    array("a","target"),
    array("td","style"),
    array("th","class"),
    array("table","border"),
    array("table","cellspacing"),
    array("table","cellpadding"),
    array("table","style"),
  );
  foreach ($cltags as $cltag) {
    $tagstring = "//".$cltag[0]."[@".$cltag[1]."]";
    foreach ($xpath->query($tagstring) as $tag) {
      $sNode = $tag->getAttributeNode( $cltag[1] );
      $tag->removeAttributeNode( $sNode );
    }
  }

  $fragment = '';
  foreach ($dom->getElementsByTagName('body')->item(0)->childNodes as $chnode) {
    $fragment .= $dom->saveHtml($chnode);
  }
  //fix a problem caused somewhere above (<br> is later replaced by a pair of  <br /> tags)
  $fragment = str_replace("<br>", "<br />", $fragment);

  return $fragment;
}
