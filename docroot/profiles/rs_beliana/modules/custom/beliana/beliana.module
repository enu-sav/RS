<?php

# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana module.
 */

/**
 * Implements hook_views_api().
 */
function beliana_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'beliana') . '/views',
  );
}

/**
 * Implements hook_menu().
 *
 * @inheritdoc
 */
function beliana_menu() {
  $items = array();
  $items['admin/users-list'] = array(
    'title' => 'Users list',
    'page callback' => 'beliana_users_list',
    'access arguments' => array('bypass node access'),
  );

  $items['admin/group-list'] = array(
    'title' => 'Group list',
    'page callback' => 'beliana_group_list',
    'access arguments' => array('bypass node access'),
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * @inheritdoc
 */
function beliana_menu_alter(&$items) {
  if (isset($items['admin/workbench/sections'])) {
    unset($items['admin/workbench/sections']);
  }

  if (isset($items['node/%node/draft'])) {
    unset($items['node/%node/draft']);
  }

  if (isset($items['node/%node/revisions'])) {
    unset($items['node/%node/revisions']);
  }

  /* get rid of the 'Index' item in the menu */
  if (isset($items['admin/index'])) {
    unset($items['admin/index']);
  }

  /* get rid of the create/forum item in the menu */
  /* not a good idea - blocks the possibility to create topics */
  //if (isset($items['node/add/forum'])) {
  //unset($items['node/add/forum']);
  //}
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * @inheritdoc
 */
function beliana_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  if (isset($data['tabs'][0]['output'])) {
    foreach ($data['tabs'][0]['output'] as $i => $tab) {
      if (in_array($tab['#link']['path'], array(
            'admin/tasks',
            'admin/index',
          ))) {
        unset($data['tabs'][0]['output'][$i]);
      }
    }
  }
}

function beliana_workbench_access_check($op, $type, $access_ids, $account_access) {
  global $user;

  if ($op == 'view') {
    return TRUE;
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * @inheritdoc
 */
function beliana_field_formatter_info() {
  return array(
    'beliana_external_image' => array(
      'label' => t('External image'),
      'field types' => array('url'),
      'settings' => array(
        'size' => 'medium',
        'link' => 0
      )
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function beliana_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  $element['size'] = array(
    '#type' => 'select',
    '#title' => t('Image style'),
    '#default_value' => $settings['size'],
  );

  $element['link'] = array(
    '#type' => 'select',
    '#title' => t('Link'),
    '#default_value' => $settings['link'],
    '#options' => array(t('No'), t('Yes')),
  );

  foreach (image_styles() as $key => $style) {
    $element['size']['#options'][$key] = $style['label'];
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function beliana_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $styles = image_styles();
  $options = array(t('No'), t('Yes'));

  return t('Image style: @size, Link: @link', array('@size' => $styles[$settings['size']]['label'], '@link' => $options[$settings['link']]));
}

/**
 * Implements hook_field_formatter_view().
 *
 * @inheritdoc
 */
function beliana_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  if ($display['type'] == 'beliana_external_image') {
    $width = 100;
    $styles = image_styles();

    foreach ($styles[$settings['size']]['effects'] as $effect) {
      if ($effect['name'] == 'image_scale') {
        $width = $effect['data']['width'];
      }
    }

    foreach ($items as $delta => $item) {
      $img = '<img src="' . $item['value'] . '" width="' . $width . '" />';

      $element[$delta] = array('#markup' => $img);
      if ($settings['link'] > 0) {
        $element[$delta]['#markup'] = l($img, $item['value'], array('html' => TRUE, 'external' => TRUE));
      }
    }
  }

  return $element;
}

/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */
function beliana_group_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    if ($term->depth == 0) {
      $output .= '<h1>' . $term->name . '</h1>';
    }
    else {
      //$output .= '<h3> Lexikálna skupina: <em>' . $term->name . '</em></h3>';
      $output .= '<strong>' . $term->name . '</strong>';
      $output .= '<ul>';
      foreach ($users as $user) {
        if (isset($user->workbench_access[$term->tid])) {
          $output .= '<li>'
              . $user->name . ', '
              . $user->field_meno['und'][0]['value'] . ', '
              . $user->field_priezvisko['und'][0]['value'] . ', ';
          if (isset($user->field_autorska_zmluva['und'])) {
            $output .= $user->mail . ', '
                . $user->field_autorska_zmluva['und'][0]['value'] . '</li>';
          }
          else {
            $output .= $user->mail . '</li>';
          }
        }
      }
      //$output .= '</ul><br><br>';
      $output .= '</ul>';
    }
  }
  return $output;
}

/**
 * Menu callback for `admin/users-list` path.
 *
 * We are printing users with group assigned to users.
 *
 * @return string
 *   HTML output of all users with their groups.
 */
function beliana_users_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($users as $user) {
    $output .= '<div>';
    $output .= '<h3> Lexikálne skupiny používateľa <em>' . $user->name . '</em></h3>';
    $output .= '<ul>';
    foreach ($terms as $t) {
      if (isset($user->workbench_access[$t->tid])) {
        $output .= '<li>' . $t->name . '</li>';
      }
    }
    $output .= '</ul><br><br></div>';
  }
  return $output;
}

/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_action_info() {
  return array(
    'beliana_merge' => array(
      'type' => 'entity',
      'label' => t('Merge'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'beliana_assign_author' => array(
      'type' => 'entity',
      //'label' => t('Určiť autora a priradiť autorovi'),
      'label' => t('Specify author and assign to author'),
      'configurable' => TRUE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'beliana_assign_corrector' => array(
      'type' => 'entity',
      //'label' => t('Určiť autora a priradiť redaktorovi'),
      'label' => t('Specify author and assign to editor'),
      'configurable' => TRUE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie'),
      'label' => t('Mark for publishing (editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_senior_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (VR)'),
      'label' => t('Mark for publishing (senior editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_proofreader' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (JR)'),
      'label' => t('Mark for publishing (proofreader)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'update_dates' => array(
      'type' => 'entity',
      //'label' => t('Aktualizovať dátumy'),
      'label' => t('Update dates'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'check_path_attributes' => array(
      'type' => 'entity',
      'label' => t('Check link'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'update_author_payment_data' => array(
      'type' => 'entity',
      'label' => t('Update author payment data'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Callback for 'importovane_publish_editor' action.
 *
 * changes workflow status to 'importovane_u_jr2'
 *
 * @inheritdoc
 */
function importovane_publish_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane') {
    $skip = false;
    if (!_check_links($node)) {
      $skip = true;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = true;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "importovane_u_jr2");
    }
  }
}

/**
 * Callback for 'importovane_publish_proofreader' action.
 *
 * changes workflow status to 'importovane_u_vr'
 *
 * @inheritdoc
 */
function importovane_publish_proofreader(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_jr2') {
    if (_check_links($node)) {
      workbench_moderation_moderate($node, "importovane_u_vr");
    }
  }
}

/**
 * Callback for 'importovane_publish_senior_editor' action.
 *
 * changes workflow status to 'na_zalomenie'
 *
 * @inheritdoc
 */
function importovane_publish_senior_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_vr') {
    $skip = false;
    if (!_check_links($node)) {
      $skip = true;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = true;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "na_zalomenie");
    }
  }
}

/**
 * Configuration form for `beliana_assign_author` action.
 *
 * @inheritdoc
 */
function beliana_assign_author_form($form, &$form_state) {
  return _beliana_assign_user_form();
}

/**
 * Validation for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state);
}

/**
 * Submit function for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'u_autora');
}

/**
 * Callback for `beliana_assign_author` action.
 *
 * Assigns selected user as node author and
 * changes workflow status to `u_autora`.
 *
 * @inheritdoc
 */
function beliana_assign_author(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Configuration form for `beliana_assign_corrector` action.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_form($form, &$form_state) {
  return _beliana_assign_user_form();
}

/**
 * Validation for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state);
}

/**
 * Submit function for for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'needs_review');
}

/**
 * Callback function for `beliana_assign_corrector` action.
 *
 * Assigns selected user as node author and
 * change workflow status to `needs_review`.
 *
 * @inheritdoc
 */
function beliana_assign_corrector(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Callback function for `update_dates` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function update_dates(&$entity, $context = array()) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    // get dates from article text
    $dates = get_header_dates($entity->field_text_hesla[LANGUAGE_NONE][0]['value']);
    if (count($dates) > 0) {
      // unset date fields first
      for ($i = 2; $i >= 0; $i--) {
        if (isset($entity->field_datum[LANGUAGE_NONE][$i]['value']))
          unset($entity->field_datum[LANGUAGE_NONE][$i]['value']);
      }
      for ($i = 0; $i < count($dates); $i++) {
        // set the field
        $entity->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
      }
      node_save($entity);
    }
  }
}

/*
  Check, if the node was sent to the needs_review state after 11.11.2018
  the node IS in the state needs_review (U redaktora) since only role Redaktor can edit the payment information
  find date (tstamp) of the latest of transitions na_zalomenie >> needs_review
  compare tstamp with the date 11.11.2018 (reftime) (on that day payment data was manuall exported)
  if tstamp > refdate return True (do not display payment fields). We have manually exported payment data
  if tstamp < refdate return False (edit payment fields). We do not have payment data
 */

function has_vr_to_r_transition(&$node) {

  // find transitions na_zverejnenie >> needs_review
  $reftime = strtotime("11-11-2018"); // date of manual accounting data export
  $transitions = db_select('workbench_moderation_node_history', 'w')
      ->fields('w') // all fields
      ->condition('from_state', 'na_zverejnenie') // u vyst. redaktor 1 state
      ->condition('state', 'needs_review')  // u redaktora state
      ->condition('nid', $node->nid)
      ->execute()
      ->fetchAll();
  // find the most recent transition
  $tstamp1 = 0;
  foreach ($transitions as $tr) {
    if ($tr->stamp > $tstamp1) { // find the most recent transition
      $tstamp1 = $tr->stamp;
    }
  }

  // find transitions u_vyst_redaktora_2 >> needs_review
  $transitions = db_select('workbench_moderation_node_history', 'w')
      ->fields('w') // all fields
      ->condition('from_state', 'u_vyst_redaktora_2')  // u redaktora state
      ->condition('state', 'needs_review')  // u vr1 state
      ->condition('nid', $node->nid)  // u vr1 state
      ->execute()
      ->fetchAll();
  // find the most recent transition
  $tstamp2 = 0;
  if (!empty($transitions)) {
    foreach ($transitions as $tr) {
      if ($tr->stamp > $tstamp2) { // find the most recent transition
        $tstamp2 = $tr->stamp;
      }
    }
  }
  $tstamp = max($tstamp1, $tstamp2);
#dpm(date("m.d.Y",$tstamp), date("m.d.Y",$reftime));
  return $tstamp > $reftime;
}

// check if field related to payment should be displayed, and if, then how (editable, noneditable)
// return strings hideall enableall or showeditable
function _display_payment_fields_form(&$form) {
  return _display_payment_fields($form['#node']);
}

function _display_payment_fields(&$node) {
  #do not show the fields for new items
  if (!isset($node->nid)) {
#dpm("hideall (nove heslo)", "display_payment_fields");
    return "hideall";
  }

  #do not show the fields for merged (zlucene) articles (i. e. field_zlucene_z is nonempty)
  if (isset($node->field_zlucene_z[LANGUAGE_NONE][0])) {
#dpm("hideall (merged)", "display_payment_fields");
    return "hideall";
  }

  global $user;
  $curstate = $node->workbench_moderation['current']->state;
//dpm($user);
  // administrator has access to everything
  //if (0 and !in_array("administrátor", $user->roles)) { // comment out in testing 
  if (in_array("administrátor", $user->roles)) { // $form: node 
#dpm("enableall", "display_payment_fields");
    return "enableall";
  }

  // do not show in the case of nodes imported from files Kolembus-00* and Komunikator-00*
  if (
      (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Kolembus-00') !== False)
      or ( isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Komunikator-00') !== False)
  ) {
#dpm("hideall (import)", "display_payment_fields");
    return "hideall";
  }

  // if filled out, field_datum_autorovho_textu is set.  Just show, do not edit
  if (isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'])) {
#dpm("showdisabled (filled out)", "display_payment_fields, field_datum_autorovho_textu is set");
    return("showdisabled");
  }
  //state of the node changed from vr1 or vr2 state to needs_review after 11.11.2018 
  if (has_vr_to_r_transition($node)) {
#dpm("hideall (has transition)", "display_payment_fields");
    return("hideall");
  }
  if ($curstate === 'needs_review') {
#dpm("showeditable (no transition, needs_review)", "display_payment_fields");
    return("showeditable");
  }
  else {
#dpm("hideall (no transition, no needs_review)", "display_payment_fields");
    return("hideall");
  }
}

/**
 * Find the first transition needs_review -> na_zalomenie and return text length
 *
 */
function _get_authors_text_length(&$node) {
  if ($node->type != 'heslo')
    return null;

  // get the array of transitions needs_review -> na_zalomenie (U redaktora -> U VR1)
  $transitions = db_select('workbench_moderation_node_history', 'w')
      ->fields('w') // all fields
      ->condition('from_state', 'needs_review')  // u redaktora state
      ->condition('state', 'na_zverejnenie')  // u vr1 state
      ->condition('nid', $node->nid)  // u vr1 state
      ->execute()
      ->fetchAll();
  if (empty($transitions))
    return null;
  // get vid of the oldest transition
  $tstamp = $transitions[0]->stamp;
  $vid = $transitions[0]->vid;
  foreach ($transitions as $tr) {
    if ($tr->stamp < $tstamp) {
      $tstamp = $tr->stamp;
      $vid = $tr->vid;
    }
  }

  // load the $vid revision
  $revision = entity_revision_load('node', $vid);
  // remove tags and clean the text
  $text = strip_tags(str_replace('<', ' <', $revision->field_text_hesla[LANGUAGE_NONE][0]['value']));
  $text = preg_replace('/\n|\r|\t/m', ' ', $text);
  $text = str_replace('&nbsp;', ' ', $text);
  $text = str_replace("\xc2\xa0", ' ', $text);
  $text = trim(preg_replace('/\s\s+/', ' ', $text));
  $tlen = drupal_strlen($text);

  return $tlen;
}

/**
 * Callback function for `check_path_attributes` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function check_path_attributes(&$entity, $context = array()) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    $alias = drupal_get_path_alias('node/' . $entity->nid);

    if (strpos($alias, '_') === false) {
      $entity->field_atributy = array(LANGUAGE_NONE => array(array('value' => 'odkazOK')));
      node_save($entity);
    }
  }
}

/**
 * Callback function for `beliana_merge` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function beliana_merge(&$entity, $context = array()) {
  // If current entity is the first one,
  // create new entity `Heslo` and store its nid into session.
  if ($context['progress']['current'] === 1) {
    $master = new stdClass();
    $master->type = 'heslo';
    node_object_prepare($master);
    $master->title = $entity->title;
    $master->field_text_hesla = array(
      LANGUAGE_NONE => array(
        array(
          'value' => '',
          'format' => 'filtered_html',
        ),
      ),
    );
    $master->field_taxsubor = $entity->field_taxsubor;
    $master->language = 'sk';
    node_save($master);
    $_SESSION['master'] = $master->nid;
  }

  // Load master entity from session.
  $master = node_load($_SESSION['master']);

  // If master entity found, copy fields from current entity into it.
  if ($master != FALSE) {
    // Merge field_lexikalna_skupina.
    foreach ($entity->field_lexikalna_skupina[LANGUAGE_NONE] as $ls) {
      // find the top most parent (set to editor name) 
      $parents = taxonomy_get_parents_all($ls['tid']);
      foreach ($parents as $parent) {
        if (count(taxonomy_get_parents_all($parent->tid)) == 1) {
          $top_parent = $parent;
        }
      }

      // store the top most parent (editor name) to field_redaktori_zluceneho
      $found = FALSE;
      if (isset($master->field_redaktori_zluceneho[LANGUAGE_NONE])) {
        foreach ($master->field_redaktori_zluceneho[LANGUAGE_NONE] as $tid) {
          if ($tid['tid'] === $top_parent->tid) {
            $found = TRUE;
          }
        }
      }
      if (!$found) {
        $master->field_redaktori_zluceneho[LANGUAGE_NONE][]['tid'] = $top_parent->tid;
      }
      // We want to preserve the original taxonomy values in further processing.
      $master->field_povodne_lexikalne_skupiny[LANGUAGE_NONE][]['tid'] = $ls;
    }

    // Merge field_komentar_instrukcie, use "\n" as separator.
    if (isset($entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) || empty($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_hesla, use "</p>\n<p>" as separator.
    if (!isset($master->field_text_hesla[LANGUAGE_NONE][0]['value']) || empty($master->field_text_hesla[LANGUAGE_NONE][0]['value'])) {
      $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
    }
    else {
      // special requirement: in merging put GEO articles in front of others
      if ($top_parent->tid === "390") {  // "390" is Lubica Krajcovicova, editor of GEO articles. 
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'] . "<p>&nbsp;/p>" . $master->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] .= "<p>&nbsp;</p>" . $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_z_gh, use "\n" as separator.
    if (isset($entity->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_text_z_gh[LANGUAGE_NONE][0]['value']) || empty($master->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] = $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_ilustracia.
    if (!empty($entity->field_ilustracia)) {
      foreach ($entity->field_ilustracia[LANGUAGE_NONE] as $img) {
        $master->field_ilustracia[LANGUAGE_NONE][] = $img;
      }
    }

    // Merge field_atributy, use "\n" as separator.
    if (isset($entity->field_atributy[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_atributy[LANGUAGE_NONE][0]['value']) || empty($master->field_atributy[LANGUAGE_NONE][0]['value'])) {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] = $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] .= "," . $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
    }

    // Check if entity has moderation state history: u_vyst_redaktora_2x >> u_vyst_redaktora_2
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $entity->nid)
        ->execute()
        ->fetchAll();

    // If master has state u_vyst_redaktora_2x, write to merged entity as attribute
    if (!empty($transitions)) {
      $master->field_atributy[LANGUAGE_NONE][0]['value'] = 'VR2X';
    }

    $master->field_zlucene_z[LANGUAGE_NONE][]['target_id'] = $entity->nid;
    node_save($master);

    $entity->field_zlucene_do[LANGUAGE_NONE][0]['target_id'] = $_SESSION['master'];
    // Empty alias for original entity.
    //$entity->path['alias'] = '';
    // Set automatic alias creation to FALSE.
    //$entity->path['pathauto'] = FALSE;
    node_save($entity);
    workbench_moderation_moderate($entity, 'ukoncenezluene');
  }

  // If current entity is the last, make workflow transition.
  if ($context['progress']['current'] === $context['progress']['total']) {
    $master = node_load($_SESSION['master']);
    // Reset fields.
    $master->field_vyplatit = NULL;
    $master->field_errta = NULL;
    $master->field_datum = NULL;
    // Set automatic alias creation to FALSE.
    $master->path['pathauto'] = FALSE;
    // Set field_lexikalna_skupina to `Zlúčené heslo`.
    $term = array_shift(taxonomy_get_term_by_name('Zlúčené heslo', 'lexikalne_skupiny'));
    $master->field_lexikalna_skupina[LANGUAGE_NONE][]['tid'] = $term->tid;
    node_save($master);
    workbench_moderation_moderate($master, 'zlucene');
    $_SESSION['master'] = NULL;
  }
}

/**
 * Implements hook_node_presave().
 *
 * @inheritdoc
 */
function beliana_node_presave($node) {
  # do not execute in the case of workbench moderation state transitions
  # execute only on node saving
  # on node creation $node->workbench_moderation does not exist
  if (isset($node->workbench_moderation_state_new) and
      isset($node->workbench_moderation) and
      $node->workbench_moderation['current']->state != $node->workbench_moderation_state_new) {
    return;
  }

  // set field_na_zoradenie if empty or fix it if necessary
  setlocale(LC_COLLATE, 'sk_SK.utf8');
  $rebuild_sort = !isset($node->field_na_zoradenie['und'][0]['value']);
  if (!$rebuild_sort) {
    // are there funny characters in sort string (field_na_zoradenie)?
    $rebuild_sort = preg_match('/[^a-zA-ZŠšČčŽž_0-9]/', $node->field_na_zoradenie['und'][0]['value']);
    //is there comma in title by not '_' in sort string (field_na_zoradenie)? - fixes missing '_' between surname and name
    $rebuild_sort = $rebuild_sort ||
        (strpos($node->title, ",") and // comma in title
        ! strpos($node->field_na_zoradenie['und'][0]['value'], "_") and // no "_" in sort string
        ! preg_match("/^[0-9]/", $node->title) and // not starting with number (in chemistry, like 1,3-butadien)
        $node->type == 'importovane_heslo' // only 'importovane_heslo' 'heslo' is sorted in a different way
        );
  }
  if ($rebuild_sort) {
    $transliterated = preg_replace("/\(^ad-|al-|af |d’ |d’|de |da |z |ze |del |\)./", '', $node->title);
    $transliterated = _beliana_remove_accents($transliterated);
    $transliterated = str_replace(",", "_", $transliterated);
    $transliterated = preg_replace('/[^a-zA-ZŠšČčŽž_0-9]/', '', $transliterated);
    $transliterated = strtolower($transliterated);
    $transliterated = str_replace("Š", "š", $transliterated); // not changed by strtolower
    $transliterated = str_replace("Č", "č", $transliterated);
    $transliterated = str_replace("Ž", "ž", $transliterated);
    $node->field_na_zoradenie['und'][0]['value'] = substr($transliterated, 0, 50);
  }

  // set field_taxsubor using the value of field_na_zoradenie 
  $vocabulary = taxonomy_vocabulary_machine_name_load('subory');
  //$subory = taxonomy_term_load_multiple(array(), array('vid' => $vocabulary->vid)); //default sort instead of Slovak
  $subory = taxonomy_get_tree($vocabulary->vid);
  foreach ($subory as $term) {
    // ignore items starting with digit, such as '1. subor'
    if (!ctype_digit(substr($term->name, 0, 1)) && strcoll($term->name, $node->field_na_zoradenie['und'][0]['value']) >= 0) {
      $node->field_taxsubor['und'][0]['tid'] = $term->tid;
      break;
    }
  }

  # do not continue if node has just been created
  if (isset($node->is_new) and $node->is_new === True)
    return;

  // clean tags and remove unnecessary field values in type 'ilustracie'
  if ($node->type != "heslo" && $node->type != 'importovane_heslo') {
    if ($node->type == "ilustracia") {
      $html = beliana_clean_tags($node, $node->field_popis[LANGUAGE_NONE][0]['value'], "Popis ilustracie (beliana_node_presave)");
      $node->field_popis[LANGUAGE_NONE][0]['value'] = $html;
      // remove inappropriate setting of field_licencia1 if licence type is not 'CC licencia' (possible in the form)
      if (isset($node->field_zdroj_ilustracie[LANGUAGE_NONE][0]) and $node->field_zdroj_ilustracie[LANGUAGE_NONE][0]['value'] !== 'CC licencia') {
        if (isset($node->field_licencia1[LANGUAGE_NONE][0])) {
          #dpm("Odstránená nepotrebná hodnota v field_licencia1 (typ CC licencie)");
          unset($node->field_licencia1[LANGUAGE_NONE][0]);
        }
        if (isset($node->field_modifikovane[LANGUAGE_NONE][0])) {
          #dpm("Odstránená nepotrebná hodnota v field_modifikovane");
          unset($node->field_modifikovane[LANGUAGE_NONE][0]);
        }
      }
      if (isset($node->field_modifikovane[LANGUAGE_NONE][0]) and $node->field_modifikovane[LANGUAGE_NONE][0]['value'] !== '1') {
        if (isset($node->field_popis_modifikacie[LANGUAGE_NONE][0])) {
          #dpm("Odstránený nepotrebný text v field_popis_modifikacie (1)");
          unset($node->field_popis_modifikacie[LANGUAGE_NONE][0]);
        }
      }
      if (!isset($node->field_modifikovane[LANGUAGE_NONE][0]) and isset($node->field_popis_modifikacie[LANGUAGE_NONE][0])) {
        #dpm("Odstránený nepotrebný text v field_popis_modifikacie (2)");
        unset($node->field_popis_modifikacie[LANGUAGE_NONE][0]);
      }
    }
    return;
  }

  // update field_datum according to the text
  $dates = get_header_dates($node->field_text_hesla[LANGUAGE_NONE][0]['value']);
  if (count($dates) > 0) {
    // unset date fields first
    for ($i = 2; $i >= 0; $i--) {
      if (isset($node->field_datum[LANGUAGE_NONE][$i]['value']))
        unset($node->field_datum[LANGUAGE_NONE][$i]['value']);
    }
    for ($i = 0; $i < count($dates); $i++) {
      $node->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
    }
  }

  // to be used in logs for node save debugging
  watchdog('content', '@type: updated (1) @title. (' . (time() - $node->changed) . ' s) ' . date("Y/m/d H:i:s", $node->changed), [
    '@type' => $node->type,
    '@title' => $node->title
      ], WATCHDOG_NOTICE);

  // find links pointing to articles in Ukončené/Zlúčené (ukoncenezluene) state and replace them
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($node->field_text_hesla[LANGUAGE_NONE][0]['value'], 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  foreach ($links as $item) {
    $target = substr($item->getAttribute('href'), 1); // we do not need the leading slash /
    $path = drupal_get_normal_path($target);
    $parts = explode("/", $path);
    if ($parts[0] === 'node') {
      $lnode = node_load($parts[1]); // the linked node
      if ($lnode->workbench_moderation['current']->state == 'ukoncenezluene') {
        // $znode: the node $lnode is merged to
        $znode = node_load($lnode->field_zlucene_do[LANGUAGE_NONE][0]['target_id']);
        $newpath = $znode->path['alias'];
        // replace including the closing '"' to make the replacement string unique
        $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = str_replace($target . '"', $newpath . '"', $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
        watchdog('aktualizovany odkaz', 'Heslo "' . $node->title . '": aktualizovaný odkaz na zlúčené heslo (z <a href="/' . $target . '">' . $target . '</a> na <a href="/' . $newpath . '">' . $newpath . '</a>)');
      }
    }
  }

  // to be used in logs for node save debugging
  watchdog('content', '@type: updated (2) @title. (' . (time() - $node->changed) . ' s) ' . date("Y/m/d H:i:s", $node->changed), [
    '@type' => $node->type,
    '@title' => $node->title
      ], WATCHDOG_NOTICE);

  // remove unnecessary tags
  $html = beliana_clean_tags($node, $node->field_text_hesla[LANGUAGE_NONE][0]['value'], "Text hesla (beliana_node_presave)");
  $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = $html;
  if (isset($node->field_table[LANGUAGE_NONE][0])) {
    $html = beliana_clean_tags($node, $node->field_table[LANGUAGE_NONE][0]['value'], "Tabuľka pre geografické heslá");
    $node->field_table[LANGUAGE_NONE][0]['value'] = $html;
  }

  // store information about the author's text length (used for payments)
  // first, unset field_dlzka_autorovho_textu_zad if field_vyplatit is not Vyplatiť 
  // (setting it makes no sense, but is possible in the form)
  if (isset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]) and
      $node->field_vyplatit[LANGUAGE_NONE][0]['value'] !== "Vyplatiť") {
    #dpm("Odstránená nepotrebná hodnota v field_dlzka_autorovho_textu_zad");
    unset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]);
  }
  // Compute the lenght if value 0 was entered in field field_dlzka_autorovho_textu_zad.
  if (isset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]) and ( !isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value']) or
      $node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] == 0)) {
    // set the date (if set,  field field_dlzka_autorovho_textu_zad will never be changed again)
    $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = date("Y/m/d");
    // if  field_dlzka_autorovho_textu_zad is set to 0, fill the value automatically
    if ($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] == 0) {
      $text = strip_tags(str_replace('<', ' <', $node->field_text_hesla[LANGUAGE_NONE][0]['value']));
      $text = preg_replace('/\n|\r|\t/m', ' ', $text);
      $text = str_replace('&nbsp;', ' ', $text);
      $text = str_replace("\xc2\xa0", ' ', $text);
      $text = trim(preg_replace('/\s\s+/', ' ', $text));
      $tlen = drupal_strlen($text);
      $node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] = $tlen;
      #log this event
      $node->log = $node->log . ", automaticky určená dĺžka autorovho textu";
    }
    else { # log if a value was entered manually
      $node->log = $node->log . ", ručne vložená dĺžka autorovho textu";
    }
  }
  // save date when the author's text information was saved. Used for monthly records
  if (isset($node->field_vyplatit[LANGUAGE_NONE][0]) and ! isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'])) {
    $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = date("Y/m/d");
    $node->log = $node->log . ", vyplnené pole Vyplatiť";
  }

  #update the link table
  _beliana_process_links($node);
  // to be used in logs for node save debugging
  watchdog('content', '@type: updated (3) @title. (' . (time() - $node->changed) . ' s) ' . date("Y/m/d H:i:s", $node->changed), [
    '@type' => $node->type,
    '@title' => $node->title
      ], WATCHDOG_NOTICE);
}

/**
 * Implements hook_views_post_execute().
 */
function beliana_views_post_execute(&$view) {
  $affected_views = array(
    'sync_to_web' => 'node_workbench_moderation_node_history_nid',
    'vsetky_hesla_detaily' => 'nid',
    'export_na_import' => 'nid',
  );

  if (in_array($view->name, array_keys($affected_views))) {
    $old_count = count($view->result);
    $unique_nids = array();
    $new_results = array();

    // Loop through results and filter out duplicate results.
    foreach ($view->result as $index => $result) {
      $nid = $result->{$affected_views[$view->name]};

      if (!in_array($nid, $unique_nids)) {
        $unique_nids[] = $nid;
        $new_results[] = $result;
      }
    }

    $view->result = $new_results;
    $new_count = count($new_results);

    if ($old_count > $new_count && $view->query->pager->total_items < 50) {
      $view->total_rows = $new_count;
      $view->query->pager->total_items = $new_count;
      $view->query->pager->update_page_info();
    }
  }
}

/**
 * Implements hook_form_alter().
 * If user has role 'redaktor' and state is `zaradene`,
 * we remove option 'u_autora' and 'u redaktora' (needs_review) from possible next states.
 * This forces editor to use the view "Priradit autora" to assign article to and author
  watchdog('content', '@type: updated @title. (' . (time() - $node->changed) . ' s) ' . date("Y/m/d H:i:s",$node->changed), [
 *
 * @inheritdoc
 */
function beliana_form_alter(&$form, &$form_state, $form_id) {
  // log information about opening nodes for editing
  // if $form['title']['#default_value'] is empty (node just ceated), do not log anything
  $nf_pos = strpos($form_id, "_node_form");
  if (!($nf_pos === false) && isset($form['title']['#default_value'])) {
    watchdog('content', '@type: otvorené na úpravu @title. (open, ' . date("Y/m/d H:i:s") . ')', [
      '@type' => substr($form_id, 0, $nf_pos),
      '@title' => $form['title']['#default_value'],
        ], WATCHDOG_NOTICE);
  }

  global $user;
  // disable but show fields related to author's text, if already set
  if ($form_id == "heslo_node_form") {
    $display_payment = _display_payment_fields_form($form);
    //hideall, enableall, showdisabled, showeditable
    if ($display_payment == "enableall") {
      // no action necessary
    }
    elseif ($display_payment == "hideall") {
      if (isset($form['field_vyplatit'])) {
        $form['field_vyplatit']['#access'] = FALSE;
      }
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
      if (isset($form['field_dlzka_autorovho_textu_zad'])) {
        $form['field_dlzka_autorovho_textu_zad']['#access'] = FALSE;
      }
    }
    elseif ($display_payment == "showdisabled") {
      if (isset($form['field_vyplatit'])) {
        $form['field_vyplatit']['#disabled'] = TRUE;
      }
      if (isset($form['field_dlzka_autorovho_textu_zad'])) {
        $form['field_dlzka_autorovho_textu_zad']['#disabled'] = TRUE;
      }
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
    }
    elseif ($display_payment == "showeditable") {
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
    }
  }

  //'workbench_moderation_moderate_form': the form displaying a node 'view' or similar
  //$form['node']['#value'] is not set if user cannot modify a node
  if (isset($form['node']['#value']) && $form_id === 'workbench_moderation_moderate_form') {
    if ($form['node']['#value']->workbench_moderation['current']->state === 'zaradene' && in_array("Redaktor", $user->roles)) {
      foreach ($form['state']['#options'] as $k => $v) {
        if (in_array($k, array('needs_review', 'u_autora'))) {
          unset($form['state']['#options'][$k]);
        }
      }
    }

    // Add custom submit handler.
    $form['#submit'][] = 'beliana_workflow_reaction';
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 * @inheritdoc
 */
function beliana_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  $form['#attached']['js'][] = drupal_get_path('module', 'beliana') . '/js/editor.js';
  drupal_add_js(array('beliana' => array('current_user' => array('id' => $user->uid, 'name' => $user->name))), array('type' => 'setting'));
}

/**
 * Callback function for `workbench_moderation_moderate_form` submit.
 *
 * @inheritdoc
 */
function beliana_workflow_reaction(&$form, &$form_state) {
  $values = $form_state['values'];
  if (!isset($values['node']->workbench_moderation['current']->state))
    return;

  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;

  // ensure corect state transitions if article is merged from other articles
  if (isset($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    // starting '1_korektura:' copy editor names to field_spravit_1_korekturu
    if (($cur_state === 'na_jazykovu_korekturu' && $new_state === '1_korektura'))
      _start_korektura($values);

    // transition 1_korektura >> u_vyst_redaktora_3 
    if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
      _transition_korektura($values, "1_korektura");
    }

    // merge links in zlucene >> u_jaz_redaktora_1
    if ($cur_state === 'zlucene' && $new_state === 'na_jazykovu_korekturu') {
      foreach ($values['node']->field_zlucene_z[LANGUAGE_NONE] as $item) {
        $query = db_query('SELECT node.nid AS nid FROM {node} node INNER JOIN {search_node_links} links ON node.nid = links.sid WHERE links.nid = :nid', array(':nid' => $item['target_id']));
        $result = $query->fetchAll();

        if (!empty($result)) {
          foreach ($result as $backlink) {
            if ($source = node_load($backlink->nid)) {
              node_save($source);
            }
          }
        }
      }
    }

    $run_as_1_korektura = true;  // choose between two ways how to run 2_korekt_ra - FIXME needs workflow change 
    if ($run_as_1_korektura) { // 2_korekt_ra: the same procedure as 1_korektura
      // starting 'korektura': copy editor names to field_spravit_1_korekturu
      if (($cur_state === 'u_vyst_redaktora_3' && $new_state === '2_korekt_ra'))
        _start_korektura($values);

      // transition 2_korekt_ra >> u_vyst_redaktora_4 
      if ($cur_state === '2_korekt_ra' && $new_state === 'u_vyst_redaktora_4')
        _transition_korektura($values, "2_korekt_ra");
    }
    else // korekt_ra: version with only one editor selected
      _run_2_korektura_single($values);
    node_save($values['node']);
    return;
  }

  // transition 1_korektura >> u_vyst_redaktora_3 
  if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
    _transition_vr2x($values);
    node_save($values['node']);
  }

  // check type heslo
  if ($values['node']->type === 'heslo') {
    $fail = False;
    // do not change state to na_opakovane_zverejnenie or na_zalomenie if LITE changes exist
    if ($new_state === "na_opakovane_zverejnenie" or $new_state === "na_zalomenie") {
      $text = $values['node']->field_text_hesla['und'][0]['value'];
      if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
        $fail = True;
        drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . '</a> nebol zmenený, lebo v jeho texte sú uložené LITE zmeny', 'error');
      }
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $texttab = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (strpos($texttab, "ice-ins") or strpos($texttab, "ice-del")) {
          $fail = True;
          drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo v poli 'Tabuľka pre geografické heslá' sú uložené LITE zmeny", 'error');
        }
      }
    }
    // check if payment information is stored
    if (($cur_state === "needs_review" and $new_state === "na_zverejnenie") and  // u redaktora state u vr1 state transition
        _display_payment_fields($values['node']) == "showeditable") {
      $fail = True;
      drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo nie je vyplnené pole 'Vyplatenie odmeny'", 'error');
    }
    if ($fail) {
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // check types heslo and importovane_heslo, ignore for authors
  if (!($cur_state === "u_autora" and $new_state === "needs_review")) {
    if ($values['node']->type === 'importovane_heslo' or $values['node']->type === 'heslo') {
      // Check link correctness
      $skip = false;
      if (!_check_links($values['node'])) {
        $skip = True;
      }
      // Check alternative text marker correctness in article body
      if (!_check_alternative_text_markers($values['node'], $values['node']->field_text_hesla['und'][0]['value'], "v hesle")) {
        $skip = True;
      }
      // Check alternative text marker correctness in article table
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $text_table = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (!_check_alternative_text_markers($values['node'], $text_table, "v tabuľke pre geografické údaje hesla")) {
          $skip = TRUE;
        }
      }
      if ($skip) {
        drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
        $values['node']->workbench_moderation_state_new = $cur_state;
        node_save($values['node']);
        return;
      }
    }
  }

  // check illustration state on transition of 'importovane_heslo' to state 'importovane_u_jr2'
  if ($values['node']->type === 'importovane_heslo' and $new_state == 'importovane_u_jr2') {
    $skip = false;
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    $skip = !check_ill_at_node_transition($values['node'], $ok_states, 'state change');
    if ($skip) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // check illustrations
  if ($values['node']->type === 'ilustracia') {
    $skip = FALSE;
    if ($cur_state == 'ilustracia_u_redaktora' and $new_state == 'ilustracia_u_vyst_redaktora_5') {
      $ilu_node = $values['node'];

      if (!_check_ilu_attached($ilu_node, 'state change')) {
        $skip = TRUE;
      }

      //if (!_check_field_pouzit($ilu_node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // ignore illustrations, which are not intended for web
      if (il_display_on_web($ilu_node)) {
        if (is_null(_check_illustration_web($ilu_node, $ilu_node, 'state change'))) {
          $skip = TRUE;
        }
      }
    }

    // a problem with illustration, keep the current state
    if ($skip) {
      drupal_set_message('<strong>Stav ilustrácie nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    else {
      $values['node']->field_datum_zverejnenia[LANGUAGE_NONE][0]['value'] = date('Y-m-d H:i:s');
      node_save($values['node']);
    }
  }
}

function _check_ilu_attached(&$ilu_node, $category) {
  $query = new EntityFieldQuery();
  $query
      ->entityCondition('entity_type', "node")
      ->fieldCondition('field_ilustracia', 'target_id', $ilu_node->nid, "=");
  $result = $query->execute();
  if (isset($result['node'])) {
    return true;
  }
  else {
    il_error($ilu_node, $ilu_node, 'nie je priradená k žiadnemu heslu', $category);
    return false;
  }
}

/*
 * $ok_states: list of required illustration states 
 * return true if OK
 */

function check_ill_at_node_transition(&$node, $ok_states, $category) {
  $skip = false;
  if (isset($node->field_ilustracia[LANGUAGE_NONE])) {
    foreach ($node->field_ilustracia[LANGUAGE_NONE] as $illustration) {
      $ilu_generic_node = node_load($illustration['target_id']);
      $ilu_node = workbench_moderation_node_current_load($ilu_generic_node);

      //if (!_check_field_pouzit($node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // check illustrations, which are intended for web
      if (il_display_on_web($ilu_node)) {
        $illustration_data = _check_illustration_web($node, $ilu_node, 'state change');
        if (is_null($illustration_data)) {
          $skip = TRUE;
        }

        // Check if illustration is in correct WB status.
        if (!in_array($ilu_node->workbench_moderation['current']->state, $ok_states)) {
          il_error($node, $ilu_node, 'má byť zverejnená na webe, ale nie je v žiadnom z požadovaných stavov: [' . implode(", ", $ok_states) . ']', 'state change');
          $skip = TRUE;
        }
      }
    }
  }
  return !$skip;
}

/**
 * check validity of used alternative text markers
 * correct marked text:  ▶[KkWw][^▶]*◀
 *
 * @param $nid
 */
function _check_alternative_text_markers(&$node, $text, $where) {
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  // do not check validity if LITE changes are stored
  if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
    return true;
  }
  $retvalue = true;
  $hlink = 'Chybný alternatívny text ' . $where . ' <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: ';
  $pattern = "/(*UTF8)(▶[^◀]*▶)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'opakovaný začiatok (... ▶ ... ▶ ...)', 'error');
    $retvalue = false;
  }
  $pattern = "/(*UTF8)(◀[^▶]*◀)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'opakované ukončenie (... ◀ ... ◀ ...)', 'error');
    $retvalue = false;
  }
  $pattern = "/(*UTF8)(▶[^kKwW])/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'použité "' . $matches[0][0] . '" namiesto "▶K" alebo "▶W"', 'error');
    $retvalue = false;
  }
  $pattern = "/(*UTF8)(▶[^◀]*$)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'chýba ukončenie ◀', 'error');
    $retvalue = false;
  }
  $pattern = "/(*UTF8)^[^▶]*◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'chýba začiatok "▶K" alebo "▶W"', 'error');
    $retvalue = false;
  }
  $pattern = "/(*UTF8) ◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'pred znakom ◀ nesmie byť medzera', 'error');
    $retvalue = false;
  }
  // check correctness of tags inside the alternatives
  // catches only closing tags 
  $pattern = "/(*UTF8)▶[^◀▶]*◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    foreach ($matches[0] as $match) {
      $dom = beliana_get_dom($node, $match);
      preg_match_all("/(*UTF8)(<[^\/])/", $match, $matchesopen);
      preg_match_all("/(*UTF8)(<\/)/", $match, $matchesclose);
      if (!$dom or count($matchesopen[0]) != count($matchesclose[0])) {
        $match = str_replace("<", "&lt;", $match);
        $match = str_replace(">", "&gt;", $match);
        drupal_set_message($hlink . 'formátovanie presahuje hranice alternatívneho textu: "' . $match . '"', 'error');
        $retvalue = false;
      }
    }
  }
  return $retvalue;
}

/**
 * Extract links from node and check their validity
 *
 * @param $nid
 */
function _check_links(&$node) {
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  $text = $node->field_text_hesla['und'][0]['value'];
  $retvalue = true;
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = 0; $i < $links->length; $i++) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      // no external lins allowed
      if (url_is_external($target)) {
        drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
        $retvalue = false;
      }
      else {
        if (preg_match('?^/heslo/[^/]*?', $target)) {
          // form OK, check if it exists
          // Get non-alias path, so we can get nid from it.
          $path = drupal_get_normal_path(substr($target, 1));
          $parts = explode("/", $path);
          if ($parts[0] !== 'node') {
            drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkazované heslo neexistuje)', 'error');
            $retvalue = false;
          }
          else {
            $generic_node = node_load($parts[1]);
            $auxnode = workbench_moderation_node_current_load($generic_node);
            // linked article must be a normal one, not a pure reference article (i.e. must contain the "—" character)
            if (strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "—") === false and
                strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "➔") !== false) {
              drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkaz na odkazové alebo nesprávne formátované heslo (chýba "—" )', 'error');
              $retvalue = false;
            // linked article must not be in 'vyradene' state
            } elseif ($auxnode->workbench_moderation['current']->state === 'vyradene') {
              drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkaz na vyradené heslo)', 'error');
              $retvalue = false;
            }
          }
        }
        else {
          // not in the form '/heslo/alias'
          drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
          $retvalue = false;
        }
      }
    }
  }
  return $retvalue;
}

/**
 * Helper function: start 'korektura'
 */
function _start_korektura(&$values) {
  // copy editor names to field_spravit_1_korekturu
  foreach ($values['node']->field_redaktori_zluceneho['und'] as $redaktor)
    $values['node']->field_spravit_1_korekturu['und'][]['tid'] = $redaktor['tid'];
  // take the next editor
  $values['node']->field_lexikalna_skupina['und'] = array();
  $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_korektura(&$values, $korektura) {
  if (!empty($values['node']->field_spravit_1_korekturu['und'])) {
    // return back to '$korektura'
    $values['node']->workbench_moderation_state_new = $korektura;
    // take the next editor
    $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
  }
  else {
    _transition_vr2x($values);
    // we are done, restore the initial status
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_vr2x(&$values) {
  // check if "heslo" was already seen by vr2x
  $already_seen_by_vr2x = FALSE;
  if (empty($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $values['node']->nid)
        ->execute()
        ->fetchAll();

    $already_seen_by_vr2x = !empty($transitions);
  }
  else {
    if (!empty($values['node']->field_atributy[LANGUAGE_NONE])) {
      $already_seen_by_vr2x = $values['node']->field_atributy[LANGUAGE_NONE][0]['value'] == 'VR2X';
    }
  }

  // if seen, move to vr4
  if ($already_seen_by_vr2x) {
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_4';
  }
}

/**
 * Helper function: transition to 2_korekt_ra
 */
function _run_2_korektura_single(&$values) {
  if ($values['state'] === '2_korekt_ra') {
    if (count($values['node']->field_lexikalna_skupina['und']) != 1) {
      //MS drupal_set_message('Ako lexikálnu skupinu zadajte meno požadovaného redaktora.', 'error');
      drupal_set_message('Heslo je zlúčené a má viacero lexikálnych skupín. Pri odosielaní na 2. korektúru však heslo môže mať len jednu lexikálnu skupinu.', 'error');
      drupal_set_message('Lexikálne skupiny upravte, heslo uložte a potom odošlite na 2. korektúru ešte raz. Po návrate z 2. korektúry sa lexikálne skupiny vrátia do pôvodného stavu.', 'error');
      $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
    }
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_vyst_redaktora_4' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U výstupného redaktora 4. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_jaz_redaktora_2' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U jazykového redaktora 2. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  if ($values['node']->workbench_moderation['current']->state === '2_korekt_ra' && $values['state'] === 'u_vyst_redaktora_3') {
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function to get user autocomplete form.
 *
 * @return array
 *   Array with form element.
 */
function _beliana_assign_user_form() {
  $form = array();
  $form['user'] = array(
    '#type' => 'textfield',
    '#title' => t('Vyberte autora, ktorému chcete heslo priradiť'),
    '#required' => TRUE,
    '#autocomplete_path' => 'user/autocomplete',
  );
  return $form;
}

/**
 * Helper function for user autocomplete form validation.
 *
 * @param array $form_state
 *   Array with form values.
 */
function _beliana_validate_assign_user_form(&$form_state) {
  if (user_load_by_name($form_state['values']['user']) === FALSE) {
    form_set_error('user', t('You need to choose existing user'));
  }
}

/**
 * Helper function for processing user autocomplete form submit.
 *
 * @param array $form_state
 *   Array with form values.
 * @param string $state
 *   New status for node.
 *
 * @return array
 *   Keyed array with user nd status.
 */
function _beliana_submit_assign_user_form($form_state, $state) {
  $return = array();
  $return['user'] = $form_state['values']['user'];
  $return['status'] = $state;
  return $return;
}

/**
 * Helper function changing node author and workflow status.
 *
 * @param object $node
 *   Object of node.
 * @param array $context
 *   Array of context.
 *
 * @throws \Exception
 *
 * @return FALSE
 *   Return FALSE if assigning of the new group failed.
 */
function _beliana_assign_user(&$node, $context) {
  $user = user_load_by_name($context['user']);
  if ($user !== FALSE) {
    // create array of node's categories
    $parents_all = taxonomy_get_parents_all(array_values($node->workbench_access)[0]);
    $node_taxo = array();
    foreach ($parents_all as $val) {
      $node_taxo[] = $val->tid;
    }
    // create array of user's categories
    $user_taxo = array();
    foreach ($user->workbench_access as $key => $val) {
      $user_taxo[] = $key;
    }
    // return if intersection is empty
    if (empty(array_intersect($node_taxo, $user_taxo))) {
      drupal_set_message($node->title . ' sa nepodarilo priradiť autorovi, pretože nemá zodpovedajúcu lexikálnu skupinu.', 'error');
      return FALSE;
    }
    $node->uid = $user->uid;
    node_save($node);
    workbench_moderation_moderate($node, $context['status']);
  }
}

/**
 * Helper function removing accents.
 *
 * @param string $text
 *   String we want to remove accents from.
 *
 * @return string
 *   String without accents.
 */
function _beliana_remove_accents($text) {
  $trans = array(
    'À' => 'A',
    'Á' => 'A',
    'Â' => 'A',
    'Ã' => 'A',
    'Ä' => 'A',
    'Å' => 'A',
    'Ç' => 'C',
    'È' => 'E',
    'É' => 'E',
    'Ê' => 'E',
    'Ë' => 'E',
    'Ì' => 'I',
    'Í' => 'I',
    'Î' => 'I',
    'Ï' => 'I',
    'Ñ' => 'N',
    'Ò' => 'O',
    'Ó' => 'O',
    'Ô' => 'O',
    'Õ' => 'O',
    'Ö' => 'O',
    'Ø' => 'O',
    'Ù' => 'U',
    'Ú' => 'U',
    'Û' => 'U',
    'Ü' => 'U',
    'Ý' => 'Y',
    'à' => 'a',
    'æ' => 'ae',
    'Æ' => 'ae',
    'á' => 'a',
    'â' => 'a',
    'ã' => 'a',
    'ä' => 'a',
    'å' => 'a',
    'ç' => 'c',
    'è' => 'e',
    'é' => 'e',
    'ê' => 'e',
    'ë' => 'e',
    'ì' => 'i',
    'í' => 'i',
    'î' => 'i',
    'ï' => 'i',
    'ñ' => 'n',
    'ò' => 'o',
    'ó' => 'o',
    'ô' => 'o',
    'õ' => 'o',
    'ö' => 'o',
    'ø' => 'o',
    'ù' => 'u',
    'ú' => 'u',
    'û' => 'u',
    'ü' => 'u',
    'ý' => 'y',
    'ÿ' => 'y',
    'Ā' => 'A',
    'ā' => 'a',
    'Ă' => 'A',
    'ă' => 'a',
    'Ą' => 'A',
    'ą' => 'a',
    'Ć' => 'C',
    'ć' => 'c',
    'Ĉ' => 'C',
    'ĉ' => 'c',
    'Ċ' => 'C',
    'ċ' => 'c',
    'Ď' => 'D',
    'ď' => 'd',
    'Đ' => 'D',
    'đ' => 'd',
    'Ē' => 'E',
    'ē' => 'e',
    'Ĕ' => 'E',
    'ĕ' => 'e',
    'Ė' => 'E',
    'ė' => 'e',
    'Ę' => 'E',
    'ę' => 'e',
    'Ě' => 'E',
    'ě' => 'e',
    'Ĝ' => 'G',
    'ĝ' => 'g',
    'Ğ' => 'G',
    'ğ' => 'g',
    'Ġ' => 'G',
    'ġ' => 'g',
    'Ģ' => 'G',
    'ģ' => 'g',
    'Ĥ' => 'H',
    'ĥ' => 'h',
    'Ħ' => 'H',
    'ħ' => 'h',
    'Ĩ' => 'I',
    'ĩ' => 'i',
    'Ī' => 'I',
    'ī' => 'i',
    'Ĭ' => 'I',
    'ĭ' => 'i',
    'Į' => 'I',
    'į' => 'i',
    'İ' => 'I',
    'ı' => 'i',
    'Ĵ' => 'J',
    'ĵ' => 'j',
    'Ķ' => 'K',
    'ķ' => 'k',
    'Ĺ' => 'L',
    'ĺ' => 'l',
    'Ļ' => 'L',
    'ļ' => 'l',
    'Ľ' => 'L',
    'ľ' => 'l',
    'Ŀ' => 'L',
    'ŀ' => 'l',
    'Ł' => 'L',
    'ł' => 'l',
    'Ń' => 'N',
    'ń' => 'n',
    'Ņ' => 'N',
    'ņ' => 'n',
    'Ň' => 'N',
    'ň' => 'n',
    'ŉ' => 'n',
    'Ō' => 'O',
    'ō' => 'o',
    'Ŏ' => 'O',
    'ŏ' => 'o',
    'Ő' => 'O',
    'ő' => 'o',
    'Ŕ' => 'R',
    'ŕ' => 'r',
    'Ŗ' => 'R',
    'ŗ' => 'r',
    'Ř' => 'R',
    'ř' => 'r',
    'Ś' => 'S',
    'ś' => 's',
    'Ŝ' => 'S',
    'ŝ' => 's',
    'Ş' => 'S',
    'ş' => 's',
    'Ţ' => 'T',
    'ţ' => 't',
    'Ť' => 'T',
    'ť' => 't',
    'Ŧ' => 'T',
    'ŧ' => 't',
    'Ũ' => 'U',
    'ũ' => 'u',
    'Ū' => 'U',
    'ū' => 'u',
    'Ŭ' => 'U',
    'ŭ' => 'u',
    'Ů' => 'U',
    'ů' => 'u',
    'Ű' => 'U',
    'ű' => 'u',
    'Ų' => 'U',
    'ų' => 'u',
    'Ŵ' => 'W',
    'ŵ' => 'w',
    'Ŷ' => 'Y',
    'ŷ' => 'y',
    'Ÿ' => 'Y',
    'Ź' => 'Z',
    'ź' => 'z',
    'Ż' => 'Z',
    'ż' => 'z',
    'ƀ' => 'b',
    'Ɓ' => 'B',
    'Ƃ' => 'B',
    'ƃ' => 'b',
    'Ƈ' => 'C',
    'ƈ' => 'c',
    'Ɗ' => 'D',
    'Ƌ' => 'D',
    'ƌ' => 'd',
    'Ƒ' => 'F',
    'ƒ' => 'f',
    'Ɠ' => 'G',
    'Ɨ' => 'I',
    'Ƙ' => 'K',
    'ƙ' => 'k',
    'ƚ' => 'l',
    'Ɲ' => 'N',
    'ƞ' => 'n',
    'Ɵ' => 'O',
    'Ơ' => 'O',
    'ơ' => 'o',
    'Ƥ' => 'P',
    'ƥ' => 'p',
    'ƫ' => 't',
    'Ƭ' => 'T',
    'ƭ' => 't',
    'Ʈ' => 'T',
    'Ư' => 'U',
    'ư' => 'u',
    'Ʋ' => 'V',
    'Ƴ' => 'Y',
    'ƴ' => 'y',
    'Ƶ' => 'Z',
    'ƶ' => 'z',
    'ǅ' => 'D',
    'ǈ' => 'L',
    'ǋ' => 'N',
    'Ǎ' => 'A',
    'ǎ' => 'a',
    'Ǐ' => 'I',
    'ǐ' => 'i',
    'Ǒ' => 'O',
    'ǒ' => 'o',
    'Ǔ' => 'U',
    'ǔ' => 'u',
    'Ǖ' => 'U',
    'ǖ' => 'u',
    'Ǘ' => 'U',
    'ǘ' => 'u',
    'Ǚ' => 'U',
    'ǚ' => 'u',
    'Ǜ' => 'U',
    'ǜ' => 'u',
    'Ǟ' => 'A',
    'ǟ' => 'a',
    'Ǡ' => 'A',
    'ǡ' => 'a',
    'Ǥ' => 'G',
    'ǥ' => 'g',
    'Ǧ' => 'G',
    'ǧ' => 'g',
    'Ǩ' => 'K',
    'ǩ' => 'k',
    'Ǫ' => 'O',
    'ǫ' => 'o',
    'Ǭ' => 'O',
    'ǭ' => 'o',
    'ǰ' => 'j',
    'ǲ' => 'D',
    'Ǵ' => 'G',
    'ǵ' => 'g',
    'Ǹ' => 'N',
    'ǹ' => 'n',
    'Ǻ' => 'A',
    'ǻ' => 'a',
    'Ǿ' => 'O',
    'ǿ' => 'o',
    'Ȁ' => 'A',
    'ȁ' => 'a',
    'Ȃ' => 'A',
    'ȃ' => 'a',
    'Ȅ' => 'E',
    'ȅ' => 'e',
    'Ȇ' => 'E',
    'ȇ' => 'e',
    'Ȉ' => 'I',
    'ȉ' => 'i',
    'Ȋ' => 'I',
    'ȋ' => 'i',
    'Ȍ' => 'O',
    'ȍ' => 'o',
    'Ȏ' => 'O',
    'ȏ' => 'o',
    'Ȑ' => 'R',
    'ȑ' => 'r',
    'Ȓ' => 'R',
    'ȓ' => 'r',
    'Ȕ' => 'U',
    'ȕ' => 'u',
    'Ȗ' => 'U',
    'ȗ' => 'u',
    'Ș' => 'S',
    'ș' => 's',
    'Ț' => 'T',
    'ț' => 't',
    'Ȟ' => 'H',
    'ȟ' => 'h',
    'Ƞ' => 'N',
    'ȡ' => 'd',
    'Ȥ' => 'Z',
    'ȥ' => 'z',
    'Ȧ' => 'A',
    'ȧ' => 'a',
    'Ȩ' => 'E',
    'ȩ' => 'e',
    'Ȫ' => 'O',
    'ȫ' => 'o',
    'Ȭ' => 'O',
    'ȭ' => 'o',
    'Ȯ' => 'O',
    'ȯ' => 'o',
    'Ȱ' => 'O',
    'ȱ' => 'o',
    'Ȳ' => 'Y',
    'ȳ' => 'y',
    'ȴ' => 'l',
    'ȵ' => 'n',
    'ȶ' => 't',
    'ȷ' => 'j',
    'Ⱥ' => 'A',
    'Ȼ' => 'C',
    'ȼ' => 'c',
    'Ƚ' => 'L',
    'Ⱦ' => 'T',
    'ȿ' => 's',
    'ɀ' => 'z',
    'Ƀ' => 'B',
    'Ʉ' => 'U',
    'Ɇ' => 'E',
    'ɇ' => 'e',
    'Ɉ' => 'J',
    'ɉ' => 'j',
    'ɋ' => 'q',
    'Ɍ' => 'R',
    'ɍ' => 'r',
    'Ɏ' => 'Y',
    'ɏ' => 'y',
    'ɓ' => 'b',
    'ɕ' => 'c',
    'ɖ' => 'd',
    'ɗ' => 'd',
    'ɟ' => 'j',
    'ɠ' => 'g',
    'ɦ' => 'h',
    'ɨ' => 'i',
    'ɫ' => 'l',
    'ɬ' => 'l',
    'ɭ' => 'l',
    'ɱ' => 'm',
    'ɲ' => 'n',
    'ɳ' => 'n',
    'ɵ' => 'o',
    'ɼ' => 'r',
    'ɽ' => 'r',
    'ɾ' => 'r',
    'ʂ' => 's',
    'ʄ' => 'j',
    'ʈ' => 't',
    'ʉ' => 'u',
    'ʋ' => 'v',
    'ʐ' => 'z',
    'ʑ' => 'z',
    'ʝ' => 'j',
    'ʠ' => 'q',
    'ͣ' => 'a',
    'ͤ' => 'e',
    'ͥ' => 'i',
    'ͦ' => 'o',
    'ͧ' => 'u',
    'ͨ' => 'c',
    'ͩ' => 'd',
    'ͪ' => 'h',
    'ͫ' => 'm',
    'ͬ' => 'r',
    'ͭ' => 't',
    'ͮ' => 'v',
    'ͯ' => 'x',
    'ᵢ' => 'i',
    'ᵣ' => 'r',
    'ᵤ' => 'u',
    'ᵥ' => 'v',
    'ᵬ' => 'b',
    'ᵭ' => 'd',
    'ᵮ' => 'f',
    'ᵯ' => 'm',
    'ᵰ' => 'n',
    'ᵱ' => 'p',
    'ᵲ' => 'r',
    'ᵳ' => 'r',
    'ᵴ' => 's',
    'ᵵ' => 't',
    'ᵶ' => 'z',
    'ᵻ' => 'i',
    'ᵽ' => 'p',
    'ᵾ' => 'u',
    'ᶀ' => 'b',
    'ᶁ' => 'd',
    'ᶂ' => 'f',
    'ᶃ' => 'g',
    'ᶄ' => 'k',
    'ᶅ' => 'l',
    'ᶆ' => 'm',
    'ᶇ' => 'n',
    'ᶈ' => 'p',
    'ᶉ' => 'r',
    'ᶊ' => 's',
    'ᶌ' => 'v',
    'ᶍ' => 'x',
    'ᶎ' => 'z',
    'ᶏ' => 'a',
    'ᶑ' => 'd',
    'ᶒ' => 'e',
    'ᶖ' => 'i',
    'ᶙ' => 'u',
    '᷊' => 'r',
    'ᷗ' => 'c',
    'ᷚ' => 'g',
    'ᷜ' => 'k',
    'ᷝ' => 'l',
    'ᷠ' => 'n',
    'ᷣ' => 'r',
    'ᷤ' => 's',
    'ᷦ' => 'z',
    'Ḁ' => 'A',
    'ḁ' => 'a',
    'Ḃ' => 'B',
    'ḃ' => 'b',
    'Ḅ' => 'B',
    'ḅ' => 'b',
    'Ḇ' => 'B',
    'ḇ' => 'b',
    'Ḉ' => 'C',
    'ḉ' => 'c',
    'Ḋ' => 'D',
    'ḋ' => 'd',
    'Ḍ' => 'D',
    'ḍ' => 'd',
    'Ḏ' => 'D',
    'ḏ' => 'd',
    'Ḑ' => 'D',
    'ḑ' => 'd',
    'Ḓ' => 'D',
    'ḓ' => 'd',
    'Ḕ' => 'E',
    'ḕ' => 'e',
    'Ḗ' => 'E',
    'ḗ' => 'e',
    'Ḙ' => 'E',
    'ḙ' => 'e',
    'Ḛ' => 'E',
    'ḛ' => 'e',
    'Ḝ' => 'E',
    'ḝ' => 'e',
    'Ḟ' => 'F',
    'ḟ' => 'f',
    'Ḡ' => 'G',
    'ḡ' => 'g',
    'Ḣ' => 'H',
    'ḣ' => 'h',
    'Ḥ' => 'H',
    'ḥ' => 'h',
    'Ḧ' => 'H',
    'ḧ' => 'h',
    'Ḩ' => 'H',
    'ḩ' => 'h',
    'Ḫ' => 'H',
    'ḫ' => 'h',
    'Ḭ' => 'I',
    'ḭ' => 'i',
    'Ḯ' => 'I',
    'ḯ' => 'i',
    'Ḱ' => 'K',
    'ḱ' => 'k',
    'Ḳ' => 'K',
    'ḳ' => 'k',
    'Ḵ' => 'K',
    'ḵ' => 'k',
    'Ḷ' => 'L',
    'ḷ' => 'l',
    'Ḹ' => 'L',
    'ḹ' => 'l',
    'Ḻ' => 'L',
    'ḻ' => 'l',
    'Ḽ' => 'L',
    'ḽ' => 'l',
    'Ḿ' => 'M',
    'ḿ' => 'm',
    'Ṁ' => 'M',
    'ṁ' => 'm',
    'Ṃ' => 'M',
    'ṃ' => 'm',
    'Ṅ' => 'N',
    'ṅ' => 'n',
    'Ṇ' => 'N',
    'ṇ' => 'n',
    'Ṉ' => 'N',
    'ṉ' => 'n',
    'Ṋ' => 'N',
    'ṋ' => 'n',
    'Ṍ' => 'O',
    'ṍ' => 'o',
    'Ṏ' => 'O',
    'ṏ' => 'o',
    'Ṑ' => 'O',
    'ṑ' => 'o',
    'Ṓ' => 'O',
    'ṓ' => 'o',
    'Ṕ' => 'P',
    'ṕ' => 'p',
    'Ṗ' => 'P',
    'ṗ' => 'p',
    'Ṙ' => 'R',
    'ṙ' => 'r',
    'Ṛ' => 'R',
    'ṛ' => 'r',
    'Ṝ' => 'R',
    'ṝ' => 'r',
    'Ṟ' => 'R',
    'ṟ' => 'r',
    'Ṡ' => 'S',
    'ṡ' => 's',
    'Ṣ' => 'S',
    'ṣ' => 's',
    'Ṥ' => 'S',
    'ṥ' => 's',
    'Ṧ' => 'S',
    'ṧ' => 's',
    'Ṩ' => 'S',
    'ṩ' => 's',
    'Ṫ' => 'T',
    'ṫ' => 't',
    'Ṭ' => 'T',
    'ṭ' => 't',
    'Ṯ' => 'T',
    'ṯ' => 't',
    'Ṱ' => 'T',
    'ṱ' => 't',
    'Ṳ' => 'U',
    'ṳ' => 'u',
    'Ṵ' => 'U',
    'ṵ' => 'u',
    'Ṷ' => 'U',
    'ṷ' => 'u',
    'Ṹ' => 'U',
    'ṹ' => 'u',
    'Ṻ' => 'U',
    'ṻ' => 'u',
    'Ṽ' => 'V',
    'ṽ' => 'v',
    'Ṿ' => 'V',
    'ṿ' => 'v',
    'Ẁ' => 'W',
    'ẁ' => 'w',
    'Ẃ' => 'W',
    'ẃ' => 'w',
    'Ẅ' => 'W',
    'ẅ' => 'w',
    'Ẇ' => 'W',
    'ẇ' => 'w',
    'Ẉ' => 'W',
    'ẉ' => 'w',
    'Ẋ' => 'X',
    'ẋ' => 'x',
    'Ẍ' => 'X',
    'ẍ' => 'x',
    'Ẏ' => 'Y',
    'ẏ' => 'y',
    'Ẑ' => 'Z',
    'ẑ' => 'z',
    'Ẓ' => 'Z',
    'ẓ' => 'z',
    'Ẕ' => 'Z',
    'ẕ' => 'z',
    'ẖ' => 'h',
    'ẗ' => 't',
    'ẘ' => 'w',
    'ẙ' => 'y',
    'ẚ' => 'a',
    'Ạ' => 'A',
    'ạ' => 'a',
    'Ả' => 'A',
    'ả' => 'a',
    'Ấ' => 'A',
    'ấ' => 'a',
    'Ầ' => 'A',
    'ầ' => 'a',
    'Ẩ' => 'A',
    'ẩ' => 'a',
    'Ẫ' => 'A',
    'ẫ' => 'a',
    'Ậ' => 'A',
    'ậ' => 'a',
    'Ắ' => 'A',
    'ắ' => 'a',
    'Ằ' => 'A',
    'ằ' => 'a',
    'Ẳ' => 'A',
    'ẳ' => 'a',
    'Ẵ' => 'A',
    'ẵ' => 'a',
    'Ặ' => 'A',
    'ặ' => 'a',
    'Ẹ' => 'E',
    'ẹ' => 'e',
    'Ẻ' => 'E',
    'ẻ' => 'e',
    'Ẽ' => 'E',
    'ẽ' => 'e',
    'Ế' => 'E',
    'ế' => 'e',
    'Ề' => 'E',
    'ề' => 'e',
    'Ể' => 'E',
    'ể' => 'e',
    'Ễ' => 'E',
    'ễ' => 'e',
    'Ệ' => 'E',
    'ệ' => 'e',
    'Ỉ' => 'I',
    'ỉ' => 'i',
    'Ị' => 'I',
    'ị' => 'i',
    'Ọ' => 'O',
    'ọ' => 'o',
    'Ỏ' => 'O',
    'ỏ' => 'o',
    'Ố' => 'O',
    'ố' => 'o',
    'Ồ' => 'O',
    'ồ' => 'o',
    'Ổ' => 'O',
    'ổ' => 'o',
    'Ỗ' => 'O',
    'ỗ' => 'o',
    'Ộ' => 'O',
    'ộ' => 'o',
    'Ớ' => 'O',
    'ớ' => 'o',
    'Ờ' => 'O',
    'ờ' => 'o',
    'Ở' => 'O',
    'ở' => 'o',
    'Ỡ' => 'O',
    'ỡ' => 'o',
    'Ợ' => 'O',
    'ợ' => 'o',
    'Ụ' => 'U',
    'ụ' => 'u',
    'Ủ' => 'U',
    'ủ' => 'u',
    'Ứ' => 'U',
    'ứ' => 'u',
    'Ừ' => 'U',
    'ừ' => 'u',
    'Ử' => 'U',
    'ử' => 'u',
    'Ữ' => 'U',
    'ữ' => 'u',
    'Ự' => 'U',
    'ự' => 'u',
    'Ỳ' => 'Y',
    'ỳ' => 'y',
    'Ỵ' => 'Y',
    'ỵ' => 'y',
    'Ỷ' => 'Y',
    'ỷ' => 'y',
    'Ỹ' => 'Y',
    'ỹ' => 'y',
    'Ỿ' => 'Y',
    'ỿ' => 'y',
    'ⁱ' => 'i',
    'ⁿ' => 'n',
    'ₐ' => 'a',
    'ₑ' => 'e',
    'ₒ' => 'o',
    'ₓ' => 'x',
    '⒜' => 'a',
    '⒝' => 'b',
    '⒞' => 'c',
    '⒟' => 'd',
    '⒠' => 'e',
    '⒡' => 'f',
    '⒢' => 'g',
    '⒣' => 'h',
    '⒤' => 'i',
    '⒥' => 'j',
    '⒦' => 'k',
    '⒧' => 'l',
    '⒨' => 'm',
    '⒩' => 'n',
    '⒪' => 'o',
    '⒫' => 'p',
    '⒬' => 'q',
    '⒭' => 'r',
    '⒮' => 's',
    '⒯' => 't',
    '⒰' => 'u',
    '⒱' => 'v',
    '⒲' => 'w',
    '⒳' => 'x',
    '⒴' => 'y',
    '⒵' => 'z',
    'Ⓐ' => 'A',
    'Ⓑ' => 'B',
    'Ⓒ' => 'C',
    'Ⓓ' => 'D',
    'Ⓔ' => 'E',
    'Ⓕ' => 'F',
    'Ⓖ' => 'G',
    'Ⓗ' => 'H',
    'Ⓘ' => 'I',
    'Ⓙ' => 'J',
    'Ⓚ' => 'K',
    'Ⓛ' => 'L',
    'Ⓜ' => 'M',
    'Ⓝ' => 'N',
    'Ⓞ' => 'O',
    'Ⓟ' => 'P',
    'Ⓠ' => 'Q',
    'Ⓡ' => 'R',
    'Ⓢ' => 'S',
    'Ⓣ' => 'T',
    'Ⓤ' => 'U',
    'Ⓥ' => 'V',
    'Ⓦ' => 'W',
    'Ⓧ' => 'X',
    'Ⓨ' => 'Y',
    'Ⓩ' => 'Z',
    'ⓐ' => 'a',
    'ⓑ' => 'b',
    'ⓒ' => 'c',
    'ⓓ' => 'd',
    'ⓔ' => 'e',
    'ⓕ' => 'f',
    'ⓖ' => 'g',
    'ⓗ' => 'h',
    'ⓘ' => 'i',
    'ⓙ' => 'j',
    'ⓚ' => 'k',
    'ⓛ' => 'l',
    'ⓜ' => 'm',
    'ⓝ' => 'n',
    'ⓞ' => 'o',
    'ⓟ' => 'p',
    'ⓠ' => 'q',
    'ⓡ' => 'r',
    'ⓢ' => 's',
    'ⓣ' => 't',
    'ⓤ' => 'u',
    'ⓥ' => 'v',
    'ⓦ' => 'w',
    'ⓧ' => 'x',
    'ⓨ' => 'y',
    'ⓩ' => 'z',
    'Ⱡ' => 'L',
    'ⱡ' => 'l',
    'Ɫ' => 'L',
    'Ᵽ' => 'P',
    'Ɽ' => 'R',
    'ⱥ' => 'a',
    'ⱦ' => 't',
    'Ⱨ' => 'H',
    'ⱨ' => 'h',
    'Ⱪ' => 'K',
    'ⱪ' => 'k',
    'Ⱬ' => 'Z',
    'ⱬ' => 'z',
    'Ɱ' => 'M',
    'ⱱ' => 'v',
    'Ⱳ' => 'W',
    'ⱳ' => 'w',
    'ⱴ' => 'v',
    'ⱸ' => 'e',
    'ⱺ' => 'o',
    'ⱼ' => 'j',
    'Ꝁ' => 'K',
    'ꝁ' => 'k',
    'Ꝃ' => 'K',
    'ꝃ' => 'k',
    'Ꝅ' => 'K',
    'ꝅ' => 'k',
    'Ꝉ' => 'L',
    'ꝉ' => 'l',
    'Ꝋ' => 'O',
    'ꝋ' => 'o',
    'Ꝍ' => 'O',
    'ꝍ' => 'o',
    'Ꝑ' => 'P',
    'ꝑ' => 'p',
    'Ꝓ' => 'P',
    'ꝓ' => 'p',
    'Ꝕ' => 'P',
    'ꝕ' => 'p',
    'Ꝗ' => 'Q',
    'ꝗ' => 'q',
    'Ꝙ' => 'Q',
    'ꝙ' => 'q',
    'Ꝛ' => 'R',
    'ꝛ' => 'r',
    'Ꝟ' => 'V',
    'ꝟ' => 'v',
    'Ａ' => 'A',
    'Ｂ' => 'B',
    'Ｃ' => 'C',
    'Ｄ' => 'D',
    'Ｅ' => 'E',
    'Ｆ' => 'F',
    'Ｇ' => 'G',
    'Ｈ' => 'H',
    'Ｉ' => 'I',
    'Ｊ' => 'J',
    'Ｋ' => 'K',
    'Ｌ' => 'L',
    'Ｍ' => 'M',
    'Ｎ' => 'N',
    'Ｏ' => 'O',
    'Ｐ' => 'P',
    'Ｑ' => 'Q',
    'Ｒ' => 'R',
    'Ｓ' => 'S',
    'Ｔ' => 'T',
    'Ｕ' => 'U',
    'Ｖ' => 'V',
    'Ｗ' => 'W',
    'Ｘ' => 'X',
    'Ｙ' => 'Y',
    'Ｚ' => 'Z',
    'ａ' => 'a',
    'ｂ' => 'b',
    'ｃ' => 'c',
    'ｄ' => 'd',
    'ｅ' => 'e',
    'ｆ' => 'f',
    'ｇ' => 'g',
    'ｈ' => 'h',
    'ｉ' => 'i',
    'ｊ' => 'j',
    'ｋ' => 'k',
    'ｌ' => 'l',
    'ｍ' => 'm',
    'ｎ' => 'n',
    'ｏ' => 'o',
    'ｐ' => 'p',
    'ｑ' => 'q',
    'ｒ' => 'r',
    'ｓ' => 's',
    'ｔ' => 't',
    'ｕ' => 'u',
    'ｖ' => 'v',
    'ｗ' => 'w',
    'ｘ' => 'x',
    'ｙ' => 'y',
    'ｚ' => 'z',
  );
  return strtr($text, $trans);
}

/**
 * Helper function to extract dates from an article header
 *
 * @param string $text
 *   String with the article text (field_text_hesla)
 *
 * @return array
 *   Array of dates to be stored in field_datum, may be empty
 */
function get_header_dates($text) {
  $dates = array();

  # ignore pure reference articles  (they do not contain em dash "—")
  $exploded = explode("—", $text);
  if (count($exploded) > 1) {
    // $header = $exploded[0];
    // remove tags first
    $header = preg_replace('/<[^>]*>/', '', $exploded[0]);
    # find all dates in header
    $pattern = "/ (\d{1,2}. \d{1,2}. \d{4} )/";
    preg_match_all($pattern, $header, $matches);

    # convert dates to importable form and save them to 'dates'
    foreach ($matches[0] as $mt) {
      sscanf($mt, "%d. %d. %d", $d, $m, $y);
      if ($y > 999) { # drupal does not like dates prior to 1000
        $odate = sprintf("%d-%02d-%02dT00:00:00", $y, $m, $d);
        array_push($dates, $odate);
      }
    }
  }
  return $dates;
}

/**
 * Delete unnecessary tags from node text
 * these usually originate from pasting from Word and from highlighting text and undoing the highlights
 *
 * @param $node
 *   node the next 'text' argument relates to (may be article node, but the text may be related to illustration)
 * @param string $text
 *   node text area to be represented
 * @param string $where
 *   some text for an error message
 *
 * @return 
 *   cleaned $text or unchenged $text in case of an error (e.g. not valid html)
 */
function beliana_clean_tags($node, $text, $where) {
  $dom = beliana_get_dom($node, $text, $where);
  if (!$dom)
    return $text;

  $xpath = new DOMXPath($dom);
  // remove tags completely: <ins>, <span>, ....
  $rmtags = array(
    '//ins[not(@*)]',
    '//span[not(@*)]',
    '//span[@style="background-color:null"]',
    '//span[@style="background-color:#ffffff"]',
    '//span[@style="background-color:white"]',
    '//td/p',
  );
  foreach ($rmtags as $tag) {
    //_remove_node($xpath, $tag);
    // Move all tag node content to its parent node just before it.
    foreach ($xpath->query($tag) as $textnode) {
      while ($textnode->hasChildNodes()) {
        $child = $textnode->removeChild($textnode->firstChild);
        $textnode->parentNode->insertBefore($child, $textnode);
      }
      // Remove the tag node.
      $textnode->parentNode->removeChild($textnode);
    }
  }

  // remove tag attributes
  $cltags = array(
    array("a", "style"),
    array("a", "target"),
    array("td", "style"),
    array("th", "class"),
    array("table", "border"),
    array("table", "cellspacing"),
    array("table", "cellpadding"),
    array("table", "style"),
  );
  foreach ($cltags as $cltag) {
    $tagstring = "//" . $cltag[0] . "[@" . $cltag[1] . "]";
    foreach ($xpath->query($tagstring) as $tag) {
      $sNode = $tag->getAttributeNode($cltag[1]);
      $tag->removeAttributeNode($sNode);
    }
  }

  $fragment = '';
  foreach ($dom->getElementsByTagName('body')->item(0)->childNodes as $chnode) {
    $fragment .= $dom->saveHtml($chnode);
  }
  //fix a problem caused somewhere above (<br> is later replaced by a pair of  <br /> tags)
  $fragment = str_replace("<br>", "<br />", $fragment);

  //remove formatted space (non-breakable space fixed too)
  $fragment = str_replace("<em> </em>", " ", $fragment);
  $fragment = str_replace("<em> </em>", " ", $fragment);
  $fragment = str_replace("<strong> </strong>", " ", $fragment);
  $fragment = str_replace("<strong> </strong>", " ", $fragment);

  // remove empty lines at start and at end
  // CKeditor inserts as empty line "<p> </p>" with non-breakable space 
  // nonbreakable space: " " here
  $fragment = preg_replace('#^(<p> </p>[\r\n]*)*#', '', $fragment);
  $fragment = preg_replace('#[\r\n]*$#', '', $fragment);
  $fragment = preg_replace('#([\r\n]*<p> </p>)*$#', '', $fragment);
  // the same with (repeated) normal space
  $fragment = preg_replace('#^(<p> *</p>[\r\n]*)*#', '', $fragment);
  $fragment = preg_replace('#[\r\n]*$#', '', $fragment);
  $fragment = preg_replace('#([\r\n]*<p> *</p>)*$#', '', $fragment);

  return $fragment;
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links($node) {
  #dpm("_beliana_process_links", $node->title);
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  db_delete('beliana_links')
      ->condition('origin', $nid)
      ->execute();
  // Extract links.
  $text = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
  // do not continue if text is empty
  if ($text === "")
    return;
  $dom = beliana_get_dom($node, $text, "Text hesla (beliana_process_links)");
  if (!$dom)
    return;

  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = $links->length - 1; $i >= 0; $i--) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      if (!url_is_external($target)) {
        // Get rid of leading slash.
        if ($target[0] === '/') {
          $target = substr($target, 1);
        }
        // Get non-alias path, so we can get nid from it.
        $path = drupal_get_normal_path($target);
        $path_elements = explode('/', $path);
        // If alias belong to node, then insert record into beliana_links table.
        if ($path_elements[0] === 'node' && is_numeric($path_elements[1])) {
          $link = db_select('beliana_links', 'l')
              ->fields('l', ['origin'])
              ->condition('origin', $nid)
              ->condition('target', $path_elements[1])
              ->execute()
              ->fetchCol(0);
          // We insert new item only if it already doesn't exist.
          if (empty($link)) {
            db_insert('beliana_links')
                ->fields([
                  'origin' => $nid,
                  'target' => $path_elements[1],
                ])
                ->execute();
          }
        }
      }
    }
  }
}

/**
 * Helper function for representing node text as DOM
 *
 * @param $node
 *   node the next 'text' argument relates to (may be article node, but the text may be related to illustration)
 * @param string $text
 *   node text area to be represented
 * @param string $where
 *   some text for an error message
 *
 * @return 
 *   null or $dom
 *   no error message if $where == Null
 */
function beliana_get_dom($node, $text, $where = Null) {
  $internalErrorsState = libxml_use_internal_errors(true);
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));

  // handle errors locally
  $errors = libxml_get_errors();
  if ($errors) {
    # clear errors and restore error loging status
    if ($where) {
      foreach ($errors as $error) {
        html_error($node, $error, "Chyba HTML syntaxe v poli '" . $where);
      }
    }
    libxml_clear_errors();
    libxml_use_internal_errors($internalErrorsState);
    return null;
  }
  # clear errors and restore error loging status
  libxml_clear_errors();
  libxml_use_internal_errors($internalErrorsState);
  return $dom;
}
