<?php

#vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana module.
 */

/**
 * Implements hook_views_api().
 */
function beliana_views_api() {
  return [
    'api' => 3,
    'path' => drupal_get_path('module', 'beliana') . '/views',
  ];
}

/**
 * Implements hook_menu().
 *
 * @inheritdoc
 */
function beliana_menu() {
  $items = [];
  $items['admin/users-list'] = [
    'title' => t('Users list'),
    'page callback' => 'beliana_users_list',
    'access arguments' => ['bypass node access'],
  ];

  // implemented in rs/rsw modules
  $items['admin/group-list'] = [
    'title' => t('Group list'),
    'page callback' => 'beliana_group_list',
    'access callback' => 'beliana_group_list_access',
    'access arguments' => ['bypass node access'],
  ];

  $items['admin/editor-list'] = [
    'title' => t('Editor list'),
    'page callback' => 'beliana_editor_list',
    'access callback' => 'beliana_editor_list_access',
    'access arguments' => ['bypass node access'],
  ];

  $items['node/%node/sync-from'] = [
    'title' => 'Prebrať obsah',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['beliana_sync_from_remote_form', 1],
    'access callback' => 'beliana_sync_from_remote_access',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
  ];

  $items['node/%node/sync-from/confirm'] = [
    'title' => 'Prebrať obsah',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['beliana_sync_from_remote_confirm_form', 1],
    'access callback' => 'beliana_sync_from_remote_access',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
  ];

  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * @inheritdoc
 */
function beliana_menu_alter(&$items) {
  if (isset($items['admin/workbench/sections'])) {
    unset($items['admin/workbench/sections']);
  }

  if (isset($items['node/%node/draft'])) {
    unset($items['node/%node/draft']);
  }

  if (isset($items['node/%node/revisions'])) {
    unset($items['node/%node/revisions']);
  }

  /* get rid of the 'Index' item in the menu */
  if (isset($items['admin/index'])) {
    unset($items['admin/index']);
  }

  /* get rid of the create/forum item in the menu */
  /* not a good idea - blocks the possibility to create topics */
  //if (isset($items['node/add/forum'])) {
  //unset($items['node/add/forum']);
  //}
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * @inheritdoc
 */
function beliana_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  if (isset($data['tabs'][0]['output'])) {
    foreach ($data['tabs'][0]['output'] as $i => $tab) {
      if (in_array($tab['#link']['path'], [
        'admin/tasks',
        'admin/index',
      ])) {
        unset($data['tabs'][0]['output'][$i]);
      }
    }
  }
}

/**
 * Implements hook_permission().
 */
function beliana_permission() {
  return [
    'sync heslo content' => [
      'title' => t('Allow synchronise remote node'),
    ],
  ];
}

function beliana_sync_from_remote_access($node) {
  global $user;

  $response = workbench_access_node_access($node, 'update', $user);

  if ($response != NODE_ACCESS_DENY && user_access('sync heslo content')) {
    switch ($node->type) {
      case 'heslo':
        return in_array($node->workbench_moderation['current']->state, [
          'zaradene',
          'needs_review',
        ]);
      case 'ilustracia':
        return in_array($node->workbench_moderation['current']->state, ['ilustracia_u_redaktora']);
    }
  }

  return FALSE;
}


/**
 * Implements hook_page_alter().
 */
function beliana_page_alter(&$page) {
  if (privatemsg_user_access() && !drupal_match_path(current_path(), 'node/*/edit')) {
    $count = privatemsg_unread_count();
    if ($count) {
      drupal_set_message(format_plural($count, 'You have <a href="@messages">1 unread message</a>.', 'You have <a href="@messages">@count unread messages</a>', ['@messages' => url('messages')]));
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function beliana_form_heslo_node_form_alter(&$form, &$form_state) {
  if (empty($form['nid']['#value'])) {
    $base_url = variable_get('rs_api_uri');
    $request_url = $base_url . '/api/heslo';

    // Check connection to opposite REST server
    if ($login = beliana_api_rest_login($request_url)) {

    }
    else {
      $form['title']['#disabled'] = TRUE;

      foreach ($form as $key => $field) {
        if (strpos($key, 'field_') === 0) {
          $form[$key][LANGUAGE_NONE]['#disabled'] = TRUE;
        }
      }

      hide($form['actions']);

      drupal_set_message(t('Unable to connect <strong>@site</strong> REST API. Check <a href="/admin/config/services/beliana-sync" target="_blank">configuration</a>', ['@site' => $base_url]), 'error');
    }
  }
}

function beliana_workbench_access_check($op, $type, $access_ids, $account_access) {
  global $user;

  if ($op == 'view') {
    return TRUE;
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * @inheritdoc
 */
function beliana_field_formatter_info() {
  return [
    'beliana_external_image' => [
      'label' => t('External image'),
      'field types' => ['url'],
      'settings' => [
        'size' => 'medium',
        'link' => 0,
      ],
    ],
  ];
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function beliana_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = [];

  $element['size'] = [
    '#type' => 'select',
    '#title' => t('Image style'),
    '#default_value' => $settings['size'],
  ];

  $element['link'] = [
    '#type' => 'select',
    '#title' => t('Link'),
    '#default_value' => $settings['link'],
    '#options' => [t('No'), t('Yes')],
  ];

  foreach (image_styles() as $key => $style) {
    $element['size']['#options'][$key] = $style['label'];
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function beliana_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $styles = image_styles();
  $options = [t('No'), t('Yes')];

  return t('Image style: @size, Link: @link', [
    '@size' => $styles[$settings['size']]['label'],
    '@link' => $options[$settings['link']],
  ]);
}

/**
 * Implements hook_field_formatter_view().
 *
 * @inheritdoc
 */
function beliana_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = [];
  $settings = $display['settings'];

  if ($display['type'] == 'beliana_external_image') {
    $width = 100;
    $styles = image_styles();

    foreach ($styles[$settings['size']]['effects'] as $effect) {
      if ($effect['name'] == 'image_scale') {
        $width = $effect['data']['width'];
      }
    }

    foreach ($items as $delta => $item) {
      $img = '<img src="' . $item['value'] . '" width="' . $width . '" />';

      $element[$delta] = ['#markup' => $img];
      if ($settings['link'] > 0) {
        $element[$delta]['#markup'] = l($img, $item['value'], [
          'html' => TRUE,
          'external' => TRUE,
        ]);
      }
    }
  }

  return $element;
}

/**
 * Menu callback for `admin/editor-list` path.
 *
 * We are printing editor's taxonomy classes. Fo the current editor also
 * his/her authors are listed
 *
 * @return string
 *   HTML output of users.
 */
function beliana_editor_list() {
  global $user;
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  # create a list of parents for each term
  $termParentList = [];
  foreach ($terms as $term) {
    $termParentList[$term->tid] = $term->parents[0];
  }
  $output = '';
  // get taxonomy access list of the current user (it is not part of the $user variable)
  foreach ($users as $usr) {
    if ($usr->uid == $user->uid) {
      $user_wba = $usr->workbench_access;
      break;
    }
  }
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    if ($term->depth == 0) {
      $output .= '<br /><h1>' . $term->name . '</h1>';
    }
    else {
      //$output .= '<h3> Lexikálna skupina: <em>' . $term->name . '</em></h3>';
      $output .= '<strong>' . $term->name . '</strong>';
      $output .= '<ul>';
      foreach ($users as $usr) {
	if (substr($usr->name,0,5) == 'test_') continue;
        if (isset($usr->workbench_access[$term->tid])) {
          // we want to print only user in the role Redaktor and Author (but these only if $user has access rights)
          if (in_array("Autor", $usr->roles)) {
            // administrator and useradmin should see all authors
            if (!in_array("administrátor", $user->roles) && !in_array("useradmin", $user->roles)) {
              # check access rights in all hierarchy levels
              if (!(isset($user_wba[$term->tid]) or
                isset($user_wba[$term->parents[0]]) or #first parent
                isset($user_wba[$termParentList[$term->parents[0]]])  #second parent, if 3 levels were used
              )) {
                continue;
              }
            }
          }
          else {
            continue;
            if (!in_array("Redaktor", $usr->roles)) {
              continue;
            }
          }
          $output .= '<li>'
            . $usr->name . ', '
            . $usr->field_meno['und'][0]['value'] . ', '
            . $usr->field_priezvisko['und'][0]['value'] . ', ';
          if (isset($usr->field_autorska_zmluva['und'])) {
            $output .= $usr->mail . ', '
              . $usr->field_autorska_zmluva['und'][0]['value'] . '</li>';
          }
          else {
            $output .= $usr->mail . '</li>';
          }
        }
      }
      //$output .= '</ul><br><br>';
      $output .= '</ul>';
    }
  }
  return $output;
}

/**
 * Menu callback for `admin/users-list` path.
 *
 * We are printing users with group assigned to users.
 *
 * @return string
 *   HTML output of all users with their groups.
 */
function beliana_users_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($users as $user) {
    $output .= '<div>';
    $output .= '<h3> Lexikálne skupiny používateľa <em>' . $user->name . '</em></h3>';
    $output .= '<ul>';
    foreach ($terms as $t) {
      if (isset($user->workbench_access[$t->tid])) {
        $output .= '<li>' . $t->name . '</li>';
      }
    }
    $output .= '</ul><br><br></div>';
  }
  return $output;
}

/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_action_info() {
  return [
    'beliana_assign_author' => [
      'type' => 'entity',
      'label' => t('Specify author and assign to author'),
      'configurable' => TRUE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'beliana_assign_corrector' => [
      'type' => 'entity',
      'label' => t('Specify author and assign to editor'),
      'configurable' => TRUE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'beliana_assign_consultant' => [
      'type' => 'entity',
      'label' => t('Assign to consultant'),
      'configurable' => TRUE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'importovane_publish_editor' => [
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie'),
      'label' => t('Mark for publishing (editor)'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'importovane_publish_senior_editor' => [
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (VR)'),
      'label' => t('Mark for publishing (senior editor)'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'importovane_publish_proofreader' => [
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (JR)'),
      'label' => t('Mark for publishing (proofreader)'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'update_dates' => [
      'type' => 'entity',
      //'label' => t('Aktualizovať dátumy'),
      'label' => t('Update dates'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'check_path_attributes' => [
      'type' => 'entity',
      'label' => t('Check link'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'update_author_payment_data' => [
      'type' => 'entity',
      'label' => t('Update author payment data'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ],
    'prune_node_revisions' => [
      'type' => 'node',
      'label' => t('Prune node revisions'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => FALSE,
    ],
    'beliana_sync_from_remote_action' => [
      'type' => 'node',
      'label' => 'Prebrať obsah',
      'behavior' => ['changes_property'],
      'configurable' => TRUE,
      'vbo_configurable' => FALSE,
      'triggers' => ['any'],
      'permissions' => ['sync heslo content'],
    ],
    'reset_importovane_and_link_transfer' => [
      'type' => 'node',
      'label' => t('Reset importovane and transfer links'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => FALSE,
    ],
    'reset_vyradene_ilustracie' => [
      'type' => 'node',
      'label' => t('Reset ruled out illustrations'),
      'configurable' => FALSE,
      'triggers' => ['any'],
      'behavior' => ['create_property'],
      'vbo_configurable' => FALSE,
      'pass rows' => FALSE,
    ],
  ];
}

/**
 * Callback for 'importovane_publish_editor' action.
 *
 * changes workflow status to 'importovane_u_jr2'
 *
 * @inheritdoc
 */
function importovane_publish_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane') {
    $skip = FALSE;
    if (!_check_links($node)) {
      $skip = TRUE;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = TRUE;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "importovane_u_jr2");
    }
  }
}

/**
 * Callback for 'importovane_publish_proofreader' action.
 *
 * changes workflow status to 'importovane_u_vr'
 *
 * @inheritdoc
 */
function importovane_publish_proofreader(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_jr2') {
    if (_check_links($node)) {
      workbench_moderation_moderate($node, "importovane_u_vr");
    }
  }
}

/**
 * Callback for 'importovane_publish_senior_editor' action.
 *
 * changes workflow status to 'na_zalomenie'
 *
 * @inheritdoc
 */
function importovane_publish_senior_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_vr') {
    $skip = FALSE;
    if (!_check_links($node)) {
      $skip = TRUE;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = TRUE;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "na_zalomenie");
    }
  }
}

function beliana_sync_from_remote_action_form($settings, &$form_state) {
  $form = [];

  return $form;
}

function beliana_sync_from_remote_action_submit($form, $form_state) {
  $return = [];

  return $return;
}

function beliana_sync_from_remote_action(&$node, $context) {
  beliana_sync_from_remote($node);
}

/**
 *
 * @inheritdoc
 */
function beliana_assign_author_form($form, &$form_state) {
  return _beliana_assign_user_form('Choose the author to assign articles to');
}

/**
 * Validation for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state, ["Autor"]);
}

/**
 * Submit function for `beliana_assign_author_form`.
 *
 * @inheritdoc
 */
function beliana_assign_author_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'u_autora');
}

/**
 * Callback for `beliana_assign_author` action.
 *
 * Assigns selected user as node author and
 * changes workflow status to `u_autora`.
 *
 * @inheritdoc
 */
function beliana_assign_author(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Configuration form for `beliana_assign_corrector` action.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_form($form, &$form_state) {
  return _beliana_assign_user_form('Choose the author to assign articles to');
}

/**
 * Validation for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state, ["Autor", "Redaktor"]);
}

/**
 * Submit function for for `beliana_assign_corrector_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_corrector_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'needs_review');
}

/**
 * Callback function for `beliana_assign_corrector` action.
 *
 * Assigns selected user as node author and
 * change workflow status to `needs_review`.
 *
 * @inheritdoc
 */
function beliana_assign_corrector(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * Configuration form for `beliana_assign_consultant` action.
 *
 * @inheritdoc
 */
function beliana_assign_consultant_form($form, &$form_state) {
  return _beliana_assign_user_form('Choose the consultant to assign articles to');
}

/**
 * Validation for `beliana_assign_consultant_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_consultant_validate($form, &$form_state) {
  _beliana_validate_assign_user_form($form_state, ["Konzultant"]);
}

/**
 * Submit function for for `beliana_assign_consultant_form` form.
 *
 * @inheritdoc
 */
function beliana_assign_consultant_submit($form, $form_state) {
  return _beliana_submit_assign_user_form($form_state, 'u_konzultanta');
}

/**
 * Callback for `beliana_assign_consultant` action.
 *
 * Assigns selected user as node author and
 * changes workflow status to `u_autora`.
 *
 * @inheritdoc
 */
function beliana_assign_consultant(&$node, $context) {
  _beliana_assign_user($node, $context);
}

/**
 * @inheritdoc
 */
function beliana_sync_from_remote_form($form, $form_state, $node) {
  $type = variable_get('rs_api_type') == 'webrs' ? 'webov' : 'knižn';
  $prep = variable_get('rs_api_type') == 'webrs' ? 'vo' : 'v';
  $bundle = $node->type == 'ilustracia' ? 'Ilustrácia' : 'Heslo';

  $date = empty($node->field_datum_prebratia[LANGUAGE_NONE]) ? 'Nikdy' : $node->field_datum_prebratia[LANGUAGE_NONE][0]['value'];
  $remote_id = empty($node->field_remote_id[LANGUAGE_NONE]) ? $node->nid : $node->field_remote_id[LANGUAGE_NONE][0]['value'];

  $form['links'] = [
    '#markup' => $bundle . ' ' . $prep . ' ' . $type . 'om redakčnom systéme: <b><a href="' . variable_get('rs_api_uri') . '/node/' . $remote_id . '" target="_blank">' . $remote_id . '</a></b>.<br>' .
      'Po prevzatím obsahu z ' . $type . 'ého redakčného systému bude lokálny obsah prepísaný.<br>' .
      'Preberaný obsah musí byť dokončený.<br><br>',
  ];

  $form['message'] = [
    '#markup' => 'Dátum posledného prenosu obsahu: <b>' . $date . '</b>.<br><br>',
  ];

  $form['nid'] = [
    '#type' => 'hidden',
    '#value' => $node->nid,
  ];

  $form['submit'] = [
    '#type' => 'submit',
    '#value' => 'Prebrať',
  ];

  return $form;
}

function beliana_sync_from_remote_form_submit($form, &$form_state) {
  $form_state['redirect'] = ['node/' . $form_state['values']['nid'] . '/sync-from/confirm'];
}

function beliana_sync_from_remote_confirm_form($form, $form_state, $node) {
  $form['nid'] = [
    '#type' => 'hidden',
    '#value' => $node->nid,
  ];

  return confirm_form(
    $form,
    t('Are you sure you want to perform this action?'),
    'node/' . $node->nid . '/sync-from',
    t('This action cannot be undone.'),
    t('Confirm'),
    t('Cancel')
  );
}

function beliana_sync_from_remote_confirm_form_submit($form, &$form_state) {
  beliana_sync_from_remote(node_load($form_state['values']['nid']));

  $form_state['redirect'] = ['node/' . $form_state['values']['nid'] . '/sync-from'];
}

function beliana_sync_from_remote($node) {
  $remote_id = empty($node->field_remote_id[LANGUAGE_NONE]) ? $node->nid : $node->field_remote_id[LANGUAGE_NONE][0]['value'];

  if ($remote_node = beliana_api_rest_get_node($remote_id)) {
    beliana_sync_from_remote_build($node, $remote_node);
  }
  else {
    drupal_set_message(t('Nepodarilo sa prevziať heslo @id (komunikačná chyba API)', ['@id' => $remote_id]), 'error');
  }
}

function beliana_sync_from_remote_build($node, $remote_node) {
  global $user;

  $api_type = variable_get('rs_api_type');

  $label_type = $api_type == 'webrs' ? 'webov' : 'knižn';
  $label_state = $api_type == 'webrs' ? 'Zverejnené na webe' : 'Zalomené';

  if (in_array($remote_node->workbench_moderation->current->state, [
    'zaradene',
    'publikovane_na_webe',
    'ilustracia_na_webe',
  ])) {
    $fields_to_skip = [
      'field_remote_id',
      'field_ilustracia',
      'field_zlucene_z',
      'field_zlucene_do',
      'field_text_hesla',
      'field_komentar_instrukcie',
      'field_datum_autorovho_textu',
    ];

    foreach ($remote_node as $field => $data) {
      $value = empty($data) ? '' : json_decode(json_encode($data), TRUE);

      if (($field == 'uid' || $field == 'title' || strpos($field, 'field_') === 0) && !in_array($field, $fields_to_skip)) {
        $node->{$field} = $value;
      }

      if ($field == 'field_text_hesla') {
        $matches = [];
        $imce_path = $api_type == 'webrs' ? 'rs' : 'webrs';

        preg_match_all('/<img.*?src=[\'"](.*?)[\'"].*?>/i', $value[LANGUAGE_NONE][0]['value'], $matches);

        if (!empty($matches)) {
          foreach ($matches[1] as $src) {
            $data = file_get_contents(variable_get('rs_api_uri') . $src);
            $new_src = str_replace($api_type, $imce_path, $src);
            $file = file_save_data($data, str_replace('/sites/' . $imce_path . '/files/', 'public://', $new_src), FILE_EXISTS_REPLACE);

            $value[LANGUAGE_NONE][0]['value'] = str_replace('src="' . $src, 'src="' . $new_src, $value[LANGUAGE_NONE][0]['value']);
            $value[LANGUAGE_NONE][0]['safe_value'] = str_replace('src="' . $src, 'src="' . $new_src, $value[LANGUAGE_NONE][0]['safe_value']);
          }
        }

        $node->field_text_hesla = $value;
      }

      if ($field == 'field_datum_autorovho_textu') {
        $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = '1970-01-01 00:00:00';
      }

      if ($field == 'field_komentar_instrukcie') {
        $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = 'Obsah prevzatý z ' . $label_type . 'ého RS. ';

        if (!empty($value)) {
          $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= $value[0]['value'];
        }
      }

      if (in_array($field, [
        'field_subor_ilustracie',
        'field_obrazok_navrh_',
        'field_original',
      ])) {
        $node->{$field}[LANGUAGE_NONE] = [];

        if (!empty($value)) {
          foreach ($value[LANGUAGE_NONE] as $key => $remote_file) {
            $data = file_get_contents(variable_get('rs_api_uri') . '/sites/' . variable_get('rs_api_type') . '/files' . str_replace('public:/', '', $remote_file['uri']));
            $file = file_save_data($data, $remote_file['uri'], FILE_EXISTS_REPLACE);

            $node->{$field}[LANGUAGE_NONE][$key] = [
              'fid' => $file->fid,
              'uid' => $file->uid,
              'filename' => $file->filename,
              'uri' => $file->uri,
              'filemime' => $file->filemime,
              'filesize' => $file->filesize,
              'status' => 1,
              'display' => 1,
              'description' => '',
            ];
          }
        }
      }

      if (in_array($field, [
        'field_ilustracia',
        'field_zlucene_z',
        'field_zlucene_do',
      ])) {
        $node->{$field}[LANGUAGE_NONE] = [];

        if (!empty($value)) {
          foreach ($value[LANGUAGE_NONE] as $delta => $ilustracia) {
            if ($target_remote_node = beliana_api_rest_get_node($ilustracia['target_id'])) {
              // do not sync ilusracia bundle when syncing from node
              //beliana_sync_from_remote_build(node_load($ilustracia['target_id']), $target_remote_node);
              $node->{$field}[LANGUAGE_NONE][$delta]['target_id'] = empty($target_remote_node->field_remote_id->und) ? $target_remote_node->nid : $target_remote_node->field_remote_id->und[0]->value;
            }
          }
        }
      }

    }

    $node->field_datum_prebratia = [LANGUAGE_NONE => [['value' => date('Y-m-d H:i:s')]]];
    $node->revision = 1;

    $workbench_moderation = 'needs_review';
    if ($node->type == 'ilustracia') {
      $workbench_moderation = 'ilustracia_u_redaktora';
    }
    elseif ($label_type == 'knižn') {
      $workbench_moderation = 'prevzate_z_rs';
    }

    $message_log = 'Obsah prevzatý z ' . $label_type . 'ého RS (' . date('Y-m-d') . ', ' . $user->name . ')';
    if (strpos($node->log, $message_log) === FALSE) {
      $node->log .= '. ' . $message_log;
    }

    workbench_moderation_moderate($node, $workbench_moderation);
    drupal_set_message(t('Obsah hesla @id bol úspešne prebratý', ['@id' => $remote_node->nid]));
  }
  else {
    drupal_set_message(t('Nepodarilo sa prevziať obsah hesla @id (heslo nie je v stave @state)', [
      '@id' => $remote_node->nid,
      '@state' => $label_state,
    ]), 'error');
  }
}

/**
 * Callback function for `update_dates` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function update_dates(&$entity, $context = []) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    // get dates from article text
    $dates = get_header_dates($entity->field_text_hesla[LANGUAGE_NONE][0]['value']);
    if (count($dates) > 0) {
      // unset date fields first
      for ($i = 2; $i >= 0; $i--) {
        if (isset($entity->field_datum[LANGUAGE_NONE][$i]['value'])) {
          unset($entity->field_datum[LANGUAGE_NONE][$i]['value']);
        }
      }
      for ($i = 0; $i < count($dates); $i++) {
        // set the field
        $entity->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
      }
      node_save($entity);
    }
  }
}

/*
  Check, if the node was sent to the needs_review state after 11.11.2018
  the node IS in the state needs_review (U redaktora) since only role Redaktor can edit the payment information
  find date (tstamp) of the latest of transitions na_zalomenie >> needs_review
  compare tstamp with the date 11.11.2018 (reftime) (on that day payment data was manuall exported)
  if tstamp > refdate return True (do not display payment fields). We have manually exported payment data
  if tstamp < refdate return False (edit payment fields). We do not have payment data
 */

function has_vr_to_r_transition(&$node) {

  // find transitions na_zverejnenie >> needs_review
  $reftime = strtotime("11-11-2018"); // date of manual accounting data export
  $transitions = db_select('workbench_moderation_node_history', 'w')
    ->fields('w') // all fields
    ->condition('from_state', 'na_zverejnenie') // u vyst. redaktor 1 state
    ->condition('state', 'needs_review')  // u redaktora state
    ->condition('nid', $node->nid)
    ->execute()
    ->fetchAll();
  // find the most recent transition
  $tstamp1 = 0;
  foreach ($transitions as $tr) {
    if ($tr->stamp > $tstamp1) { // find the most recent transition
      $tstamp1 = $tr->stamp;
    }
  }

  // find transitions u_vyst_redaktora_2 >> needs_review
  $transitions = db_select('workbench_moderation_node_history', 'w')
    ->fields('w') // all fields
    ->condition('from_state', 'u_vyst_redaktora_2')  // u redaktora state
    ->condition('state', 'needs_review')  // u vr1 state
    ->condition('nid', $node->nid)  // u vr1 state
    ->execute()
    ->fetchAll();
  // find the most recent transition
  $tstamp2 = 0;
  if (!empty($transitions)) {
    foreach ($transitions as $tr) {
      if ($tr->stamp > $tstamp2) { // find the most recent transition
        $tstamp2 = $tr->stamp;
      }
    }
  }
  $tstamp = max($tstamp1, $tstamp2);
  #dpm(date("m.d.Y",$tstamp), date("m.d.Y",$reftime));
  return $tstamp > $reftime;
}

// check if field related to payment should be displayed, and if, then how (editable, noneditable)
// return strings hideall enableall or showeditable
function _display_payment_fields_form(&$form) {
  return _display_payment_fields($form['#node']);
}

function _display_payment_fields(&$node) {
  #do not show the fields for new items
  if (!isset($node->nid)) {
    #dpm("hideall (nove heslo)", "display_payment_fields");
    return "hideall";
  }

  #do not show the fields for merged (zlucene) articles (i. e. field_zlucene_z is nonempty)
  if (isset($node->field_zlucene_z[LANGUAGE_NONE][0])) {
    #dpm("hideall (merged)", "display_payment_fields");
    return "hideall";
  }

  global $user;
  $curstate = $node->workbench_moderation['current']->state;
  //dpm($user);
  // administrator has access to everything
  //if (0 and !in_array("administrátor", $user->roles)) { // comment out in testing
  if (in_array("administrátor", $user->roles)) { // $form: node
    #dpm("enableall", "display_payment_fields");
    return "enableall";
  }

  // do not show in the case of nodes imported from files Kolembus-00* and Komunikator-00*
  if (
    (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Kolembus-00') !== FALSE)
    or (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Komunikator-00') !== FALSE)
  ) {
    #dpm("hideall (import)", "display_payment_fields");
    return "hideall";
  }

  // if filled out, field_datum_autorovho_textu is set.  Just show, do not edit
  if (isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'])) {
    #dpm("showdisabled (filled out)", "display_payment_fields, field_datum_autorovho_textu is set");
    return ("showdisabled");
  }
  //state of the node changed from vr1 or vr2 state to needs_review after 11.11.2018
  if (has_vr_to_r_transition($node)) {
    #dpm("hideall (has transition)", "display_payment_fields");
    return ("hideall");
  }
  if ($curstate === 'needs_review') {
    #dpm("showeditable (no transition, needs_review)", "display_payment_fields");
    return ("showeditable");
  }
  else {
    #dpm("hideall (no transition, no needs_review)", "display_payment_fields");
    return ("hideall");
  }
}

/**
 * Find the first transition needs_review -> na_zverejnenie and return text length
 *
 */
function _get_authors_text_length(&$node) {
  if ($node->type != 'heslo') {
    return NULL;
  }

  // get the array of transitions needs_review -> na_zverejnenie (U redaktora -> U VR1)
  $transitions = db_select('workbench_moderation_node_history', 'w')
    ->fields('w') // all fields
    ->condition('from_state', 'needs_review')  // u redaktora state
    ->condition('state', 'na_zverejnenie')  // u vr1 state
    ->condition('nid', $node->nid)  // u vr1 state
    ->execute()
    ->fetchAll();
  if (empty($transitions)) {
    return NULL;
  }
  // get vid of the oldest transition
  $tstamp = $transitions[0]->stamp;
  $vid = $transitions[0]->vid;
  foreach ($transitions as $tr) {
    if ($tr->stamp < $tstamp) {
      $tstamp = $tr->stamp;
      $vid = $tr->vid;
    }
  }

  // load the $vid revision
  $revision = entity_revision_load('node', $vid);
  // remove tags and clean the text
  $text = strip_tags(str_replace('<', ' <', $revision->field_text_hesla[LANGUAGE_NONE][0]['value']));
  $text = preg_replace('/\n|\r|\t/m', ' ', $text);
  $text = str_replace('&nbsp;', ' ', $text);
  $text = str_replace("\xc2\xa0", ' ', $text);
  $text = trim(preg_replace('/\s\s+/', ' ', $text));
  $tlen = drupal_strlen($text);

  return $tlen;
}

/**
 * Callback function for `check_path_attributes` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function check_path_attributes(&$entity, $context = []) {
  if ($entity->type == 'heslo' || $entity->type == 'importovane_heslo') {
    $alias = drupal_get_path_alias('node/' . $entity->nid);

    if (strpos($alias, '_') === FALSE) {
      $entity->field_atributy = [LANGUAGE_NONE => [['value' => 'odkazOK']]];
      node_save($entity);
    }
  }
}

/**
 * Callback function for `prune_node_revisions` action.
 * Delete repeated revisions by the same editor, keeps the oldest and the
 * newest revision
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function prune_node_revisions(&$node, $context = []) {
  if (!in_array($node->type, ['heslo', 'importovane_heslo', 'ilustracia'])) {
    return;
  }
  // get (sorted) list of revisions
  $revisions = node_revision_list($node);
  $cur_editor_name = array_values($revisions)[0]->name;
  foreach (array_slice($revisions, 1, -1) as $revision) {
    if ($revision->name == $cur_editor_name) {
      node_revision_delete($revision->vid);
    }
    else {
      $cur_editor_name = $revision->name;
    }
  }
}

/**
 * Callback function for `reset_importovane_and_link_transfer` action.
 * 1. Transfer links from the actual version to the oldest one or
 *    the revision edited by iredaktor_jch or iredaktor_mb (they edited math
 * equations and tables)
 * 2. Set text of the this revision as the actual text
 * 3. Remove illustrations in tha actual version
 * 4. Remove all revisions except for the actual, the revision edited by
 * iredaktor_jch or iredaktor_mb and the oldest one
 */
function reset_importovane_and_link_transfer(&$node, $context = []) {
  if (!in_array($node->type, ['importovane_heslo'])) {
    return;
  }
  // get (sorted) list of revisions
  $revisions = node_revision_list($node);
  // find the first revision edited by iredaktor_jch or iredaktor_mb
  $extra_rev = 0; // revision with corrected mathematics to take
  foreach ($revisions as $revision) {
    if ($revision->name == "iredaktor_jch" or $revision->name == "iredaktor_mb") {
      $extra_rev = $revision->vid;
      break;
    }
  }
  $first_rev = ($extra_rev) ? entity_revision_load('node', $extra_rev) : entity_revision_load('node', end($revisions)->vid);
  //dpm($first_rev);

  // clean some stuff
  $rslt = transfer_links($first_rev->field_text_hesla['und'][0]['value'], $node->field_text_hesla['und'][0]['value']);
  $node->field_text_hesla['und'][0]['value'] = str_replace("➔", "—&gt; ", $rslt[0]);
  // add text to comment, so that a user knows
  $komentar = "Knižný text s doplnenými odkazmi. \n" . $rslt[1];
  $node->field_komentar_instrukcie['und'][0]['value'] = $komentar;
  $node->revision = TRUE;
  $node->log = "Reset and link transfer";
  if (isset($node->field_ilustracia['und'])) {
    unset($node->field_ilustracia['und']);
  }
  node_save($node);

  #delete all revisions except:
  #the two most recent and the oldest (imported) one
  #the first revision edited by iredaktor_jch or iredaktor_mb
  $revisions = node_revision_list($node);
  $skip_math = TRUE;
  foreach (array_slice($revisions, 2, -1) as $revision) {
    if ($skip_math and ($revision->name == "iredaktor_jch" or $revision->name == "iredaktor_mb")) {
      $skip_math = FALSE;
      continue;
    }
    node_revision_delete($revision->vid);
  }
}

/**
 * Callback function for `reset_vyradene_ilustracie` action.
 * Delete moderation history and remove attached files
 */
function reset_vyradene_ilustracie(&$node, $context = []) {
  if (!in_array($node->type, ['ilustracia'])) {
    return;
  }
  if ($node->workbench_moderation['current']->state != "vyradene") {
    return;
  }
  // list of files to be removed
  $remove_fids=array();

  // get (sorted) list of revisions
  $revisions = node_revision_list($node);
  #delete all revisions except the most recent, add fids to $remove_fids
  foreach (array_slice($revisions, 1) as $rev) {
    $revision = node_load($node->nid,$rev->vid);
    while ( $revision->field_obrazok_navrh_[LANGUAGE_NONE] ){
      $last = array_pop($revision->field_obrazok_navrh_[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
    while ( $revision->field_subor_ilustracie[LANGUAGE_NONE] ){
      $last = array_pop($revision->field_subor_ilustracie[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
    while ( $revision->field_original[LANGUAGE_NONE] ){
      $last = array_pop($revision->field_original[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
    node_revision_delete($rev->vid);
  }

  // clean individual fields of the remaining revision
  if (isset($node->field_obrazok_navrh_[LANGUAGE_NONE])) {
    while ( $node->field_obrazok_navrh_[LANGUAGE_NONE] ){
      $last = array_pop($node->field_obrazok_navrh_[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
  }
  if (isset($node->field_pouzit[LANGUAGE_NONE][0])) {
    unset($node->field_pouzit[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0])) {
    unset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_zdroj_ilustracie[LANGUAGE_NONE][0])) {
    unset($node->field_zdroj_ilustracie[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_licencia1[LANGUAGE_NONE][0])) {
    unset($node->field_licencia1[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_modifikovane[LANGUAGE_NONE][0])) {
    unset($node->field_modifikovane[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_meno_autora_diela[LANGUAGE_NONE][0])) {
    unset($node->field_meno_autora_diela[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_nazov_diela[LANGUAGE_NONE][0])) {
    unset($node->field_nazov_diela[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_institucia[LANGUAGE_NONE][0])) {
    unset($node->field_institucia[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_drzitel_prav[LANGUAGE_NONE][0])) {
    unset($node->field_drzitel_prav[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_subor_ilustracie[LANGUAGE_NONE][0])) {
    while ( $node->field_subor_ilustracie[LANGUAGE_NONE] ){
      $last = array_pop($node->field_subor_ilustracie[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
  }
  if (isset($node->field_datum_zverejnenia[LANGUAGE_NONE][0])) {
    unset($node->field_datum_zverejnenia[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_url_autora_diela[LANGUAGE_NONE][0])) {
    unset($node->field_url_autora_diela[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_url_diela[LANGUAGE_NONE][0])) {
    unset($node->field_url_diela[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_meno_autora_snimky_diela[LANGUAGE_NONE][0])) {
    unset($node->field_meno_autora_snimky_diela[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_obrazok_odkaz[LANGUAGE_NONE][0])) {
    unset($node->field_obrazok_odkaz[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_alternativny_text[LANGUAGE_NONE][0])) {
    unset($node->field_alternativny_text[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_popis_modifikacie[LANGUAGE_NONE][0])) {
    unset($node->field_popis_modifikacie[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_original[LANGUAGE_NONE][0])) {
    while ( $node->field_original[LANGUAGE_NONE] ){
      $last = array_pop($node->field_original[LANGUAGE_NONE]);
      $remove_fids[] = $last['fid'];
    }
  }
  if (isset($node->field_datum_prebratia[LANGUAGE_NONE][0])) {
    unset($node->field_datum_prebratia[LANGUAGE_NONE][0]);
  }
  if (isset($node->field_instrukcie_pre_typografa[LANGUAGE_NONE][0])) {
    unset($node->field_instrukcie_pre_typografa[LANGUAGE_NONE][0]);
  }
  node_save($node);

  // remove the files
  foreach (array_unique($remove_fids) as $fid) {
    $file = file_load($fid);
    if ($file) {
      //drupal_set_message('V ilustracii <a href="/' . $node->path['alias'] . '">' . $node->title . '</a> zmazaný súbor '.$file->uri.' ('.$fid.')');
      file_delete($file, TRUE);
    } else { // some files were probably deleter earlier
      //drupal_set_message('V ilustracii <a href="/' . $node->path['alias'] . '">' . $node->title . '</a> zlyhalo mazanie súboru ('.$fid.')');
    }
  }
}

/**
 * Callback function for `reset_heslo_webrs` action.
 * To be called only once after splitting the editiorial system in web a print
 * system Sets state of Heslo articles to Zaradene, Zlucene of Ukoncene/Zlucene
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function reset_heslo_webrs(&$node, $context = []) {
  if (!in_array($node->type, ['heslo'])) {
    return;
  }
  if (!in_array($node->workbench_moderation['current']->state,
    [
      "u_autora",
      "needs_review",
      "na_zverejnenie",
      "u_vyst_redaktora_2",
      "u_vyst_redaktora_2x",
      "u_vyst_redaktora_3",
      "u_vyst_redaktora_4",
      "u_v_st_redaktora_5",
      "1_korektura",
      "2_korekt_ra",
      "u_konzultanta",
      "u_jaz_redaktora_2",
      "na_jazykovu_korekturu",
      "ukoncenezluene",
    ])) {
    return;
  }

  $node->revision = TRUE;
  if (isset($node->field_zlucene_z['und'])) {
    $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] =
      "Verzia zlúčeného hesla v čase oddelenia redakčných systémov. Pôvodný stav: " .
      workbench_moderation_state_label($node->workbench_moderation['current']->state) . ", nový stav: " .
      workbench_moderation_state_label("zlucene") . ".";
    workbench_moderation_moderate($node, "zlucene");
  }
  elseif ($node->workbench_moderation['current']->state == 'ukoncenezluene') {
    $user = user_load($node->uid);
    $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] =
      "Verzia hesla v čase oddelenia redakčných systémov. Pôvodný stav: " .
      workbench_moderation_state_label("ukoncenezluene") . ", nový stav: " .
      workbench_moderation_state_label("ukoncenezluene") . "." . PHP_EOL .
      "Autor knižného textu: " . $user->name;
  }
  else {
    $user = user_load($node->uid);
    $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] =
      "Verzia hesla v čase oddelenia redakčných systémov. Pôvodný stav: " .
      workbench_moderation_state_label($node->workbench_moderation['current']->state) . ", nový stav: " .
      workbench_moderation_state_label("zaradene") . "." . PHP_EOL .
      "Autor knižného textu: " . $user->name;
    workbench_moderation_moderate($node, "zaradene");
  }
  $node->log = "Verzia po oddelení redakčných systémov";
  $node->uid = '719'; // 719 == nepriradeny
  node_save($node);
  // get (sorted) list of revisions
  $revisions = node_revision_list($node);
  #dpm($revisions);
  foreach (array_slice($revisions, 1, -1) as $revision) {
    node_revision_delete($revision->vid);
  }
}


//Compare strings with characters č, ch, š and ž using the strcmp function according to rules of the Slovak language
//strcoll does not work, because we need correct sorting of the _ character (ignored in strcoll)
//The idea: replace these characters by placeholders
function sk_cmp($a, $b)
{
	$a=str_replace("č","czz",$a);
	$a=str_replace("š","szz",$a);
	$a=str_replace("ž","zzz",$a);
	$a=str_replace("ch","hzz",$a);

	$b=str_replace("č","czz",$b);
	$b=str_replace("š","szz",$b);
	$b=str_replace("ž","zzz",$b);
	$b=str_replace("ch","hzz",$b);

	return strcmp($a,$b);
}

/**
 * Implements hook_node_presave().
 *
 * @inheritdoc
 */
function beliana_node_presave($node) {
  # do not execute in the case of workbench moderation state transitions
  # execute only on node saving
  # on node creation $node->workbench_moderation does not exist
  if (isset($node->workbench_moderation_state_new) and
    isset($node->workbench_moderation) and
    $node->workbench_moderation['current']->state != $node->workbench_moderation_state_new) {
    return;
  }
  // set field_na_zoradenie if empty or fix it if necessary
  $rebuild_sort = !isset($node->field_na_zoradenie['und'][0]['value']);
  if (!$rebuild_sort) {
    // are there funny characters in sort string (field_na_zoradenie)?
    $rebuild_sort = preg_match('/[^a-zA-ZŠšČčŽž_0-9]/', $node->field_na_zoradenie['und'][0]['value']);
    //is there comma in title by not '_' in sort string (field_na_zoradenie)? - fixes missing '_' between surname and name
    $rebuild_sort = $rebuild_sort ||
      (strpos($node->title, ",") and // comma in title
        !strpos($node->field_na_zoradenie['und'][0]['value'], "_") and // no "_" in sort string
        !preg_match("/^[0-9]/", $node->title) and // not starting with number (in chemistry, like 1,3-butadien)
        $node->type == 'importovane_heslo' // only 'importovane_heslo' 'heslo' is sorted in a different way
      );
  }
  if ($rebuild_sort) {
    $transliterated = preg_replace("/\(^ad-|al-|af |d’ |d’|de |da |z |ze |del |\)./", '', $node->title);
    $transliterated = _beliana_remove_accents($transliterated);
    $transliterated = str_replace(",", "_", $transliterated);
    $transliterated = preg_replace('/[^a-zA-ZŠšČčŽž_0-9]/', '', $transliterated);
    $transliterated = strtolower($transliterated);
    $transliterated = str_replace("Š", "š", $transliterated); // not changed by strtolower
    $transliterated = str_replace("Č", "č", $transliterated);
    $transliterated = str_replace("Ž", "ž", $transliterated);
    $node->field_na_zoradenie['und'][0]['value'] = substr($transliterated, 0, 50);
  }

  // set field_taxsubor using the value of field_na_zoradenie
  $vocabulary = taxonomy_vocabulary_machine_name_load('subory');
  //$subory = taxonomy_term_load_multiple(array(), array('vid' => $vocabulary->vid)); //default sort instead of Slovak
  $subory = taxonomy_get_tree($vocabulary->vid);
  foreach ($subory as $term) {
    // ignore items starting with digit, such as '1. subor'
    if (!ctype_digit(substr($term->name, 0, 1)) && sk_cmp($term->name, $node->field_na_zoradenie['und'][0]['value']) >= 0) {
      $node->field_taxsubor['und'][0]['tid'] = $term->tid;
      break;
    }
  }

  # do not continue if node has just been created
  if (isset($node->is_new) and $node->is_new === TRUE) {
    return;
  }

  // clean tags and remove unnecessary field values in type 'ilustracie'
  if ($node->type != "heslo" && $node->type != 'importovane_heslo') {
    if ($node->type == "ilustracia") {
      $html = beliana_clean_tags($node, $node->field_popis[LANGUAGE_NONE][0]['value'], "Popis ilustracie (beliana_node_presave)");
      $node->field_popis[LANGUAGE_NONE][0]['value'] = $html;
      // remove inappropriate setting of field_licencia1 if licence type is not 'CC licencia' (possible in the form)
      if (isset($node->field_zdroj_ilustracie[LANGUAGE_NONE][0]) and $node->field_zdroj_ilustracie[LANGUAGE_NONE][0]['value'] !== 'CC licencia') {
        if (isset($node->field_licencia1[LANGUAGE_NONE][0])) {
          #dpm("Odstránená nepotrebná hodnota v field_licencia1 (typ CC licencie)");
          unset($node->field_licencia1[LANGUAGE_NONE][0]);
        }
        if (isset($node->field_modifikovane[LANGUAGE_NONE][0])) {
          #dpm("Odstránená nepotrebná hodnota v field_modifikovane");
          unset($node->field_modifikovane[LANGUAGE_NONE][0]);
        }
      }
      if (isset($node->field_modifikovane[LANGUAGE_NONE][0]) and $node->field_modifikovane[LANGUAGE_NONE][0]['value'] !== '1') {
        if (isset($node->field_popis_modifikacie[LANGUAGE_NONE][0])) {
          #dpm("Odstránený nepotrebný text v field_popis_modifikacie (1)");
          unset($node->field_popis_modifikacie[LANGUAGE_NONE][0]);
        }
      }
      if (!isset($node->field_modifikovane[LANGUAGE_NONE][0]) and isset($node->field_popis_modifikacie[LANGUAGE_NONE][0])) {
        #dpm("Odstránený nepotrebný text v field_popis_modifikacie (2)");
        unset($node->field_popis_modifikacie[LANGUAGE_NONE][0]);
      }
    }
    return;
  }

  // update field_datum according to the text
  $dates = get_header_dates($node->field_text_hesla[LANGUAGE_NONE][0]['value']);
  if (count($dates) > 0) {
    // unset date fields first
    for ($i = 2; $i >= 0; $i--) {
      if (isset($node->field_datum[LANGUAGE_NONE][$i]['value'])) {
        unset($node->field_datum[LANGUAGE_NONE][$i]['value']);
      }
    }
    for ($i = 0; $i < count($dates); $i++) {
      $node->field_datum[LANGUAGE_NONE][$i]['value'] = $dates[$i];
    }
  }

  // modify links due to article merging
  modify_links_merged($node);

  // remove unnecessary tags
  $html = beliana_clean_tags($node, $node->field_text_hesla[LANGUAGE_NONE][0]['value'], "Text hesla (beliana_node_presave)");
  $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = $html;
  if (isset($node->field_table[LANGUAGE_NONE][0])) {
    $html = beliana_clean_tags($node, $node->field_table[LANGUAGE_NONE][0]['value'], "Tabuľka pre geografické heslá");
    $node->field_table[LANGUAGE_NONE][0]['value'] = $html;
  }

  // store information about the author's text length (used for payments)
  // first, unset field_dlzka_autorovho_textu_zad if field_vyplatit is not Vyplatiť
  // (setting it makes no sense, but is possible in the form)
  if (isset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]) and
    $node->field_vyplatit[LANGUAGE_NONE][0]['value'] !== "Vyplatiť") {
    #dpm("Odstránená nepotrebná hodnota v field_dlzka_autorovho_textu_zad");
    unset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]);
  }
  // Compute the lenght if value 0 was entered in field field_dlzka_autorovho_textu_zad.
  if (isset($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]) and (!isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value']) or
      $node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] == 0)) {
    // set the date (if set,  field field_dlzka_autorovho_textu_zad will never be changed again)
    $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = date("Y/m/d");
    // if  field_dlzka_autorovho_textu_zad is set to 0, fill the value automatically
    if ($node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] == 0) {
      $text = strip_tags(str_replace('<', ' <', $node->field_text_hesla[LANGUAGE_NONE][0]['value']));
      $text = preg_replace('/\n|\r|\t/m', ' ', $text);
      $text = str_replace('&nbsp;', ' ', $text);
      $text = str_replace("\xc2\xa0", ' ', $text);
      $text = trim(preg_replace('/\s\s+/', ' ', $text));
      $tlen = drupal_strlen($text);
      $node->field_dlzka_autorovho_textu_zad[LANGUAGE_NONE][0]['value'] = $tlen;
      #log this event
      $node->log = $node->log . ", automaticky určená dĺžka autorovho textu";
    }
    else { # log if a value was entered manually
      $node->log = $node->log . ", ručne vložená dĺžka autorovho textu";
    }
  }
  // save date when the author's text information was saved. Used for monthly records
  if (isset($node->field_vyplatit[LANGUAGE_NONE][0]) and !isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'])) {
    $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = date("Y/m/d");
    $node->log = $node->log . ", vyplnené pole Vyplatiť";
  }

  // store the proofreader state in which an item was edited in the field_atributy field
  // to be used to send items always to the same proofreader
  if (variable_get('rs_api_type') != "webrs" && in_array($node->workbench_moderation_state_current,
	  ['importovane_jaz_kontrola', 'importovane_u_jaz_korektora',
	   // "U jaz. redaktora", :U jaz. korektora"
	   'na_jazykovu_korekturu','u_jaz_korektora'])) {
    if (!isset($node->field_atributy[LANGUAGE_NONE]) or
       (strpos($node->field_atributy[LANGUAGE_NONE][0]['value'], $node->workbench_moderation_state_current) === FALSE)) {
         $node->field_atributy[LANGUAGE_NONE][0]['value'] = "Heslo bolo v stave '".$node->workbench_moderation_state_current."'";
    }
  }

  # remove links from text of artices in states 'vyradene' and 'ukoncenezluene'
  if (in_array($node->workbench_moderation_state_current, ['vyradene', 'ukoncenezluene'])) {
    _beliana_remove_links($node);
  }
  #update the link table (updated only in the beliana-webrs module)
  _beliana_process_links($node);
}

/**
  remove links from the node text
 */
function _beliana_remove_links($node) {
  $text = $node->field_text_hesla['und'][0]['value'];
  $text = preg_replace("/<a[^>]*>/", " ", $text);
  $node->field_text_hesla['und'][0]['value'] = str_replace("</a>", "", $text);
}

/**
 * Implements hook_views_post_execute().
 */
function beliana_views_post_execute(&$view) {
  $affected_views = [
    'sync_to_web' => 'node_workbench_moderation_node_history_nid',
    'vsetky_hesla_detaily' => 'nid',
    'export_na_import' => 'nid',
  ];

  if (in_array($view->name, array_keys($affected_views))) {
    $old_count = count($view->result);
    $unique_nids = [];
    $new_results = [];

    // Loop through results and filter out duplicate results.
    foreach ($view->result as $index => $result) {
      $nid = $result->{$affected_views[$view->name]};

      if (!in_array($nid, $unique_nids)) {
        $unique_nids[] = $nid;
        $new_results[] = $result;
      }
    }

    $view->result = $new_results;
    $new_count = count($new_results);

    if ($old_count > $new_count && $view->query->pager->total_items < 50) {
      $view->total_rows = $new_count;
      $view->query->pager->total_items = $new_count;
      $view->query->pager->update_page_info();
    }
  }
}

// migrate features specific to ckeditor4, lite and others to ckeditor5
function migrate_to_cke5($in_text) {
  // just remove lite tracking
  $text = preg_replace('|<ins[^>]*>|', '', $in_text);
  $text = preg_replace('|</ins>|', '', $text);
  $text = preg_replace('|<del[^>]*>.*</del>|U', '', $text);	//U: ungreedy
  // remove links with no text - lite leaves these when marking text for deleting, looks like a bug
  $text = preg_replace('|<a[^>]*></a>|',"",$text);
  $text = str_replace('﻿', '', $text);
  $text = str_replace("  "," ", $text);

  return $text;
}

/**
 * Implements hook_form_alter().
 *
 * @inheritdoc
 */
function beliana_form_alter(&$form, &$form_state, $form_id) {
  // log information about opening nodes for editing
  // if $form['title']['#default_value'] is empty (node just ceated), do not log anything
  $nf_pos = strpos($form_id, "_node_form");
  if (!($nf_pos === FALSE) && isset($form['title']['#default_value'])) {
    watchdog('content', '@type: otvorené na úpravu @title. (open, ' . date("Y/m/d H:i:s") . ')', [
      '@type' => substr($form_id, 0, $nf_pos),
      '@title' => $form['title']['#default_value'],
    ], WATCHDOG_NOTICE);
  }


  global $user;
  // migrate stuff from GKEditor 4 to CKEditor5
  if( in_array($form_id, ["heslo_node_form", "importovane_heslo_node_form", "ilustracia_node_form"])) {
    // only in 'heslo' and 'importovane_heslo'
    if (isset($form['field_text_hesla'][LANGUAGE_NONE][0]['#default_value'])) {
       $form['field_text_hesla'][LANGUAGE_NONE][0]['#default_value'] = migrate_to_cke5($form['field_text_hesla'][LANGUAGE_NONE][0]['#default_value']);
    }
    // only in 'heslo' and 'importovane_heslo'
    if (isset($form['field_table'][LANGUAGE_NONE][0]['#default_value'])) {
       $form['field_table'][LANGUAGE_NONE][0]['#default_value'] = migrate_to_cke5($form['field_table'][LANGUAGE_NONE][0]['#default_value']);
    }
    // only in 'ilustracia'
    if (isset($form['field_popis'][LANGUAGE_NONE][0]['#default_value'])) {
       $form['field_popis'][LANGUAGE_NONE][0]['#default_value'] = migrate_to_cke5($form['field_popis'][LANGUAGE_NONE][0]['#default_value']);
    }
  }


  // disable but show fields related to author's text, if already set
  if ($form_id == "heslo_node_form" or $form_id == "importovane_heslo_node_form" ) {
    $display_payment = _display_payment_fields_form($form);
    //hideall, enableall, showdisabled, showeditable
    if ($display_payment == "enableall") {
      // no action necessary
    }
    elseif ($display_payment == "hideall") {
      if (isset($form['field_vyplatit'])) {
        $form['field_vyplatit']['#access'] = FALSE;
      }
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
      if (isset($form['field_dlzka_autorovho_textu_zad'])) {
        $form['field_dlzka_autorovho_textu_zad']['#access'] = FALSE;
      }
    }
    elseif ($display_payment == "showdisabled") {
      if (isset($form['field_vyplatit'])) {
        $form['field_vyplatit']['#disabled'] = TRUE;
      }
      if (isset($form['field_dlzka_autorovho_textu_zad'])) {
        $form['field_dlzka_autorovho_textu_zad']['#disabled'] = TRUE;
      }
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
    }
    elseif ($display_payment == "showeditable") {
      if (isset($form['field_datum_autorovho_textu'])) {
        $form['field_datum_autorovho_textu']['#access'] = FALSE;
      }
    }
  }

  //'workbench_moderation_moderate_form': the form displaying a node 'view' or similar
  //$form['node']['#value'] is not set if user cannot modify a node
  // transition to states 'author' and 'needs_review' from stete 'zaradene' is implemented in a dedicated view, so remove it here
  if (isset($form['node']['#value']) && $form_id === 'workbench_moderation_moderate_form') {
    if ($form['node']['#value']->workbench_moderation['current']->state === 'zaradene' && in_array("Redaktor", $user->roles)) {
      foreach ($form['state']['#options'] as $k => $v) {
        if (in_array($k, ['needs_review', 'u_autora'])) {
          unset($form['state']['#options'][$k]);
        }
      }
    }

    // remove some states from the list of transitions in the case of role Redaktor (webrs only)
    //rs_api_type specifies type of the opposite side, therefore '!='  in the test
    if (variable_get('rs_api_type') != "webrs" && in_array("Redaktor", $user->roles) ) {
      // transition to 'konzultant' is implemented in a dedicated view, so remove them here
      if (in_array($form['node']['#value']->workbench_moderation['current']->state, array('needs_review'))) {
        foreach ($form['state']['#options'] as $k => $v) {
          if (in_array($k, array('u_konzultanta'))) {
            unset($form['state']['#options'][$k]);
          }
        }
      }
      // articles of type 'importovane heslo' cannot be sent to an author
      /* change in workflow: even importovane_heslo can have an author now, so comment the following out
      if ($form['node']['#value']->type === 'importovane_heslo') {
        foreach ($form['state']['#options'] as $k => $v) {
          if (in_array($k, array('u_autora'))) {
            unset($form['state']['#options'][$k]);
          }
        }
      }
      */
    }

    // allow to return an item only to the proofreader who has already edited it
    // influences also admin, so that he does not mess things up
    $node = $form['node']['#value'];
    if (variable_get('rs_api_type') != "webrs" && isset($node->field_atributy[LANGUAGE_NONE])) {
      if (strpos($node->field_atributy[LANGUAGE_NONE][0]['value'], 'na_jazykovu_korekturu') !== FALSE) {
          unset($form['state']['#options']['u_jaz_korektora']);
      }
      if (strpos($node->field_atributy[LANGUAGE_NONE][0]['value'], 'u_jaz_korektora') !== FALSE) {
          unset($form['state']['#options']['na_jazykovu_korekturu']);
      }
      if (strpos($node->field_atributy[LANGUAGE_NONE][0]['value'], 'importovane_jaz_kontrola') !== FALSE) {
          unset($form['state']['#options']['importovane_u_jaz_korektora']);
      }
      if (strpos($node->field_atributy[LANGUAGE_NONE][0]['value'], 'importovane_u_jaz_korektora') !== FALSE) {
          unset($form['state']['#options']['importovane_jaz_kontrola']);
      }
    }

    // Add custom submit handler, distinguish between rs/webrs here
    if (variable_get('rs_api_type') == "webrs") { 	//rs_api_type specifies type of the opposite side
    	$form['#submit'][] = 'rs_beliana_workflow_reaction';
    } else {
    	$form['#submit'][] = 'webrs_beliana_workflow_reaction';
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * @inheritdoc
 */
function beliana_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  $form['#attached']['js'][] = drupal_get_path('module', 'beliana') . '/js/editor.js';
  drupal_add_js([
    'beliana' => [
      'current_user' => [
        'id' => $user->uid,
        'name' => $user->name,
      ],
    ],
  ], ['type' => 'setting']);
}

function _check_ilu_attached(&$ilu_node, $category) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', "node")
    ->fieldCondition('field_ilustracia', 'target_id', $ilu_node->nid, "=");
  $result = $query->execute();
  if (isset($result['node'])) {
    return TRUE;
  }
  else {
    il_error($ilu_node, $ilu_node, 'nie je priradená k žiadnemu heslu', $category);
    return FALSE;
  }
}

/*
 * $ok_states: list of required illustration states
 * return true if OK
 */

function check_ill_at_node_transition(&$node, $ok_states, $category) {
  $skip = FALSE;
  if (isset($node->field_ilustracia[LANGUAGE_NONE])) {
    foreach ($node->field_ilustracia[LANGUAGE_NONE] as $illustration) {
      $ilu_generic_node = node_load($illustration['target_id']);
      $ilu_node = workbench_moderation_node_current_load($ilu_generic_node);

      //if (!_check_field_pouzit($node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // check illustrations, which are intended for web
      if (il_display_on_web($ilu_node)) {
        $illustration_data = _check_illustration_web($node, $ilu_node, 'state change');
        if (is_null($illustration_data)) {
          $skip = TRUE;
        }

        // Check if illustration is in correct WB status.
        if (!in_array($ilu_node->workbench_moderation['current']->state, $ok_states)) {
          il_error($node, $ilu_node, 'má byť zverejnená na webe, ale nie je v žiadnom z požadovaných stavov: [' . implode(", ", $ok_states) . ']', 'state change');
          $skip = TRUE;
        }
      }
    }
  }
  return !$skip;
}

/**
 * check validity of used alternative text markers
 * correct marked text:  ▶[KkWw][^▶]*◀
 *
 * @param $nid
 */
function _check_alternative_text_markers(&$node, $text, $where) {
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  // do not check validity if LITE changes are stored
  if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
    return TRUE;
  }
  $retvalue = TRUE;
  $hlink = 'Chybný alternatívny text ' . $where . ' <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: ';
  $pattern = "/(*UTF8)(▶[^◀]*▶)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'opakovaný začiatok (... ▶ ... ▶ ...)', 'error');
    $retvalue = FALSE;
  }
  $pattern = "/(*UTF8)(◀[^▶]*◀)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'opakované ukončenie (... ◀ ... ◀ ...)', 'error');
    $retvalue = FALSE;
  }
  $pattern = "/(*UTF8)(▶[^kKwW])/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'použité "' . $matches[0][0] . '" namiesto "▶K" alebo "▶W"', 'error');
    $retvalue = FALSE;
  }
  $pattern = "/(*UTF8)(▶[^◀]*$)/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'chýba ukončenie ◀', 'error');
    $retvalue = FALSE;
  }
  $pattern = "/(*UTF8)^[^▶]*◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'chýba začiatok "▶K" alebo "▶W"', 'error');
    $retvalue = FALSE;
  }
  $pattern = "/(*UTF8) ◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    drupal_set_message($hlink . 'pred znakom ◀ nesmie byť medzera', 'error');
    $retvalue = FALSE;
  }
  // check correctness of tags inside the alternatives
  // catches only closing tags
  $pattern = "/(*UTF8)▶[^◀▶]*◀/";
  if (preg_match_all($pattern, $text, $matches)) {
    foreach ($matches[0] as $match) {
      $dom = beliana_get_dom($node, $match);
      preg_match_all("/(*UTF8)(<[^\/])/", $match, $matchesopen);
      preg_match_all("/(*UTF8)(<\/)/", $match, $matchesclose);
      if (!$dom or count($matchesopen[0]) != count($matchesclose[0])) {
        $match = str_replace("<", "&lt;", $match);
        $match = str_replace(">", "&gt;", $match);
        drupal_set_message($hlink . 'formátovanie presahuje hranice alternatívneho textu: "' . $match . '"', 'error');
        $retvalue = FALSE;
      }
    }
  }
  return $retvalue;
}

/**
 * if article state should be changed to 'vyradene' (rejected), the must be no
 * articles referencing to it
 *
 * @param $nid
 */
function _check_transition_to_vyradene(&$node) {
  // get nodes linking to $node
  $query = db_query('SELECT node.nid AS nid FROM {node} node INNER JOIN {search_node_links} links ON node.nid = links.sid WHERE links.nid = :nid', [':nid' => $node->nid]);
  $result = $query->fetchAll();
  if ($result) {
    drupal_set_message('Heslo <a href="/' . $node->path['alias'] . '">' . $node->title . '</a> ' . 'nebolo presunuté do stavu Vyradené, lebo naň odkazujú iné heslá.', 'error');
    return FALSE;
  }
  return TRUE;
}

/**
 * Extract links from node and check their validity
 *
 * @param $nid
 *
 * @return true if OK or to be ignored
 */
function _check_links(&$node) {
  // do not check if $node is in the publikovane_na_webe state
  if ($node->workbench_moderation['current']->state === 'publikovane_na_webe') {
    return TRUE;
  }
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  $text = $node->field_text_hesla['und'][0]['value'];
  $retvalue = TRUE;
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = 0; $i < $links->length; $i++) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      // no external lins allowed
      if (url_is_external($target)) {
        drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
        $retvalue = FALSE;
      }
      else {
        if (preg_match('?^/heslo/[^/]*?', $target)) {
          // form OK, check if it exists
          // Get non-alias path, so we can get nid from it.
          $path = drupal_get_normal_path(substr($target, 1));
          $parts = explode("/", $path);
          if ($parts[0] !== 'node') {
            drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkazované heslo neexistuje)', 'error');
            $retvalue = FALSE;
          }
          else {
            $generic_node = node_load($parts[1]);
            $auxnode = workbench_moderation_node_current_load($generic_node);
            // linked article must be a normal one, not a pure reference article (i.e. must contain the "—" character)
            if (strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "—") === FALSE and
              strpos($auxnode->field_text_hesla[LANGUAGE_NONE][0]['value'], "➔") !== FALSE) {
              drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkaz na odkazové alebo nesprávne formátované heslo (chýba "—" )', 'error');
              $retvalue = FALSE;
              // linked article must not be in 'vyradene' state
            }
            elseif ($auxnode->workbench_moderation['current']->state === 'vyradene') {
              drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '" (odkaz na vyradené heslo)', 'error');
              $retvalue = FALSE;
            }
          }
        }
        else {
          // not in the form '/heslo/alias'
          drupal_set_message('Chybný odkaz v hesle <a href="/' . $node->path['alias'] . '">' . $node->title . '</a>: "' . $item->nodeValue . '"', 'error');
          $retvalue = FALSE;
        }
      }
    }
  }
  return $retvalue;
}

/**
 * Helper function to get user autocomplete form.
 *
 * @return array
 *   Array with form element.
 */
function _beliana_assign_user_form($msg) {
  $form = [];
  $form['user'] = [
    '#type' => 'textfield',
    '#title' => t($msg),
    '#required' => TRUE,
    '#autocomplete_path' => 'user/autocomplete',
  ];
  return $form;
}

/**
 * Helper function for user autocomplete form validation.
 *
 * @param array $form_state
 *   Array with form values.
 */
function _beliana_validate_assign_user_form(&$form_state, $role) {
  $user = user_load_by_name($form_state['values']['user']);
  if ($user === FALSE) {
    form_set_error('user', t('You need to choose existing user'));
  }
  if (empty(array_intersect($role, $user->roles))) {
    form_set_error('user', t('Specified user needs role: ' . implode(", ", $role)));
  }
}

/**
 * Helper function for processing user autocomplete form submit.
 *
 * @param array $form_state
 *   Array with form values.
 * @param string $state
 *   New status for node.
 *
 * @return array
 *   Keyed array with user nd status.
 */
function _beliana_submit_assign_user_form($form_state, $state) {
  $return = [];
  $return['user'] = $form_state['values']['user'];
  $return['status'] = $state;
  return $return;
}

/**
 * Helper function changing node author and workflow status.
 *
 * @param object $node
 *   Object of node.
 * @param array $context
 *   Array of context.
 *
 * @return FALSE
 *   Return FALSE if assigning of the new group failed.
 * @throws \Exception
 *
 */
function _beliana_assign_user(&$node, $context) {
  $user = user_load_by_name($context['user']);
  if ($user !== FALSE) {
    // create array of node's categories
    $parents_all = taxonomy_get_parents_all(array_values($node->workbench_access)[0]);
    $node_taxo = [];
    foreach ($parents_all as $val) {
      $node_taxo[] = $val->tid;
    }
    // create array of user's categories
    $user_taxo = [];
    foreach ($user->workbench_access as $key => $val) {
      $user_taxo[] = $key;
    }
    // return if intersection is empty
    if (empty(array_intersect($node_taxo, $user_taxo))) {
      drupal_set_message($node->title . ' sa nepodarilo priradiť, pretože príjemca nemá potrebnú lexikálnu skupinu.', 'error');
      return FALSE;
    }
    // in the case of transfer to consultant save the author's uid to be later restored
    // use field_redaktori_zluceneho for that
    if ($context['status'] === 'u_konzultanta') {
      $node->field_uid_autora['und'][0]['value'] = $node->uid;
    }
    $node->uid = $user->uid;
    node_save($node);

    $new_state = $context['status'];
    workbench_moderation_moderate($node, $new_state);
  }
}

/**
 * Helper function removing accents.
 *
 * @param string $text
 *   String we want to remove accents from.
 *
 * @return string
 *   String without accents.
 */
function _beliana_remove_accents($text) {
  $trans = [
    'À' => 'A',
    'Á' => 'A',
    'Â' => 'A',
    'Ã' => 'A',
    'Ä' => 'A',
    'Å' => 'A',
    'Ç' => 'C',
    'È' => 'E',
    'É' => 'E',
    'Ê' => 'E',
    'Ë' => 'E',
    'Ì' => 'I',
    'Í' => 'I',
    'Î' => 'I',
    'Ï' => 'I',
    'Ñ' => 'N',
    'Ò' => 'O',
    'Ó' => 'O',
    'Ô' => 'O',
    'Õ' => 'O',
    'Ö' => 'O',
    'Ø' => 'O',
    'Ù' => 'U',
    'Ú' => 'U',
    'Û' => 'U',
    'Ü' => 'U',
    'Ý' => 'Y',
    'à' => 'a',
    'æ' => 'ae',
    'Æ' => 'ae',
    'á' => 'a',
    'â' => 'a',
    'ã' => 'a',
    'ä' => 'a',
    'å' => 'a',
    'ç' => 'c',
    'è' => 'e',
    'é' => 'e',
    'ê' => 'e',
    'ë' => 'e',
    'ì' => 'i',
    'í' => 'i',
    'î' => 'i',
    'ï' => 'i',
    'ñ' => 'n',
    'ò' => 'o',
    'ó' => 'o',
    'ô' => 'o',
    'õ' => 'o',
    'ö' => 'o',
    'ø' => 'o',
    'ù' => 'u',
    'ú' => 'u',
    'û' => 'u',
    'ü' => 'u',
    'ý' => 'y',
    'ÿ' => 'y',
    'Ā' => 'A',
    'ā' => 'a',
    'Ă' => 'A',
    'ă' => 'a',
    'Ą' => 'A',
    'ą' => 'a',
    'Ć' => 'C',
    'ć' => 'c',
    'Ĉ' => 'C',
    'ĉ' => 'c',
    'Ċ' => 'C',
    'ċ' => 'c',
    'Ď' => 'D',
    'ď' => 'd',
    'Đ' => 'D',
    'đ' => 'd',
    'Ē' => 'E',
    'ē' => 'e',
    'Ĕ' => 'E',
    'ĕ' => 'e',
    'Ė' => 'E',
    'ė' => 'e',
    'Ę' => 'E',
    'ę' => 'e',
    'Ě' => 'E',
    'ě' => 'e',
    'Ĝ' => 'G',
    'ĝ' => 'g',
    'Ğ' => 'G',
    'ğ' => 'g',
    'Ġ' => 'G',
    'ġ' => 'g',
    'Ģ' => 'G',
    'ģ' => 'g',
    'Ĥ' => 'H',
    'ĥ' => 'h',
    'Ħ' => 'H',
    'ħ' => 'h',
    'Ĩ' => 'I',
    'ĩ' => 'i',
    'Ī' => 'I',
    'ī' => 'i',
    'Ĭ' => 'I',
    'ĭ' => 'i',
    'Į' => 'I',
    'į' => 'i',
    'İ' => 'I',
    'ı' => 'i',
    'Ĵ' => 'J',
    'ĵ' => 'j',
    'Ķ' => 'K',
    'ķ' => 'k',
    'Ĺ' => 'L',
    'ĺ' => 'l',
    'Ļ' => 'L',
    'ļ' => 'l',
    'Ľ' => 'L',
    'ľ' => 'l',
    'Ŀ' => 'L',
    'ŀ' => 'l',
    'Ł' => 'L',
    'ł' => 'l',
    'Ń' => 'N',
    'ń' => 'n',
    'Ņ' => 'N',
    'ņ' => 'n',
    'Ň' => 'N',
    'ň' => 'n',
    'ŉ' => 'n',
    'Ō' => 'O',
    'ō' => 'o',
    'Ŏ' => 'O',
    'ŏ' => 'o',
    'Ő' => 'O',
    'ő' => 'o',
    'Ŕ' => 'R',
    'ŕ' => 'r',
    'Ŗ' => 'R',
    'ŗ' => 'r',
    'Ř' => 'R',
    'ř' => 'r',
    'Ś' => 'S',
    'ś' => 's',
    'Ŝ' => 'S',
    'ŝ' => 's',
    'Ş' => 'S',
    'ş' => 's',
    'Ţ' => 'T',
    'ţ' => 't',
    'Ť' => 'T',
    'ť' => 't',
    'Ŧ' => 'T',
    'ŧ' => 't',
    'Ũ' => 'U',
    'ũ' => 'u',
    'Ū' => 'U',
    'ū' => 'u',
    'Ŭ' => 'U',
    'ŭ' => 'u',
    'Ů' => 'U',
    'ů' => 'u',
    'Ű' => 'U',
    'ű' => 'u',
    'Ų' => 'U',
    'ų' => 'u',
    'Ŵ' => 'W',
    'ŵ' => 'w',
    'Ŷ' => 'Y',
    'ŷ' => 'y',
    'Ÿ' => 'Y',
    'Ź' => 'Z',
    'ź' => 'z',
    'Ż' => 'Z',
    'ż' => 'z',
    'ƀ' => 'b',
    'Ɓ' => 'B',
    'Ƃ' => 'B',
    'ƃ' => 'b',
    'Ƈ' => 'C',
    'ƈ' => 'c',
    'Ɗ' => 'D',
    'Ƌ' => 'D',
    'ƌ' => 'd',
    'Ƒ' => 'F',
    'ƒ' => 'f',
    'Ɠ' => 'G',
    'Ɨ' => 'I',
    'Ƙ' => 'K',
    'ƙ' => 'k',
    'ƚ' => 'l',
    'Ɲ' => 'N',
    'ƞ' => 'n',
    'Ɵ' => 'O',
    'Ơ' => 'O',
    'ơ' => 'o',
    'Ƥ' => 'P',
    'ƥ' => 'p',
    'ƫ' => 't',
    'Ƭ' => 'T',
    'ƭ' => 't',
    'Ʈ' => 'T',
    'Ư' => 'U',
    'ư' => 'u',
    'Ʋ' => 'V',
    'Ƴ' => 'Y',
    'ƴ' => 'y',
    'Ƶ' => 'Z',
    'ƶ' => 'z',
    'ǅ' => 'D',
    'ǈ' => 'L',
    'ǋ' => 'N',
    'Ǎ' => 'A',
    'ǎ' => 'a',
    'Ǐ' => 'I',
    'ǐ' => 'i',
    'Ǒ' => 'O',
    'ǒ' => 'o',
    'Ǔ' => 'U',
    'ǔ' => 'u',
    'Ǖ' => 'U',
    'ǖ' => 'u',
    'Ǘ' => 'U',
    'ǘ' => 'u',
    'Ǚ' => 'U',
    'ǚ' => 'u',
    'Ǜ' => 'U',
    'ǜ' => 'u',
    'Ǟ' => 'A',
    'ǟ' => 'a',
    'Ǡ' => 'A',
    'ǡ' => 'a',
    'Ǥ' => 'G',
    'ǥ' => 'g',
    'Ǧ' => 'G',
    'ǧ' => 'g',
    'Ǩ' => 'K',
    'ǩ' => 'k',
    'Ǫ' => 'O',
    'ǫ' => 'o',
    'Ǭ' => 'O',
    'ǭ' => 'o',
    'ǰ' => 'j',
    'ǲ' => 'D',
    'Ǵ' => 'G',
    'ǵ' => 'g',
    'Ǹ' => 'N',
    'ǹ' => 'n',
    'Ǻ' => 'A',
    'ǻ' => 'a',
    'Ǿ' => 'O',
    'ǿ' => 'o',
    'Ȁ' => 'A',
    'ȁ' => 'a',
    'Ȃ' => 'A',
    'ȃ' => 'a',
    'Ȅ' => 'E',
    'ȅ' => 'e',
    'Ȇ' => 'E',
    'ȇ' => 'e',
    'Ȉ' => 'I',
    'ȉ' => 'i',
    'Ȋ' => 'I',
    'ȋ' => 'i',
    'Ȍ' => 'O',
    'ȍ' => 'o',
    'Ȏ' => 'O',
    'ȏ' => 'o',
    'Ȑ' => 'R',
    'ȑ' => 'r',
    'Ȓ' => 'R',
    'ȓ' => 'r',
    'Ȕ' => 'U',
    'ȕ' => 'u',
    'Ȗ' => 'U',
    'ȗ' => 'u',
    'Ș' => 'S',
    'ș' => 's',
    'Ț' => 'T',
    'ț' => 't',
    'Ȟ' => 'H',
    'ȟ' => 'h',
    'Ƞ' => 'N',
    'ȡ' => 'd',
    'Ȥ' => 'Z',
    'ȥ' => 'z',
    'Ȧ' => 'A',
    'ȧ' => 'a',
    'Ȩ' => 'E',
    'ȩ' => 'e',
    'Ȫ' => 'O',
    'ȫ' => 'o',
    'Ȭ' => 'O',
    'ȭ' => 'o',
    'Ȯ' => 'O',
    'ȯ' => 'o',
    'Ȱ' => 'O',
    'ȱ' => 'o',
    'Ȳ' => 'Y',
    'ȳ' => 'y',
    'ȴ' => 'l',
    'ȵ' => 'n',
    'ȶ' => 't',
    'ȷ' => 'j',
    'Ⱥ' => 'A',
    'Ȼ' => 'C',
    'ȼ' => 'c',
    'Ƚ' => 'L',
    'Ⱦ' => 'T',
    'ȿ' => 's',
    'ɀ' => 'z',
    'Ƀ' => 'B',
    'Ʉ' => 'U',
    'Ɇ' => 'E',
    'ɇ' => 'e',
    'Ɉ' => 'J',
    'ɉ' => 'j',
    'ɋ' => 'q',
    'Ɍ' => 'R',
    'ɍ' => 'r',
    'Ɏ' => 'Y',
    'ɏ' => 'y',
    'ɓ' => 'b',
    'ɕ' => 'c',
    'ɖ' => 'd',
    'ɗ' => 'd',
    'ɟ' => 'j',
    'ɠ' => 'g',
    'ɦ' => 'h',
    'ɨ' => 'i',
    'ɫ' => 'l',
    'ɬ' => 'l',
    'ɭ' => 'l',
    'ɱ' => 'm',
    'ɲ' => 'n',
    'ɳ' => 'n',
    'ɵ' => 'o',
    'ɼ' => 'r',
    'ɽ' => 'r',
    'ɾ' => 'r',
    'ʂ' => 's',
    'ʄ' => 'j',
    'ʈ' => 't',
    'ʉ' => 'u',
    'ʋ' => 'v',
    'ʐ' => 'z',
    'ʑ' => 'z',
    'ʝ' => 'j',
    'ʠ' => 'q',
    'ͣ' => 'a',
    'ͤ' => 'e',
    'ͥ' => 'i',
    'ͦ' => 'o',
    'ͧ' => 'u',
    'ͨ' => 'c',
    'ͩ' => 'd',
    'ͪ' => 'h',
    'ͫ' => 'm',
    'ͬ' => 'r',
    'ͭ' => 't',
    'ͮ' => 'v',
    'ͯ' => 'x',
    'ᵢ' => 'i',
    'ᵣ' => 'r',
    'ᵤ' => 'u',
    'ᵥ' => 'v',
    'ᵬ' => 'b',
    'ᵭ' => 'd',
    'ᵮ' => 'f',
    'ᵯ' => 'm',
    'ᵰ' => 'n',
    'ᵱ' => 'p',
    'ᵲ' => 'r',
    'ᵳ' => 'r',
    'ᵴ' => 's',
    'ᵵ' => 't',
    'ᵶ' => 'z',
    'ᵻ' => 'i',
    'ᵽ' => 'p',
    'ᵾ' => 'u',
    'ᶀ' => 'b',
    'ᶁ' => 'd',
    'ᶂ' => 'f',
    'ᶃ' => 'g',
    'ᶄ' => 'k',
    'ᶅ' => 'l',
    'ᶆ' => 'm',
    'ᶇ' => 'n',
    'ᶈ' => 'p',
    'ᶉ' => 'r',
    'ᶊ' => 's',
    'ᶌ' => 'v',
    'ᶍ' => 'x',
    'ᶎ' => 'z',
    'ᶏ' => 'a',
    'ᶑ' => 'd',
    'ᶒ' => 'e',
    'ᶖ' => 'i',
    'ᶙ' => 'u',
    '᷊' => 'r',
    'ᷗ' => 'c',
    'ᷚ' => 'g',
    'ᷜ' => 'k',
    'ᷝ' => 'l',
    'ᷠ' => 'n',
    'ᷣ' => 'r',
    'ᷤ' => 's',
    'ᷦ' => 'z',
    'Ḁ' => 'A',
    'ḁ' => 'a',
    'Ḃ' => 'B',
    'ḃ' => 'b',
    'Ḅ' => 'B',
    'ḅ' => 'b',
    'Ḇ' => 'B',
    'ḇ' => 'b',
    'Ḉ' => 'C',
    'ḉ' => 'c',
    'Ḋ' => 'D',
    'ḋ' => 'd',
    'Ḍ' => 'D',
    'ḍ' => 'd',
    'Ḏ' => 'D',
    'ḏ' => 'd',
    'Ḑ' => 'D',
    'ḑ' => 'd',
    'Ḓ' => 'D',
    'ḓ' => 'd',
    'Ḕ' => 'E',
    'ḕ' => 'e',
    'Ḗ' => 'E',
    'ḗ' => 'e',
    'Ḙ' => 'E',
    'ḙ' => 'e',
    'Ḛ' => 'E',
    'ḛ' => 'e',
    'Ḝ' => 'E',
    'ḝ' => 'e',
    'Ḟ' => 'F',
    'ḟ' => 'f',
    'Ḡ' => 'G',
    'ḡ' => 'g',
    'Ḣ' => 'H',
    'ḣ' => 'h',
    'Ḥ' => 'H',
    'ḥ' => 'h',
    'Ḧ' => 'H',
    'ḧ' => 'h',
    'Ḩ' => 'H',
    'ḩ' => 'h',
    'Ḫ' => 'H',
    'ḫ' => 'h',
    'Ḭ' => 'I',
    'ḭ' => 'i',
    'Ḯ' => 'I',
    'ḯ' => 'i',
    'Ḱ' => 'K',
    'ḱ' => 'k',
    'Ḳ' => 'K',
    'ḳ' => 'k',
    'Ḵ' => 'K',
    'ḵ' => 'k',
    'Ḷ' => 'L',
    'ḷ' => 'l',
    'Ḹ' => 'L',
    'ḹ' => 'l',
    'Ḻ' => 'L',
    'ḻ' => 'l',
    'Ḽ' => 'L',
    'ḽ' => 'l',
    'Ḿ' => 'M',
    'ḿ' => 'm',
    'Ṁ' => 'M',
    'ṁ' => 'm',
    'Ṃ' => 'M',
    'ṃ' => 'm',
    'Ṅ' => 'N',
    'ṅ' => 'n',
    'Ṇ' => 'N',
    'ṇ' => 'n',
    'Ṉ' => 'N',
    'ṉ' => 'n',
    'Ṋ' => 'N',
    'ṋ' => 'n',
    'Ṍ' => 'O',
    'ṍ' => 'o',
    'Ṏ' => 'O',
    'ṏ' => 'o',
    'Ṑ' => 'O',
    'ṑ' => 'o',
    'Ṓ' => 'O',
    'ṓ' => 'o',
    'Ṕ' => 'P',
    'ṕ' => 'p',
    'Ṗ' => 'P',
    'ṗ' => 'p',
    'Ṙ' => 'R',
    'ṙ' => 'r',
    'Ṛ' => 'R',
    'ṛ' => 'r',
    'Ṝ' => 'R',
    'ṝ' => 'r',
    'Ṟ' => 'R',
    'ṟ' => 'r',
    'Ṡ' => 'S',
    'ṡ' => 's',
    'Ṣ' => 'S',
    'ṣ' => 's',
    'Ṥ' => 'S',
    'ṥ' => 's',
    'Ṧ' => 'S',
    'ṧ' => 's',
    'Ṩ' => 'S',
    'ṩ' => 's',
    'Ṫ' => 'T',
    'ṫ' => 't',
    'Ṭ' => 'T',
    'ṭ' => 't',
    'Ṯ' => 'T',
    'ṯ' => 't',
    'Ṱ' => 'T',
    'ṱ' => 't',
    'Ṳ' => 'U',
    'ṳ' => 'u',
    'Ṵ' => 'U',
    'ṵ' => 'u',
    'Ṷ' => 'U',
    'ṷ' => 'u',
    'Ṹ' => 'U',
    'ṹ' => 'u',
    'Ṻ' => 'U',
    'ṻ' => 'u',
    'Ṽ' => 'V',
    'ṽ' => 'v',
    'Ṿ' => 'V',
    'ṿ' => 'v',
    'Ẁ' => 'W',
    'ẁ' => 'w',
    'Ẃ' => 'W',
    'ẃ' => 'w',
    'Ẅ' => 'W',
    'ẅ' => 'w',
    'Ẇ' => 'W',
    'ẇ' => 'w',
    'Ẉ' => 'W',
    'ẉ' => 'w',
    'Ẋ' => 'X',
    'ẋ' => 'x',
    'Ẍ' => 'X',
    'ẍ' => 'x',
    'Ẏ' => 'Y',
    'ẏ' => 'y',
    'Ẑ' => 'Z',
    'ẑ' => 'z',
    'Ẓ' => 'Z',
    'ẓ' => 'z',
    'Ẕ' => 'Z',
    'ẕ' => 'z',
    'ẖ' => 'h',
    'ẗ' => 't',
    'ẘ' => 'w',
    'ẙ' => 'y',
    'ẚ' => 'a',
    'Ạ' => 'A',
    'ạ' => 'a',
    'Ả' => 'A',
    'ả' => 'a',
    'Ấ' => 'A',
    'ấ' => 'a',
    'Ầ' => 'A',
    'ầ' => 'a',
    'Ẩ' => 'A',
    'ẩ' => 'a',
    'Ẫ' => 'A',
    'ẫ' => 'a',
    'Ậ' => 'A',
    'ậ' => 'a',
    'Ắ' => 'A',
    'ắ' => 'a',
    'Ằ' => 'A',
    'ằ' => 'a',
    'Ẳ' => 'A',
    'ẳ' => 'a',
    'Ẵ' => 'A',
    'ẵ' => 'a',
    'Ặ' => 'A',
    'ặ' => 'a',
    'Ẹ' => 'E',
    'ẹ' => 'e',
    'Ẻ' => 'E',
    'ẻ' => 'e',
    'Ẽ' => 'E',
    'ẽ' => 'e',
    'Ế' => 'E',
    'ế' => 'e',
    'Ề' => 'E',
    'ề' => 'e',
    'Ể' => 'E',
    'ể' => 'e',
    'Ễ' => 'E',
    'ễ' => 'e',
    'Ệ' => 'E',
    'ệ' => 'e',
    'Ỉ' => 'I',
    'ỉ' => 'i',
    'Ị' => 'I',
    'ị' => 'i',
    'Ọ' => 'O',
    'ọ' => 'o',
    'Ỏ' => 'O',
    'ỏ' => 'o',
    'Ố' => 'O',
    'ố' => 'o',
    'Ồ' => 'O',
    'ồ' => 'o',
    'Ổ' => 'O',
    'ổ' => 'o',
    'Ỗ' => 'O',
    'ỗ' => 'o',
    'Ộ' => 'O',
    'ộ' => 'o',
    'Ớ' => 'O',
    'ớ' => 'o',
    'Ờ' => 'O',
    'ờ' => 'o',
    'Ở' => 'O',
    'ở' => 'o',
    'Ỡ' => 'O',
    'ỡ' => 'o',
    'Ợ' => 'O',
    'ợ' => 'o',
    'Ụ' => 'U',
    'ụ' => 'u',
    'Ủ' => 'U',
    'ủ' => 'u',
    'Ứ' => 'U',
    'ứ' => 'u',
    'Ừ' => 'U',
    'ừ' => 'u',
    'Ử' => 'U',
    'ử' => 'u',
    'Ữ' => 'U',
    'ữ' => 'u',
    'Ự' => 'U',
    'ự' => 'u',
    'Ỳ' => 'Y',
    'ỳ' => 'y',
    'Ỵ' => 'Y',
    'ỵ' => 'y',
    'Ỷ' => 'Y',
    'ỷ' => 'y',
    'Ỹ' => 'Y',
    'ỹ' => 'y',
    'Ỿ' => 'Y',
    'ỿ' => 'y',
    'ⁱ' => 'i',
    'ⁿ' => 'n',
    'ₐ' => 'a',
    'ₑ' => 'e',
    'ₒ' => 'o',
    'ₓ' => 'x',
    '⒜' => 'a',
    '⒝' => 'b',
    '⒞' => 'c',
    '⒟' => 'd',
    '⒠' => 'e',
    '⒡' => 'f',
    '⒢' => 'g',
    '⒣' => 'h',
    '⒤' => 'i',
    '⒥' => 'j',
    '⒦' => 'k',
    '⒧' => 'l',
    '⒨' => 'm',
    '⒩' => 'n',
    '⒪' => 'o',
    '⒫' => 'p',
    '⒬' => 'q',
    '⒭' => 'r',
    '⒮' => 's',
    '⒯' => 't',
    '⒰' => 'u',
    '⒱' => 'v',
    '⒲' => 'w',
    '⒳' => 'x',
    '⒴' => 'y',
    '⒵' => 'z',
    'Ⓐ' => 'A',
    'Ⓑ' => 'B',
    'Ⓒ' => 'C',
    'Ⓓ' => 'D',
    'Ⓔ' => 'E',
    'Ⓕ' => 'F',
    'Ⓖ' => 'G',
    'Ⓗ' => 'H',
    'Ⓘ' => 'I',
    'Ⓙ' => 'J',
    'Ⓚ' => 'K',
    'Ⓛ' => 'L',
    'Ⓜ' => 'M',
    'Ⓝ' => 'N',
    'Ⓞ' => 'O',
    'Ⓟ' => 'P',
    'Ⓠ' => 'Q',
    'Ⓡ' => 'R',
    'Ⓢ' => 'S',
    'Ⓣ' => 'T',
    'Ⓤ' => 'U',
    'Ⓥ' => 'V',
    'Ⓦ' => 'W',
    'Ⓧ' => 'X',
    'Ⓨ' => 'Y',
    'Ⓩ' => 'Z',
    'ⓐ' => 'a',
    'ⓑ' => 'b',
    'ⓒ' => 'c',
    'ⓓ' => 'd',
    'ⓔ' => 'e',
    'ⓕ' => 'f',
    'ⓖ' => 'g',
    'ⓗ' => 'h',
    'ⓘ' => 'i',
    'ⓙ' => 'j',
    'ⓚ' => 'k',
    'ⓛ' => 'l',
    'ⓜ' => 'm',
    'ⓝ' => 'n',
    'ⓞ' => 'o',
    'ⓟ' => 'p',
    'ⓠ' => 'q',
    'ⓡ' => 'r',
    'ⓢ' => 's',
    'ⓣ' => 't',
    'ⓤ' => 'u',
    'ⓥ' => 'v',
    'ⓦ' => 'w',
    'ⓧ' => 'x',
    'ⓨ' => 'y',
    'ⓩ' => 'z',
    'Ⱡ' => 'L',
    'ⱡ' => 'l',
    'Ɫ' => 'L',
    'Ᵽ' => 'P',
    'Ɽ' => 'R',
    'ⱥ' => 'a',
    'ⱦ' => 't',
    'Ⱨ' => 'H',
    'ⱨ' => 'h',
    'Ⱪ' => 'K',
    'ⱪ' => 'k',
    'Ⱬ' => 'Z',
    'ⱬ' => 'z',
    'Ɱ' => 'M',
    'ⱱ' => 'v',
    'Ⱳ' => 'W',
    'ⱳ' => 'w',
    'ⱴ' => 'v',
    'ⱸ' => 'e',
    'ⱺ' => 'o',
    'ⱼ' => 'j',
    'Ꝁ' => 'K',
    'ꝁ' => 'k',
    'Ꝃ' => 'K',
    'ꝃ' => 'k',
    'Ꝅ' => 'K',
    'ꝅ' => 'k',
    'Ꝉ' => 'L',
    'ꝉ' => 'l',
    'Ꝋ' => 'O',
    'ꝋ' => 'o',
    'Ꝍ' => 'O',
    'ꝍ' => 'o',
    'Ꝑ' => 'P',
    'ꝑ' => 'p',
    'Ꝓ' => 'P',
    'ꝓ' => 'p',
    'Ꝕ' => 'P',
    'ꝕ' => 'p',
    'Ꝗ' => 'Q',
    'ꝗ' => 'q',
    'Ꝙ' => 'Q',
    'ꝙ' => 'q',
    'Ꝛ' => 'R',
    'ꝛ' => 'r',
    'Ꝟ' => 'V',
    'ꝟ' => 'v',
    'Ａ' => 'A',
    'Ｂ' => 'B',
    'Ｃ' => 'C',
    'Ｄ' => 'D',
    'Ｅ' => 'E',
    'Ｆ' => 'F',
    'Ｇ' => 'G',
    'Ｈ' => 'H',
    'Ｉ' => 'I',
    'Ｊ' => 'J',
    'Ｋ' => 'K',
    'Ｌ' => 'L',
    'Ｍ' => 'M',
    'Ｎ' => 'N',
    'Ｏ' => 'O',
    'Ｐ' => 'P',
    'Ｑ' => 'Q',
    'Ｒ' => 'R',
    'Ｓ' => 'S',
    'Ｔ' => 'T',
    'Ｕ' => 'U',
    'Ｖ' => 'V',
    'Ｗ' => 'W',
    'Ｘ' => 'X',
    'Ｙ' => 'Y',
    'Ｚ' => 'Z',
    'ａ' => 'a',
    'ｂ' => 'b',
    'ｃ' => 'c',
    'ｄ' => 'd',
    'ｅ' => 'e',
    'ｆ' => 'f',
    'ｇ' => 'g',
    'ｈ' => 'h',
    'ｉ' => 'i',
    'ｊ' => 'j',
    'ｋ' => 'k',
    'ｌ' => 'l',
    'ｍ' => 'm',
    'ｎ' => 'n',
    'ｏ' => 'o',
    'ｐ' => 'p',
    'ｑ' => 'q',
    'ｒ' => 'r',
    'ｓ' => 's',
    'ｔ' => 't',
    'ｕ' => 'u',
    'ｖ' => 'v',
    'ｗ' => 'w',
    'ｘ' => 'x',
    'ｙ' => 'y',
    'ｚ' => 'z',
  ];
  return strtr($text, $trans);
}

/**
 * Helper function to extract dates from an article header
 *
 * @param string $text
 *   String with the article text (field_text_hesla)
 *
 * @return array
 *   Array of dates to be stored in field_datum, may be empty
 */
function get_header_dates($text) {
  $dates = [];

  # ignore pure reference articles  (they do not contain em dash "—")
  $exploded = explode("—", $text);
  if (count($exploded) > 1) {
    // $header = $exploded[0];
    // remove tags first
    $header = preg_replace('/<[^>]*>/', '', $exploded[0]);
    # find all dates in header
    $pattern = "/ (\d{1,2}. \d{1,2}. \d{4} )/";
    preg_match_all($pattern, $header, $matches);

    # convert dates to importable form and save them to 'dates'
    foreach ($matches[0] as $mt) {
      sscanf($mt, "%d. %d. %d", $d, $m, $y);
      if ($y > 999) { # drupal does not like dates prior to 1000
        $odate = sprintf("%d-%02d-%02dT00:00:00", $y, $m, $d);
        array_push($dates, $odate);
      }
    }
  }
  return $dates;
}

/**
 * Delete unnecessary tags from node text
 * these usually originate from pasting from Word and from highlighting text
 * and undoing the highlights
 *
 * @param $node
 *   node the next 'text' argument relates to (may be article node, but the
 *   text may be related to illustration)
 * @param string $text
 *   node text area to be represented
 * @param string $where
 *   some text for an error message
 *
 * @return
 *   cleaned $text or unchanged $text in case of an error (e.g. not valid html)
 */
function beliana_clean_tags($node, $text, $where) {
  $dom = beliana_get_dom($node, $text, $where);
  if (!$dom) {
    return $text;
  }

  $xpath = new DOMXPath($dom);
  // remove tags completely: <ins>, <span>, ....
  $rmtags = [
    '//ins[not(@*)]',
    '//span[not(@*)]',
    '//span[@style="background-color:null"]',
    '//span[@style="background-color:#ffffff"]',
    '//span[@style="background-color:white"]',
    '//td/p',
  ];
  foreach ($rmtags as $tag) {
    //_remove_node($xpath, $tag);
    // Move all tag node content to its parent node just before it.
    foreach ($xpath->query($tag) as $textnode) {
      while ($textnode->hasChildNodes()) {
        $child = $textnode->removeChild($textnode->firstChild);
        $textnode->parentNode->insertBefore($child, $textnode);
      }
      // Remove the tag node.
      $textnode->parentNode->removeChild($textnode);
    }
  }

  // remove tag attributes
  $cltags = [
    ["a", "style"],
    ["a", "target"],
    ["td", "style"],
    ["th", "class"],
    ["table", "border"],
    ["table", "cellspacing"],
    ["table", "cellpadding"],
    ["table", "style"],
  ];
  foreach ($cltags as $cltag) {
    $tagstring = "//" . $cltag[0] . "[@" . $cltag[1] . "]";
    foreach ($xpath->query($tagstring) as $tag) {
      $sNode = $tag->getAttributeNode($cltag[1]);
      $tag->removeAttributeNode($sNode);
    }
  }

  $fragment = '';
  foreach ($dom->getElementsByTagName('body')->item(0)->childNodes as $chnode) {
    $fragment .= $dom->saveHtml($chnode);
  }
  //fix a problem caused somewhere above (<br> is later replaced by a pair of  <br /> tags)
  $fragment = str_replace("<br>", "<br />", $fragment);

  //remove formatted space (non-breakable space fixed too)
  $fragment = str_replace("<em> </em>", " ", $fragment);
  $fragment = str_replace("<em> </em>", " ", $fragment);
  $fragment = str_replace("<strong> </strong>", " ", $fragment);
  $fragment = str_replace("<strong> </strong>", " ", $fragment);

  // remove empty lines at start and at end
  // CKeditor inserts as empty line "<p> </p>" with non-breakable space
  // nonbreakable space: " " here
  $fragment = preg_replace('#^(<p> </p>[\r\n]*)*#', '', $fragment);
  $fragment = preg_replace('#[\r\n]*$#', '', $fragment);
  $fragment = preg_replace('#([\r\n]*<p> </p>)*$#', '', $fragment);
  // the same with (repeated) normal space
  $fragment = preg_replace('#^(<p> *</p>[\r\n]*)*#', '', $fragment);
  $fragment = preg_replace('#[\r\n]*$#', '', $fragment);
  $fragment = preg_replace('#([\r\n]*<p> *</p>)*$#', '', $fragment);

  $fragment = str_replace('﻿', '', $fragment);

  return $fragment;
}

/**
 * Helper function for representing node text as DOM
 *
 * @param $node
 *   node the next 'text' argument relates to (may be article node, but the
 *   text may be related to illustration)
 * @param string $text
 *   node text area to be represented
 * @param string $where
 *   some text for an error message
 *
 * @return
 *   null or $dom
 *   no error message if $where == Null
 */
function beliana_get_dom($node, $text, $where = NULL) {
  $internalErrorsState = libxml_use_internal_errors(TRUE);
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($text, 'HTML-ENTITIES', 'UTF-8'));

  // handle errors locally
  $errors = libxml_get_errors();
  if ($errors) {
    # clear errors and restore error loging status
    if ($where) {
      foreach ($errors as $error) {
        html_error($node, $error, "Chyba HTML syntaxe v poli '" . $where);
      }
    }
    libxml_clear_errors();
    libxml_use_internal_errors($internalErrorsState);
    return NULL;
  }
  # clear errors and restore error loging status
  libxml_clear_errors();
  libxml_use_internal_errors($internalErrorsState);
  return $dom;
}

/* ----- CURL HELPER CALLBACKS ----- */

function beliana_api_rest_login($request_url) {
  $user_data = [
    'username' => variable_get('rs_api_login'),
    'password' => variable_get('rs_api_password'),
  ];

  $data = [];
  $curl = curl_init($request_url . '/user/login');

  // LOGIN USER
  curl_setopt($curl, CURLOPT_HTTPHEADER, ['Accept: application/json']);
  curl_setopt($curl, CURLOPT_POST, 1);
  curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($user_data));
  curl_setopt($curl, CURLOPT_HEADER, FALSE);
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($curl, CURLOPT_FAILONERROR, TRUE);

  $response = curl_exec($curl);
  $http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);

  if ($http_code == 200) {
    $logged_user = json_decode($response);
  }
  else {
    $http_message = curl_error($curl);
    watchdog('error', 'Auth error in node synchronization (' . $request_url . ') ' . $http_message);
    return FALSE;
  }

  $data['session'] = $logged_user->session_name . '=' . $logged_user->sessid;

  // GET CSRF TOKEN
  curl_setopt_array($curl, [
    CURLOPT_RETURNTRANSFER => 1,
    CURLOPT_URL => $request_url . '/user/token',
  ]);

  curl_setopt($curl, CURLOPT_COOKIE, $data['session'] . "");

  $ret = new stdClass;
  $ret->response = curl_exec($curl);
  $response = json_decode($ret->response);
  //watchdog('sync', $ret->response);

  if (is_object($response)) {
    $data['token'] = $response->token;
  }

  return $data;
}

/*
 * Create remote node (Heslo only) in the web editorial system
 * sets current nid in the remote_nid field of the remote node
 * sets nid of the remote node in the remote_nid of the current node
 * sets fields title_field, field_lexikalna_skupina and field_text_hesla od the remote node
 * sets remote node alias to be the same as alias of the current node
 * $site: 'rs' or 'rsw'
 * $which_article: "Nové heslo:" or "Zlúčené heslo:"
 * $attribute: if set, field_attibuty of the remote node is set to this value (used to set "Zlucene heslo" in article merging"
 */
function beliana_api_rest_create_node($node, $site, $which_article, $attribute = NULL) {
  global $user;

  $base_url = variable_get('rs_api_uri');
  $request_url = $base_url . '/api/heslo';

  if ($login = beliana_api_rest_login($request_url)) {
    $curl = curl_init($request_url . '/node');
    $comment = $site == 'rsw' ? 'vo webovom' : 'v knižnom';
    $instructions = empty($node->field_komentar_instrukcie[LANGUAGE_NONE]) ? '' : PHP_EOL . $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];

    $data = [
      'type' => $node->type,
      'title' => $node->title,
      'status' => $node->status,
      'title_field[und][0][value]' => $node->title,
      'field_komentar_instrukcie[und][0][value]' => $which_article . ' vytvorené ' . $comment . ' redakčnom systéme ' . date('d.m.Y') . ', ' . $user->name . '. ' . $instructions,
      'field_remote_id[und][0][value]' => $node->nid,
    ];

    // we need to distinguish between:
    // field_lexikalna_skupina and  field_lexikalna_skupina_il
    // field_text_hesla and field_popis
    if ($node->type == "heslo") {
      $terms = [];
      $data['field_text_hesla[und][0][value]'] = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
      $data['field_text_hesla[und][0][format]'] = 'filtered_html';
      if (!$attribute) {  # regularly created article
        if (!empty($node->field_lexikalna_skupina[LANGUAGE_NONE])) {
          foreach ($node->field_lexikalna_skupina[LANGUAGE_NONE] as $value) {
            $terms[] = $value['name'];
          }
          $data['field_lexikalna_skupina[und]'] = implode(', ', $terms);
        }
      }
      else {  # only if article is created by merging
        if (!empty($node->field_povodne_lexikalne_skupiny[LANGUAGE_NONE])) {
          foreach ($node->field_povodne_lexikalne_skupiny[LANGUAGE_NONE] as $value) {
            $term = taxonomy_term_load($value['tid']);
            $terms[] = $term->name;
          }
          $data['field_lexikalna_skupina[und]'] = implode(', ', $terms);
        }
      }
    }
    else { // ilustracia
      $terms = [];
      $data['field_popis[und][0][value]'] = $node->field_popis[LANGUAGE_NONE][0]['value'];
      $data['field_popis[und][0][format]'] = 'filtered_html';
      if (!empty($node->field_lexikalna_skupina_il[LANGUAGE_NONE])) {
        foreach ($node->field_lexikalna_skupina_il[LANGUAGE_NONE] as $value) {
          $terms[] = $value['name'];
        }
        $data['field_lexikalna_skupina_il[und]'] = implode(', ', $terms);
      }
    }

    if ($attribute) {
      $data['field_atributy[und][0][value]'] = $attribute;
    }

    curl_setopt($curl, CURLOPT_HTTPHEADER, [
      'Accept: application/json',
      'X-CSRF-Token: ' . $login['token'],
    ]);
    curl_setopt($curl, CURLOPT_POST, 1);
    curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($data));
    curl_setopt($curl, CURLOPT_HEADER, FALSE);
    curl_setopt($curl, CURLOPT_COOKIE, $login['session'] . "");
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($curl, CURLOPT_FAILONERROR, TRUE);

    $response = curl_exec($curl);
    $http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);

    if ($http_code == 200) {
      $response = json_decode($response);
      watchdog('sync', 'Created remote node <a href="' . $base_url . '/node/' . $response->nid . '">' . $node->title . '</a>');
      return $response;
    }
    else {
      $http_message = curl_error($curl);
      watchdog('error', 'Error creating remote node (' . $node->title . '): ' . $http_message);
    }
  }

  return FALSE;
}

function beliana_api_rest_get_node($id) {
  $base_url = variable_get('rs_api_uri');
  $request_url = $base_url . '/api/heslo';

  if ($login = beliana_api_rest_login($request_url)) {
    $curl = curl_init($request_url . '/node/' . $id);
    curl_setopt($curl, CURLOPT_HTTPHEADER, [
      'Accept: application/json',
      'X-CSRF-Token: ' . $login['token'],
    ]);
    curl_setopt($curl, CURLOPT_HEADER, FALSE);
    curl_setopt($curl, CURLOPT_COOKIE, $login['session'] . "");
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($curl, CURLOPT_FAILONERROR, TRUE);

    $response = curl_exec($curl);
    $http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);

    if ($http_code == 200) {
      return json_decode($response);
    }
  }

  return FALSE;
}

// display error message (illustration)
function il_error($node, $ilu_node, $msg, $category) {
  if ($node->type === 'ilustracia') {
    watchdog($category, 'Chyba v ilustrácii "@ilu_title": ' . $msg, [
      '@ilu_title' => $ilu_node->title,
    ], WATCHDOG_NOTICE);
    $msg = 'Chyba v ilustrácii <strong><a href="/' . $ilu_node->path['source'] . '">' . $ilu_node->title . '</a></strong>: ' . $msg . '.';
    drupal_set_message($msg, 'error');
  }
  else {
    watchdog($category, 'Chyba v hesle "@title": ilustrácia "@ilu_title:" ' . $msg, [
      '@title' => $node->title,
      '@ilu_title' => $ilu_node->title,
    ], WATCHDOG_NOTICE);
    $msg = 'Chyba v hesle <a href ="/' . $node->path['source'] . '">' . $node->title . '</a>: ilustrácia <strong><a href="/' . $ilu_node->path['source'] . '">' . $ilu_node->title . '</a></strong>: ' . $msg . '.';
    drupal_set_message($msg, 'error');
  }
}

// display error message (article)
function art_error($node, $msg, $category) {
  watchdog($category, 'Chyba v hesle "@title" ' . $msg, [
    '@title' => $node->title,
  ], WATCHDOG_NOTICE);
  $msg = 'Chyba v hesle <a href ="/' . $node->path['source'] . '">' . $node->title . '</a>: ' . $msg . '.';
  drupal_set_message($msg, 'error');
}

// prepare and display error message in the case of html syntax error
function html_error($node, $error, $shortmsg) {
  $msg = $shortmsg . ": " . $error->message . "(" . "riadok " . $error->line . ", znak " . $error->column . ")";
  art_error($node, $msg, 'htmlerror');
}

/*
 * compare two strings taking into account possible abbreviations
 */
function abb_equal($abtext, $text) {
  $abte = explode(" ", str_replace(".", "", $abtext));
  $te = explode(" ", $text);
  if (count($abte) != count($te)) {
    return FALSE;
  }
  foreach (array_combine($abte, $te) as $a => $t) {
    if ($a != substr($t, 0, strlen($a))) {
      return FALSE;
    }
  }
  return "true";
}

/*
 * transfer links from text_from to text_to
 * return array(new_text, log)
 */
function transfer_links($text_to, $text_from) {
  //dpm($text_from, "from");
  //dpm($text_to, "to");
  $text_to = str_replace("—&gt; ", "➔", $text_to);
  $text_to = str_replace("—>", "➔", $text_to);
  $text_to = str_replace("➔", "➔ ", $text_to);
  $text_to = str_replace(" ", " ", $text_to); //odstranit nezalomitelnu medzeru
  $text_to = str_replace("&nbsp;", " ", $text_to); //odstranit nezalomitelnu medzeru
  $text_to = str_replace("﻿", "", $text_to); //odstranit nezalomitelny znak 0-ovej sirky
  $text_to = str_replace("​", "", $text_to); //odstranit nezalomitelny znak 0-ovej sirky


  //remove <p> tags from tables
  preg_match_all('?(<p><table.*</table></p>)?ms', $text_to, $tbs);
  foreach ($tbs[0] as $tb) {
    $tbp = str_replace("</p>", "", str_replace("<p>", "", $tb));
    $text_to = str_replace($tb, $tbp, $text_to);
  }

  // fix junk inherited for MS Word
  //<em>a<sub>i</em></sub>
  $text_to = preg_replace("?<em>([^<]+)<sub>([^<]+)</em></sub>?u", "<em>$1<sub>$2</sub></em>", $text_to);
  $text_to = preg_replace("?<em>([^<]+)<sup>([^<]+)</em></sup>?u", "<em>$1<sup>$2</sup></em>", $text_to);
  //<strong>Rozloha v tis. km<sup>2</strong></sup>
  //<strong>e<sub>i</sub> e<sub>j</strong></sub>
  $text_to = preg_replace("?<strong>([^<]+)<sub>([^<]+)</strong></sub>?u", "<strong>$1<sub>$2</sub></strong>", $text_to);
  $text_to = preg_replace("?<strong>([^<]+)<sup>([^<]+)</strong></sup>?u", "<strong>$1<sup>$2</sup></strong>", $text_to);
  $text_to = preg_replace("?<em>([^<]*)<sub>([^<]*)</sub>([^<]*)<sub>([^<]*)</em></sub>?u", "<em>$1<sub>$2</sub>$3<sub>$4</sub></em>", $text_to);
  $text_to = preg_replace("?<strong>([^<]*)<sub>([^<]*)</sub>([^<]*)<sub>([^<]*)</strong></sub>?u", "<strong>$1<sub>$2</sub>$3<sub>$4</sub></strong>", $text_to);
  #<em>h<sup>1</sup>-e<sup>2</sup>-a<sup>2</em></sup>
  $text_to = preg_replace("?<em>([^<]*)<sup>([^<]*)</sup>([^<]*)<sup>([^<]*)</sup>([^<]*)<sup>([^<]*)</em></sup>?u", "?<em>$1<sup>$2</sup>$3<sup>$4</sup>$5<sup>$6</sup></em>?u", $text_to);
  //<em>a. k. = a<sub>i</sub>/c<sub>i</em></sub>
  $text_to = preg_replace("?<em>([^<]*)<sub>([^<]*)</sub>([^<]*)<sub>([^<]*)</em></sub>?u", "<em>$1<sub>$2</sub>$3<sub>$4</sub></em>", $text_to);

  // remove <strong> and <em> from text_from (links are sometimes formatted)
  $text_from = str_replace("</span>", "", preg_replace("?<span[^>]*>?u", "", $text_from));
  $text_from = str_replace("</em>", "", str_replace("<em>", "", $text_from));
  $text_from = str_replace("</strong>", "", str_replace("<strong>", "", $text_from));
  $text_from = str_replace(" ", " ", $text_from); //odstranit nezalomitelnu medzeru
  $text_from = str_replace("&nbsp;", " ", $text_from); //odstranit nezalomitelnu medzeru
  $text_from = str_replace("﻿", "", $text_from); //odstranit nezalomitelny znak 0-ovej sirky
  $text_from = str_replace("​", "", $text_from); //odstranit nezalomitelny znak 0-ovej sirky

  $log = "";
  #rearrange the arrays
  #[<a href="/heslo/omyl_02">omylu</a>] =>
  #     Array ( [0] => <a href="/heslo/omyl_02">omylu</a> [1] => <a href="/heslo/omyl_02"> [2] => omylu)
  preg_match_all('*(<a [^>]+>)([^<]+)(<\/a>)*', $text_from, $match_from);
  $rmatch_from = [];
  for ($i = 0; $i < count($match_from[0]); $i++) {
    $rmatch_from[$match_from[0][$i]] = [
      $match_from[0][$i],
      $match_from[1][$i],
      $match_from[2][$i],
    ];
  }

  preg_match_all('*(<a [^>]+>)([^<]+)(<\/a>)*', $text_to, $match_to);
  $rmatch_to = [];
  for ($i = 0; $i < count($match_to[0]); $i++) {
    $rmatch_to[$match_to[0][$i]] = [
      $match_to[0][$i],
      $match_to[1][$i],
      $match_to[2][$i],
    ];
  }

  // remove the <a> tags
  $text_to = preg_replace("/<a[^>]*>/", " ", $text_to);
  $text_to = str_replace("</a>", "", $text_to);
  $text_to = preg_replace("/  +/", " ", $text_to); //odstranit opakovane medzery

  // replace from >> to by exact matching
  $used = [];
  foreach ($rmatch_from as $key => $value) {
    if (strpos($text_to, "➔ " . $value[2])) {
      $text_to = str_replace("➔ " . $value[2], "➔ " . $value[0], $text_to);
      $log = $log . "Doplnený odkaz (priamo): " . $value[2] . "\n";
      $used[] = $key;
    }
  }
  foreach ($used as $key) {
    unset($rmatch_from[$key]);
  }

  // replace from >> to by abbreviation matching or fuzzy matching
  // find max. number of words in text_from links
  $wmax = 0;
  foreach ($rmatch_from as $key => $value) {
    #$wcnt = count(explode(" ", $value[2]));
    #$wcnt = str_word_count($value[2]);
    $wcnt = substr_count($value[2], " ") + 1;
    if ($wcnt > $wmax) {
      $wmax = $wcnt;
    }
  }
  //print_r("wmax $wmax\n");
  // create lists of matching unresolved links with number 1 .. $wmax
  $lmatches = [];
  for ($i = 1; $i <= $wmax; $i++) {
    $ms = "/➔ ([^<][^ <,;()]+){" . $i . "," . $i . "}/";
    preg_match_all($ms, $text_to, $mmm);
    $lmatches[$i] = $mmm[0];
  }

  // abbreviation matching
  // for each rmatch key find unresolved matching link
  $used = [];
  foreach ($rmatch_from as $key => $value) {
    $wcnt = substr_count($value[2], " ") + 1;
    foreach ($lmatches[$wcnt] as $ltext) {
      if (!abb_equal($ltext, "➔ " . $value[2])) {
        continue;
      }
      $ltext = str_replace("➔ ", "", $ltext);
      $htext = str_replace($value[2], $ltext, $key);
      $text_to = str_replace("➔ " . $ltext, "➔ " . $htext, $text_to);
      $used[] = $key;
      $log = $log . "Doplnený odkaz (skratka): " . $ltext . "\n";
    }
  }
  foreach ($used as $key) {
    unset($rmatch_from[$key]);
  }

  // for each rmatch key find unresolved matching link
  $used = [];
  foreach ($rmatch_from as $key => $value) {
    #$wcnt = count(explode(" ", $value[2]));
    #$wcnt = str_word_count($value[2]);
    $wcnt = substr_count($value[2], " ") + 1;
    $maxperc = 0;
    foreach ($lmatches[$wcnt] as $ltext) {
      $ltext = str_replace("➔ ", "", $ltext);
      $sim = similar_text($ltext, $value[2], $perc);
      if ($perc > $maxperc) {
        $maxperc = $perc;
        $simkey = $key;
        $simltext = $ltext;
      }
    }
    // accept if similarity> 60
    //if ($maxperc > 60){
    //$htext = str_replace($value[2], $simltext, $simkey);
    if ($maxperc > 70) {
      $htext = str_replace(">" . $value[2], ">" . $simltext, $simkey);
      $text_to = str_replace($simltext, $htext, $text_to);
      $used[] = $key;
      $log = $log . "Doplnený odkaz (fuzzy): " . $simltext . "\n";
      //print_r($wcnt . " " .$simkey . " " .$simltext." " . $maxperc." ". $htext ."\n");
    }
  }
  foreach ($used as $key) {
    unset($rmatch_from[$key]);
  }

  //
  // replace unresolved links using rmatch_to (by exact matching)
  foreach ($rmatch_to as $key => $value) {
    if (strpos($text_to, "➔ " . $value[2])) {
      $text_to = str_replace("➔ " . $value[2], "➔ " . $value[0], $text_to);
      $log = $log . "Nezmenený odkaz (nenájdený v zdrojovom texte): " . $value[2] . "\n";
    }
  }

  // remaining from links:
  foreach ($rmatch_from as $key => $value) {
    $log = $log . "Nepoužitý odkaz (nenájdený v cieľovom texte): " . $value[2] . "\n";
  }

  $text_to = str_replace("➔", "—&gt; ", $text_to);
  $text_to = str_replace("—>", "—&gt; ", $text_to);
  $text_to = preg_replace("/ [&]([ .,;)])/", "&amp;$1", $text_to);
  $text_to = preg_replace("/  +/", " ", $text_to); //odstranit opakovane medzery
  $text_to = str_replace("</a></a>", "</a>", $text_to);

  // find the remaining links
  preg_match_all('/—\&gt; [^< ]+/', $text_to, $unresolved);
  foreach ($unresolved[0] as $un) {
    $log = $log . "Nevyriešený odkaz (v cieľovom texte): " . str_replace("&gt;", ">", $un) . "\n";
  }

  //dpm($text_to, "2");
  return [$text_to, $log];
}

/*
 * modify text exported by the 'export' views
 *  to be called from the function  template_process_views_data_export_msoffice_body of
 *  the views_data_export/theme/views_data_export.theme.inc file
 */
function beliana_render_export($viewname, $displayname, $text) {
  $output = $text;
  // Export for printing, path /export
  if ($viewname === 'export' && $displayname === 'views_data_export_1') {
    $output = preg_replace('/<\/?(a|span) ?.*?>/', '', $output); // strip some html tags
    $output = preg_replace('/➔ /', '→ ', $output);
    $output = preg_replace('/➔/', '→ ', $output);
  }
  // Export na tlac, path /export-multi
  else if ($viewname === 'export' && $displayname === 'views_data_export_1') {
    $output = preg_replace('/<\/?(a|span) ?.*?>/', '', $output); // strip 'a' and 'span' tags
  }
  // Export for typographer, path /export-na-sadzbu
  else if ($viewname === 'export_sadzac' && $displayname === 'views_data_export_1') {
    //$output = preg_replace('/➔/', '→ ', $output);
//////////////////////

    // Odstranit html odkazy
    // Odstranit aj sipku, pokial ide o odkaz na heslo, ktore navyslo knizne:
    // 1. ak je typ Heslo a zorad mensi ako  "kokpit"
    // ak je datum vytvorenie hesla vacsie ako  datum vydania zvazka, kam abecedne patri
    $output = preg_replace('/<\/?a ?.*?>/', '', $output); // remove links
    $output = preg_replace('/➔ /', '→ ', $output);
    $output = preg_replace('/➔/', '→ ', $output);
    //$output = preg_replace('/<p>\s*<\/p>/', ' ', $output);

    //  fix LaTeX
    $output = preg_replace('/align\*/', 'align', $output);

    // fix inline images
    global $base_url;
    // in: <src="/sites/dev/files/u1427/kekule.png" style="height:38px; width:33px" />'
    // out: <src="https://beliana.sav.sk/sites/dev/files/u1427/kekule.png" style="height:38px; width:33px" />'
    $output = str_replace('src="/sites','src="'.$base_url.'/sites', $output);
    // in:  style="height:38px; width:33px"
    // out: height="38" width="33"
    $output = preg_replace('/style="height:(\d+)px; width:(\d+)px"/i','height="$1" width="$2"', $output);

    /* Remove funny spaces
    * U+200B zero width space
    * U+200C zero width non-joiner Unicode code point
    * U+200D zero width joiner Unicode code point
    * U+FEFF zero width no-break space Unicode code point
    */
    $output = preg_replace( '/[\x{200B}-\x{200D}\x{FEFF}]/u', '', $output);

    //replace non-breakable space, may break paragraph merging
    $output = str_replace(" ", " ", $output);

/*
    // Remove new paragraph starting with <p><strong>[1-9]
    $output = preg_replace('/<\/p>\s+<p>(<strong>[1-9])/', ' \1', $output);
    // Remove new paragraph starting with <p><em>
    $output = preg_replace('/<\/p>\s+<p>(<em>)/', ' \1', $output);
    // Remove new paragraph starting with <p><span
    $output = preg_replace('/<\/p>\s+<p>(<span)/', ' \1', $output);
    // remove paragraph starting with <p>— , bahamy.html
    $output = preg_replace('/<\/p>\s+<p>—/', ' —', $output);
    // merge paragraph ending  with —<p> ,
    $output = preg_replace('/—[  ]*<\/p>\s+<p>/', '— ', $output);
    // remove new paragraphs not starting with a tag (but not if it is a list item)
    $output = preg_replace('/<\/p>\s+<p>([^< ]* [^-–])/', ' \1', $output);
*/

    // merge paragraphs
    $output = preg_replace("/<\/p>\s+<p>/", " ", $output);

    $output = str_replace('<p>', '<p style="font-family:Arial;font-size:11pt;">', $output);

    $output = preg_replace(
        '/<span class="math-tex">(\\\\\([^<]+\\\\\))<\/span>/',
        '<font color="red">\1</font>',
        $output
    );
    // change order if . and , are inside math
    $output = str_replace('.\)</font>', '\)</font>.', $output);
    $output = str_replace(',\)</font>', '\)</font>,', $output);

    // set table font
    $output = str_replace( 'style="width:100%"', 'style="font-family:Arial;font-size:11pt"', $output);
//////////////////////
    $output = preg_replace('/<\/?(a|span) ?.*?>/', '', $output); // strip some other html tags
    $output = preg_replace('/➔ /', '→ ', $output);
    $output = preg_replace('/➔/', '→ ', $output);
  }
  return $output;
}
