<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rs module.
 */


/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_rs_action_info() {
  return array(
    'beliana_merge' => array(
      'type' => 'entity',
      'label' => t('Merge'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function beliana_rs_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_profile_form':
      //disable browser remember password on user edit form
      $form['account']['current_pass']['#type'] = 'textfield';
      $form['account']['current_pass']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";
      break;
  }
}

/**
 * Implements hook_element_info_alter().
 */
function beliana_rs_element_info_alter(array &$types) {
  if (isset($types['password_confirm'])) {
    $types['password_confirm']['#process'][] = 'beliana_rs_form_process_password_confirm';
  }
}

/**
 * Process the password_confirm element.
 */
function beliana_rs_form_process_password_confirm($element) {
  $element['pass1']['#type'] = $element['pass2']['#type'] = 'textfield';
  $element['pass1']['#attributes']['onfocus'] = $element['pass2']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";

  return $element;
}

/**
 * Callback function for `beliana_merge` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function beliana_merge(&$entity, $context = array()) {
  // If current entity is the first one,
  // create new entity `Heslo` and store its nid into session.
  if ($context['progress']['current'] === 1) {
    $master = new stdClass();
    $master->type = 'heslo';
    node_object_prepare($master);
    $master->title = $entity->title;
    $master->field_text_hesla = array(
      LANGUAGE_NONE => array(
        array(
          'value' => '',
          'format' => 'filtered_html',
        ),
      ),
    );
    $master->field_taxsubor = $entity->field_taxsubor;
    $master->language = 'sk';
    node_save($master);
    $_SESSION['master'] = $master->nid;
  }

  // Load master entity from session.
  $master = node_load($_SESSION['master']);

  // If master entity found, copy fields from current entity into it.
  if ($master != FALSE) {
    // Merge field_lexikalna_skupina.
    foreach ($entity->field_lexikalna_skupina[LANGUAGE_NONE] as $ls) {
      // find the top most parent (set to editor name)
      $parents = taxonomy_get_parents_all($ls['tid']);
      foreach ($parents as $parent) {
        if (count(taxonomy_get_parents_all($parent->tid)) == 1) {
          $top_parent = $parent;
        }
      }

      // store the top most parent (editor name) to field_redaktori_zluceneho
      $found = FALSE;
      if (isset($master->field_redaktori_zluceneho[LANGUAGE_NONE])) {
        foreach ($master->field_redaktori_zluceneho[LANGUAGE_NONE] as $tid) {
          if ($tid['tid'] === $top_parent->tid) {
            $found = TRUE;
          }
        }
      }
      if (!$found) {
        $master->field_redaktori_zluceneho[LANGUAGE_NONE][]['tid'] = $top_parent->tid;
      }
      // We want to preserve the original taxonomy values in further processing.
      $master->field_povodne_lexikalne_skupiny[LANGUAGE_NONE][]['tid'] = $ls;
    }

    // Merge field_komentar_instrukcie, use "\n" as separator.
    if (isset($entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) || empty($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_hesla, use "</p>\n<p>" as separator.
    if (!isset($master->field_text_hesla[LANGUAGE_NONE][0]['value']) || empty($master->field_text_hesla[LANGUAGE_NONE][0]['value'])) {
      $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
    }
    else {
      // special requirement: in merging put GEO articles in front of others
      if ($top_parent->tid === "390") {  // "390" is Lubica Krajcovicova, editor of GEO articles.
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'] . "<p>&nbsp;</p>" . $master->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] .= "<p>&nbsp;</p>" . $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_z_gh, use "\n" as separator.
    if (isset($entity->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_text_z_gh[LANGUAGE_NONE][0]['value']) || empty($master->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] = $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_ilustracia.
    if (!empty($entity->field_ilustracia)) {
      foreach ($entity->field_ilustracia[LANGUAGE_NONE] as $img) {
        $master->field_ilustracia[LANGUAGE_NONE][] = $img;
      }
    }

    // Merge field_atributy, use "\n" as separator.
    if (isset($entity->field_atributy[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_atributy[LANGUAGE_NONE][0]['value']) || empty($master->field_atributy[LANGUAGE_NONE][0]['value'])) {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] = $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] .= "," . $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
    }

    $master->field_zlucene_z[LANGUAGE_NONE][]['target_id'] = $entity->nid;
    node_save($master);

    $entity->field_zlucene_do[LANGUAGE_NONE][0]['target_id'] = $_SESSION['master'];
    # remove links from the original
    _beliana_remove_links($entity);
    // Empty alias for original entity.
    //$entity->path['alias'] = '';
    // Set automatic alias creation to FALSE.
    //$entity->path['pathauto'] = FALSE;
    node_save($entity);
    workbench_moderation_moderate($entity, 'ukoncenezluene');
  }

  // If current entity is the last, make workflow transition.
  if ($context['progress']['current'] === $context['progress']['total']) {
    $master = node_load($_SESSION['master']);
    // Reset fields.
    $master->field_vyplatit = NULL;
    $master->field_errta = NULL;
    $master->field_datum = NULL;
    // Set automatic alias creation to FALSE.
    $master->path['pathauto'] = FALSE;
    // Set field_lexikalna_skupina to `Zlúčené heslo`.
    $term = taxonomy_get_term_by_name('Zlúčené heslo', 'lexikalne_skupiny');
    $term = array_shift($term);
    $master->field_lexikalna_skupina[LANGUAGE_NONE][]['tid'] = $term->tid;
    workbench_moderation_moderate($master, 'zlucene');
    # Synchtonize to the web editorial system
    if ($response = beliana_api_rest_create_node($master, 'rs', "Zlúčené heslo:", "Zlúčené heslo")) {
      $master->field_remote_id[LANGUAGE_NONE][0]['value'] = $response->nid;
    }
    node_save($master);
    $_SESSION['master'] = NULL;
  }
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  // no action required in the beliana_rs module
  //dpm("_beliana_process_links beliana-rs");
}


/*
 * modify links in text due to article merging
 * find links pointing to articles in Ukončené/Zlúčené (ukoncenezluene) state and replace them
 */
function modify_links_merged(&$node) {
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($node->field_text_hesla[LANGUAGE_NONE][0]['value'], 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  foreach ($links as $item) {
    $target = substr($item->getAttribute('href'), 1); // we do not need the leading slash /
    $path = drupal_get_normal_path($target);
    $parts = explode("/", $path);
    if ($parts[0] === 'node') {
      $lnode = node_load($parts[1]); // the linked node
      if ($lnode->workbench_moderation['current']->state == 'ukoncenezluene') {
        // $znode: the node $lnode is merged to
        $znode = node_load($lnode->field_zlucene_do[LANGUAGE_NONE][0]['target_id']);
        $newpath = $znode->path['alias'];
        // replace including the closing '"' to make the replacement string unique
        $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = str_replace($target . '"', $newpath . '"', $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
        watchdog('aktualizovany odkaz', 'Heslo "' . $node->title . '": aktualizovaný odkaz na zlúčené heslo (z <a href="/' . $target . '">' . $target . '</a> na <a href="/' . $newpath . '">' . $newpath . '</a>)');
      }
    }
  }
}

/*
 * Handle special transitions in the book workflow
 */
function handle_special_transitions(&$values) {
  // ensure corect state transitions if article is merged from other articles
  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;
  if (isset($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    // starting '1_korektura:' copy editor names to field_spravit_1_korekturu
    if (($cur_state === 'na_jazykovu_korekturu' && $new_state === '1_korektura'))
      _start_korektura($values);

    // transition 1_korektura >> u_vyst_redaktora_4
    if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_4') {
      dpm("1. korektura >> u_vyst_redaktora_4 trans");
      _transition_korektura($values, "1_korektura");
    }

    // update links in nodes referencing the merged articles (in zlucene >> u_jaz_redaktora_1 transition)
    if ($cur_state === 'zlucene' && $new_state === 'na_jazykovu_korekturu') {
      dpm("zlucene >> u_jaz_redaktora_1transitio");
      foreach ($values['node']->field_zlucene_z[LANGUAGE_NONE] as $item) {
        $query = db_query('SELECT node.nid AS nid FROM {node} node INNER JOIN {search_node_links} links ON node.nid = links.sid WHERE links.nid = :nid', array(':nid' => $item['target_id']));
        $result = $query->fetchAll();

        if (!empty($result)) {
          foreach ($result as $backlink) {
            if ($source = node_load($backlink->nid)) {
              node_save($source);
            }
          }
        }
      }
    }

    // Po vybaveni 2. korektury zmazat az po XX
    $run_as_1_korektura = true;  // choose between two ways how to run 2_korekt_ra - FIXME needs workflow change
    if ($run_as_1_korektura) { // 2_korekt_ra: the same procedure as 1_korektura
      // starting 'korektura': copy editor names to field_spravit_1_korekturu
      if (($cur_state === 'u_vyst_redaktora_3' && $new_state === '2_korekt_ra'))
        _start_korektura($values);

      // transition 2_korekt_ra >> u_vyst_redaktora_4
      if ($cur_state === '2_korekt_ra' && $new_state === 'u_vyst_redaktora_4')
        _transition_korektura($values, "2_korekt_ra");
    }
    else // korekt_ra: version with only one editor selected
      _run_2_korektura_single($values);
    //XX

    node_save($values['node']);
    return;
  }
}

/**
 * Helper function: start 'korektura'
 */
function _start_korektura(&$values) {
  // copy editor names to field_spravit_1_korekturu
  foreach ($values['node']->field_redaktori_zluceneho['und'] as $redaktor)
    $values['node']->field_spravit_1_korekturu['und'][]['tid'] = $redaktor['tid'];
  // take the next editor
  $values['node']->field_lexikalna_skupina['und'] = array();
  $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_korektura(&$values, $korektura) {
  if (!empty($values['node']->field_spravit_1_korekturu['und'])) {
    // return back to '$korektura'
    $values['node']->workbench_moderation_state_new = $korektura;
    // take the next editor
    $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
  }
  else {
    // we are done, restore the initial status
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function: transition to 2_korekt_ra
 */
function _run_2_korektura_single(&$values) {
  if ($values['state'] === '2_korekt_ra') {
    if (count($values['node']->field_lexikalna_skupina['und']) != 1) {
      //MS drupal_set_message('Ako lexikálnu skupinu zadajte meno požadovaného redaktora.', 'error');
      drupal_set_message('Heslo je zlúčené a má viacero lexikálnych skupín. Pri odosielaní na 2. korektúru však heslo môže mať len jednu lexikálnu skupinu.', 'error');
      drupal_set_message('Lexikálne skupiny upravte, heslo uložte a potom odošlite na 2. korektúru ešte raz. Po návrate z 2. korektúry sa lexikálne skupiny vrátia do pôvodného stavu.', 'error');
      $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
    }
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_vyst_redaktora_4' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U výstupného redaktora 4. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_jaz_redaktora_2' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U jazykového redaktora 2. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  if ($values['node']->workbench_moderation['current']->state === '2_korekt_ra' && $values['state'] === 'u_vyst_redaktora_3') {
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

// check if illustration should go to web
// dummy function here, used only in the web version
function il_display_on_web(&$ilu_node)
{
  return false;
}

/**
 * Callback function for `workbench_moderation_moderate_form` submit.
 *
 * @inheritdoc
 */
function rs_beliana_workflow_reaction(&$form, &$form_state) {
  $values = $form_state['values'];
  if (!isset($values['node']->workbench_moderation['current']->state)) {
    return;
  }

  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;

  //Handle special transitions in the book workflow
  handle_special_transitions($values);

  // check type heslo and importovane heslo 
  // (in RS importovane heslo is not processed and in WEBRS is processed (nearly) equaly as heslo)
  if ($values['node']->type === 'heslo' || $values['node']->type === 'importovane_heslo' ) {
    $fail = FALSE;
    // do not change state if LITE changes exist
    $publish_states = ["na_opakovane_zverejnenie", "na_zalomenie", "importovane_na_zverejnenie"];
    if (in_array($new_state, $publish_states)) {
      $text = $values['node']->field_text_hesla['und'][0]['value'];
      if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
        $fail = TRUE;
        drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . '</a> nebol zmenený, lebo v jeho texte sú uložené LITE zmeny', 'error');
      }
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $texttab = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (strpos($texttab, "ice-ins") or strpos($texttab, "ice-del")) {
          $fail = TRUE;
          drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo v poli 'Tabuľka pre geografické heslá' sú uložené LITE zmeny", 'error');
        }
      }
    }
    // check if payment information is stored
    if (($cur_state === "needs_review" && $new_state === "na_zverejnenie") && // u redaktora state u vr1/vr state transition
      _display_payment_fields($values['node']) == "showeditable") {
      $fail = TRUE;
      drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo nie je vyplnené pole 'Vyplatenie odmeny'", 'error');
    }

    // check "lexikalna skupina"
    if ($cur_state === "u_jaz_redaktora1" && $new_state === "u_vyst_redaktora2") { // u jt state > u vr2 state transition
      $tids = [];
      foreach ($values['node']->field_lexikalna_skupina[LANGUAGE_NONE] as $value) {
        $tids[] = $value['tid'];
      }

      if (in_array(827, $tids)) { //827 = "Zlúčené heslo"
        $fail = TRUE;
        drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo zlúčené heslá nemôžu byť v stave 'U výst. redaktora 2", 'error');
      }
    }

    if ($fail) {
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    # remove links from text of artices in state 'vyradene'
    if (in_array($new_state, ['vyradene']) and strpos($values['node']->field_text_hesla['und'][0]['value'], '</a>')) {
      _beliana_remove_links($values['node']);
      node_save($values['node']);
    }
  }

  // check types heslo and importovane_heslo, ignore for authors
  if (!($cur_state === "u_autora" and $new_state === "needs_review")) {
    if ($values['node']->type === 'importovane_heslo' or $values['node']->type === 'heslo') {
      // Check link correctness
      $skip = FALSE;
      if (!_check_links($values['node'])) {
        $skip = TRUE;
      }
      if ($new_state === 'vyradene') {
        if (!_check_transition_to_vyradene($values['node'])) {
          $skip = TRUE;
        }
      }
      // Check alternative text marker correctness in article body
      if (!_check_alternative_text_markers($values['node'], $values['node']->field_text_hesla['und'][0]['value'], "v hesle")) {
        $skip = TRUE;
      }
      // Check alternative text marker correctness in article table
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $text_table = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (!_check_alternative_text_markers($values['node'], $text_table, "v tabuľke pre geografické údaje hesla")) {
          $skip = TRUE;
        }
      }
      if ($skip) {
        drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
        $values['node']->workbench_moderation_state_new = $cur_state;
        node_save($values['node']);
        return;
      }
    }
  }

  // check illustration state on transition of 'importovane_heslo' to state 'importovane_u_jr2'
  if ($values['node']->type === 'importovane_heslo' and $new_state == 'importovane_u_jr2') {
    $skip = FALSE;
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    $skip = !check_ill_at_node_transition($values['node'], $ok_states, 'state change');
    if ($skip) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // restore id of the node author from the saved value
  if (($cur_state === "u_konzultanta" and $new_state === "needs_review"))
  {
    if (isset($values['node']->field_uid_autora['und'])) {
      $values['node']->uid = $values['node']->field_uid_autora['und'][0]['value'];
      unset($values['node']->field_uid_autora['und']);
      node_save($values['node']);
    }
  }

  // check illustrations
  if ($values['node']->type === 'ilustracia') {
    $skip = FALSE;
    if ($cur_state == 'ilustracia_u_redaktora' and $new_state == 'ilustracia_u_vyst_redaktora_5') {
      $ilu_node = $values['node'];

      // temporarily disabled
      //if (!_check_ilu_attached($ilu_node, 'state change')) {
        //$skip = TRUE;
      //}

      //if (!_check_field_pouzit($ilu_node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // ignore illustrations, which are not intended for web
      if (il_display_on_web($ilu_node)) { //false always returned in the print version
        if (is_null(_check_illustration_web($ilu_node, $ilu_node, 'state change'))) {
          $skip = TRUE;
        }
      }
    }

    // a problem with illustration, keep the current state
    if ($skip) {
      drupal_set_message('<strong>Stav ilustrácie nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    else {
      $values['node']->field_datum_zverejnenia[LANGUAGE_NONE][0]['value'] = date('Y-m-d H:i:s');
      node_save($values['node']);
    }
  }
}

/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */

function beliana_group_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    if ($term->depth == 0) {
      $output .= '<h1>' . $term->name . '</h1>';
    }
    else {
      //$output .= '<h3> Lexikálna skupina: <em>' . $term->name . '</em></h3>';
      $output .= '<strong>' . $term->name . '</strong>';
      $output .= '<ul>';
      foreach ($users as $user) {
        if (isset($user->workbench_access[$term->tid])) {
          $output .= '<li>'
            . $user->name . ', '
            . $user->field_meno['und'][0]['value'] . ', '
            . $user->field_priezvisko['und'][0]['value'] . ', ';
          if (isset($user->field_autorska_zmluva['und'])) {
            $output .= $user->mail . ', '
              . $user->field_autorska_zmluva['und'][0]['value'] . '</li>';
          }
          else {
            $output .= $user->mail . '</li>';
          }
        }
      }
      //$output .= '</ul><br><br>';
      $output .= '</ul>';
    }
  }
  return $output;
}

/**
 * access callback for beliana_editor_list
 */
function beliana_editor_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Redaktor",
    "Správca heslára",
    "Výstupný redaktor 1",
    "administrátor",
    "Výstupný redaktor 2",
    "Výstupný redaktor 2X",
    "useradmin",
    "Výstupný redaktor 3",
    "Výstupný redaktor 4",
    "Výstupný redaktor 5",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * access callback for beliana_group_list
 */
function beliana_group_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "administrátor",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

// transfer node from the web editorial system
// $node: current node
// $remote_node: remote node (data)
function beliana_sync_from_remote_build($node, $remote_node) {
  global $user;

  // remote accept states
  $heslo_accept_states = ['publikovane_na_webe'];
  $heslo_accept_states_hr = ['Zverejnené na webe'];	// human readable
  $ilu_accept_states = ['ilustracia_na_webe'];
  $ilu_accept_states_hr = ['Ilustrácia na webe'];	// human readable

  $local_site = "rs";
  $remote_site = "webrs";
  $local_uri = variable_get('base_url');
  $remote_uri = variable_get('rs_api_uri');

  // accept content if remote is in the accept state
  if (in_array($remote_node->workbench_moderation->current->state, array_merge($heslo_accept_states,$ilu_accept_states)))
  {
    // fields ignored or treated in a special way
    $fields_to_skip = [
      'field_remote_id',      // keep local value
      'field_datum_prebratia',// set here
      'field_ilustracia',     // special processing
      'field_zlucene_z',      // ignored
      'field_zlucene_do',     // ignored
      'field_text_hesla',     // special processing
      'field_komentar_instrukcie',   // special processing
      'field_datum_autorovho_textu', // special processing 
      'field_text_z_gh',      // ignored
      'field_povodne_lexikalne_skupiny',   // ignored
      'field_redaktori_zluceneho',   // ignored
      'field_atributy',      // ignored
    ];

    // transfer field values from remote node to local node
    foreach ($remote_node as $field => $data) {
      $remote_field_value = empty($data) ? '' : json_decode(json_encode($data), TRUE);

      // copy value except for the skipped ones
      if (($field == 'uid' || $field == 'title' || strpos($field, 'field_') === 0) && !in_array($field, $fields_to_skip)) {
        $node->{$field} = $remote_field_value;
      }

      // fetch inline images and update their paths in text
      if ($field == 'field_text_hesla') {
        // find <img tags
        // "[>]" used in the regexp to make the vim editor happy, otherwise '>' is OK
        $matches = [];
        preg_match_all('/<img.*?src=[\'"](.*?)[\'"].*?[>]/i', $remote_field_value[LANGUAGE_NONE][0]['value'], $matches);

        // fetch and update
        if (!empty($matches)) {
          foreach ($matches[1] as $src) {
            $data = file_get_contents($remote_uri . $src);
            $new_src = str_replace($remote_site, $local_site, $src);
            $file = file_save_data($data, str_replace('/sites/' . $local_site . '/files/', 'public://', $new_src), FILE_EXISTS_REPLACE);

            $remote_field_value[LANGUAGE_NONE][0]['value'] = str_replace('src="' . $src, 'src="' . $new_src, $remote_field_value[LANGUAGE_NONE][0]['value']);
            $remote_field_value[LANGUAGE_NONE][0]['safe_value'] = str_replace('src="' . $src, 'src="' . $new_src, $remote_field_value[LANGUAGE_NONE][0]['safe_value']);
          }
        }
        $node->field_text_hesla = $remote_field_value;
      }

      if ($field == 'field_datum_autorovho_textu' and $remote_field_value ) {
        $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = '1970-01-01 00:00:00';
      } else {
        unset($node->field_datum_autorovho_textu[LANGUAGE_NONE]);
      }

      if ($field == 'field_komentar_instrukcie') {
        $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = "Obsah prevzatý z webového RS " . date('Y-m-d').".";

        if (!empty($remote_field_value)) {
          $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $remote_field_value[LANGUAGE_NONE][0]['value'];
        }
      }

      // only for 'ilustracia', transfer image files
      if (in_array($field, [ 'field_subor_ilustracie', 'field_obrazok_navrh_', 'field_original', ])) {
        if (!empty($remote_field_value)) {
          if (isset($node->{$field}[LANGUAGE_NONE]) ) $node->{$field}[LANGUAGE_NONE] = [];
          // get the file(s)
          foreach ($remote_field_value[LANGUAGE_NONE] as $key => $remote_file) {
            $data = file_get_contents($remote_uri . '/sites/' . $remote_site . '/files' . str_replace('public:/', '', $remote_file['uri']));
            $file = file_save_data($data, $remote_file['uri'], FILE_EXISTS_REPLACE);

            $node->{$field}[LANGUAGE_NONE][$key] = [
              'fid' => $file->fid,
              'uid' => $file->uid,
              'filename' => $file->filename,
              'uri' => $file->uri,
              'filemime' => $file->filemime,
              'filesize' => $file->filesize,
              'status' => 1,
              'display' => 1,
              'description' => '',
            ];
          }
        }
      }

      // fields containing identifiers of other nodes.
      // It is necessary to check the 'field_remote_id' of the referenced node to get the correct local nid
      // we do not sync ilustracia bundle referenced here, ilustracia should be synced directly like nodes
      if (in_array($field, [ 'field_ilustracia'])) {
        $node->{$field}[LANGUAGE_NONE] = [];

        if (!empty($remote_field_value)) {
          foreach ($remote_field_value[LANGUAGE_NONE] as $delta => $target) {
            // fetch the remote node
            if ($target_remote_node = beliana_api_rest_get_node($target['target_id'])) {
              // if 'empty()' node ids on both sides are equal, so use target_remote_node->nid.
              $node->{$field}[LANGUAGE_NONE][$delta]['target_id'] =
                empty($target_remote_node->field_remote_id->und) ? $target_remote_node->nid : $target_remote_node->field_remote_id->und[0]->value;
            }
          }
        }
      }
    }

    $node->field_datum_prebratia = [LANGUAGE_NONE => [['value' => date('Y-m-d H:i:s')]]];
    $node->revision = 1;

    // specify the new node state
    if ($node->type == 'ilustracia') {
      $moderate_to = 'ilustracia_u_redaktora';
    } else {  
      $moderate_to = 'needs_review';
    }

    $message_log = format_string('Obsah prevzatý z webového RS (@d, @u)', ['@d'=>date('Y-m-d'), '@u'=>$user->name]);
    if (strpos($node->log, $message_log) === FALSE) {
      $node->log = $message_log;
    }

    workbench_moderation_moderate($node, $moderate_to);
    drupal_set_message(format_string('Obsah položky <a href="@url/node/@id">@title</a> bol úspešne prebratý, nový stav: @state', [
      '@url' => $local_uri,
      '@title' => $remote_node->title,
      '@id' => $remote_node->nid,
      '@state' => $moderate_to
    ]));
  }
  else
  {
    if ($node->type == 'ilustracia') {
      drupal_set_message(format_string('Nepodarilo sa prevziať obsah ilustrácie <a href="@url/node/@id">@title</a> (vo webovom RS nie je v stave @state)', [
        '@url' => $remote_uri,
        '@title' => $remote_node->title,
        '@id' => $remote_node->nid,
        '@state' => implode(", ", $ilu_accept_states_hr)
      ]), 'warning');
    } else {
      drupal_set_message(format_string('Nepodarilo sa prevziať obsah hesla <a href="@url/node/@id">@title</a> (vo webovom RS nie je v stave @state)', [
        '@url' => $remote_uri,
        '@title' => $remote_node->title,
        '@id' => $remote_node->nid,
        '@state' => implode(", ", $heslo_accept_states_hr)
      ]), 'warning');
    }
  }
}

// decides if the "Prebrať obsah" menu item is displayed
function beliana_sync_from_remote_access($node) {
  global $user;

  // Access rights must be set in /admin/config/workbench/access/ (even for administrator)
  // returns 'deny' or Null
  $response = workbench_access_node_access($node, 'update', $user);
  if ($response != NODE_ACCESS_DENY && user_access('sync heslo content')) {
    switch ($node->type) {
      case 'heslo':
        return in_array($node->workbench_moderation['current']->state, [
          'zaradene', // As articles in webrs already have assigned author, synced articles will be moderated to the state 'needs_review' (U redaktora)
        ]);
      case 'ilustracia':
        return in_array($node->workbench_moderation['current']->state, ['ilustracia_u_redaktora']);
    }
  }

  return FALSE;
}


// check if field related to payment should be displayed, and if, then how (editable, noneditable)
// return strings hideall enableall or showeditable
function _display_payment_fields(&$node) {
  #do not show the fields for new items
  if (!isset($node->nid)) {
    #dpm("hideall (nove heslo)", "display_payment_fields");
    return "hideall";
  }

  #do not show the fields for merged (zlucene) articles (i. e. field_zlucene_z is nonempty)
  if (isset($node->field_zlucene_z[LANGUAGE_NONE][0])) {
    #dpm("hideall (merged)", "display_payment_fields");
    return "hideall";
  }

  global $user;
  $curstate = $node->workbench_moderation['current']->state;
  //dpm($user);
  // administrator has access to everything
  if (in_array("administrátor", $user->roles)) { // $form: node
    #dpm("enableall", "display_payment_fields");
    return "enableall";
  }

  // do not show in the case of nodes imported from files Kolembus-00* and Komunikator-00*
  if (
    (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Kolembus-00') !== FALSE)
    or (isset($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) and
      strpos($node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'], 'import Komunikator-00') !== FALSE)
  ) {
    #dpm("hideall (import)", "display_payment_fields");
    return "hideall";
  }

  // if filled out, field_datum_autorovho_textu is set.  Just show, do not edit
  if (isset($node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'])) {
    #dpm("showdisabled (filled out)", "display_payment_fields, field_datum_autorovho_textu is set");
    return ("showdisabled");
  }
  //state of the node changed from vr1 or vr2 state to needs_review after 11.11.2018
  if (has_vr_to_r_transition($node)) {
    #dpm("hideall (has transition)", "display_payment_fields");
    return ("hideall");
  }
  if ($curstate === 'needs_review') {
    #dpm("showeditable (no transition, needs_review)", "display_payment_fields");
    return ("showeditable");
  }
  else {
    #dpm("hideall (no transition, no needs_review)", "display_payment_fields");
    return ("hideall");
  }
}

/*
  Check, if the node was sent to the needs_review state after 11.11.2018
  the node IS in the state needs_review (U redaktora) since only role Redaktor can edit the payment information
  find date (tstamp) of the latest of transitions na_zalomenie >> needs_review
  compare tstamp with the date 11.11.2018 (reftime) (on that day payment data was manuall exported)
  if tstamp > refdate return True (do not display payment fields). We have manually exported payment data
  if tstamp < refdate return False (edit payment fields). We do not have payment data
 */

function has_vr_to_r_transition(&$node) {

  // find transitions na_zverejnenie >> needs_review
  $reftime = strtotime("11-11-2018"); // date of manual accounting data export
  $transitions = db_select('workbench_moderation_node_history', 'w')
    ->fields('w') // all fields
    ->condition('from_state', 'na_zverejnenie') // u vyst. redaktor 1 state
    ->condition('state', 'needs_review')  // u redaktora state
    ->condition('nid', $node->nid)
    ->execute()
    ->fetchAll();
  // find the most recent transition
  $tstamp1 = 0;
  foreach ($transitions as $tr) {
    if ($tr->stamp > $tstamp1) { // find the most recent transition
      $tstamp1 = $tr->stamp;
    }
  }

  // find transitions u_vyst_redaktora_2 >> needs_review
  $transitions = db_select('workbench_moderation_node_history', 'w')
    ->fields('w') // all fields
    ->condition('from_state', 'u_vyst_redaktora_2')  // u redaktora state
    ->condition('state', 'needs_review')  // u vr1 state
    ->condition('nid', $node->nid)  // u vr1 state
    ->execute()
    ->fetchAll();
  // find the most recent transition
  $tstamp2 = 0;
  if (!empty($transitions)) {
    foreach ($transitions as $tr) {
      if ($tr->stamp > $tstamp2) { // find the most recent transition
        $tstamp2 = $tr->stamp;
      }
    }
  }
  $tstamp = max($tstamp1, $tstamp2);
  #dpm(date("m.d.Y",$tstamp), date("m.d.Y",$reftime));
  return $tstamp > $reftime;
}
