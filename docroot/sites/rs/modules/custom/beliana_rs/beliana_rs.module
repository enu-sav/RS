<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rs module.
 */


/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_rs_action_info() {
  return array(
    'beliana_merge' => array(
      'type' => 'entity',
      'label' => t('Merge'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Callback function for `beliana_merge` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function beliana_merge(&$entity, $context = array()) {
  // If current entity is the first one,
  // create new entity `Heslo` and store its nid into session.
  if ($context['progress']['current'] === 1) {
    $master = new stdClass();
    $master->type = 'heslo';
    node_object_prepare($master);
    $master->title = $entity->title;
    $master->field_text_hesla = array(
      LANGUAGE_NONE => array(
        array(
          'value' => '',
          'format' => 'filtered_html',
        ),
      ),
    );
    $master->field_taxsubor = $entity->field_taxsubor;
    $master->language = 'sk';
    node_save($master);
    $_SESSION['master'] = $master->nid;
  }

  // Load master entity from session.
  $master = node_load($_SESSION['master']);

  // If master entity found, copy fields from current entity into it.
  if ($master != FALSE) {
    // Merge field_lexikalna_skupina.
    foreach ($entity->field_lexikalna_skupina[LANGUAGE_NONE] as $ls) {
      // find the top most parent (set to editor name) 
      $parents = taxonomy_get_parents_all($ls['tid']);
      foreach ($parents as $parent) {
        if (count(taxonomy_get_parents_all($parent->tid)) == 1) {
          $top_parent = $parent;
        }
      }

      // store the top most parent (editor name) to field_redaktori_zluceneho
      $found = FALSE;
      if (isset($master->field_redaktori_zluceneho[LANGUAGE_NONE])) {
        foreach ($master->field_redaktori_zluceneho[LANGUAGE_NONE] as $tid) {
          if ($tid['tid'] === $top_parent->tid) {
            $found = TRUE;
          }
        }
      }
      if (!$found) {
        $master->field_redaktori_zluceneho[LANGUAGE_NONE][]['tid'] = $top_parent->tid;
      }
      // We want to preserve the original taxonomy values in further processing.
      $master->field_povodne_lexikalne_skupiny[LANGUAGE_NONE][]['tid'] = $ls;
    }

    // Merge field_komentar_instrukcie, use "\n" as separator.
    if (isset($entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) || empty($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_hesla, use "</p>\n<p>" as separator.
    if (!isset($master->field_text_hesla[LANGUAGE_NONE][0]['value']) || empty($master->field_text_hesla[LANGUAGE_NONE][0]['value'])) {
      $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
    }
    else {
      // special requirement: in merging put GEO articles in front of others
      if ($top_parent->tid === "390") {  // "390" is Lubica Krajcovicova, editor of GEO articles. 
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'] . "<p>&nbsp;</p>" . $master->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] .= "<p>&nbsp;</p>" . $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_z_gh, use "\n" as separator.
    if (isset($entity->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_text_z_gh[LANGUAGE_NONE][0]['value']) || empty($master->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] = $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_ilustracia.
    if (!empty($entity->field_ilustracia)) {
      foreach ($entity->field_ilustracia[LANGUAGE_NONE] as $img) {
        $master->field_ilustracia[LANGUAGE_NONE][] = $img;
      }
    }

    // Merge field_atributy, use "\n" as separator.
    if (isset($entity->field_atributy[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_atributy[LANGUAGE_NONE][0]['value']) || empty($master->field_atributy[LANGUAGE_NONE][0]['value'])) {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] = $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] .= "," . $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
    }

    // Check if entity has moderation state history: u_vyst_redaktora_2x >> u_vyst_redaktora_2
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $entity->nid)
        ->execute()
        ->fetchAll();

    // If master has state u_vyst_redaktora_2x, write to merged entity as attribute
    if (!empty($transitions)) {
      $master->field_atributy[LANGUAGE_NONE][0]['value'] = 'VR2X';
    }

    $master->field_zlucene_z[LANGUAGE_NONE][]['target_id'] = $entity->nid;
    node_save($master);

    $entity->field_zlucene_do[LANGUAGE_NONE][0]['target_id'] = $_SESSION['master'];
    // Empty alias for original entity.
    //$entity->path['alias'] = '';
    // Set automatic alias creation to FALSE.
    //$entity->path['pathauto'] = FALSE;
    node_save($entity);
    workbench_moderation_moderate($entity, 'ukoncenezluene');
  }

  // If current entity is the last, make workflow transition.
  if ($context['progress']['current'] === $context['progress']['total']) {
    $master = node_load($_SESSION['master']);
    // Reset fields.
    $master->field_vyplatit = NULL;
    $master->field_errta = NULL;
    $master->field_datum = NULL;
    // Set automatic alias creation to FALSE.
    $master->path['pathauto'] = FALSE;
    // Set field_lexikalna_skupina to `Zlúčené heslo`.
    $term = taxonomy_get_term_by_name('Zlúčené heslo', 'lexikalne_skupiny');
    $term = array_shift($term);
    $master->field_lexikalna_skupina[LANGUAGE_NONE][]['tid'] = $term->tid;
    workbench_moderation_moderate($master, 'zlucene');
    # Synchtonize to the web editorial system
    if ($response = beliana_api_rest_node($master, 'rs', "Zlúčené heslo:")) {
      $master->field_remote_id[LANGUAGE_NONE][0]['value'] = $response->nid;
    }
    node_save($master);
    $_SESSION['master'] = NULL;
  }
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  // no action required in the beliana_rs module
  //dpm("_beliana_process_links beliana-rs");
}


/*
 * modify links in text due to article merging
 * find links pointing to articles in Ukončené/Zlúčené (ukoncenezluene) state and replace them
 */
function modify_links_merged(&$node) {
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($node->field_text_hesla[LANGUAGE_NONE][0]['value'], 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  foreach ($links as $item) {
    $target = substr($item->getAttribute('href'), 1); // we do not need the leading slash /
    $path = drupal_get_normal_path($target);
    $parts = explode("/", $path);
    if ($parts[0] === 'node') {
      $lnode = node_load($parts[1]); // the linked node
      if ($lnode->workbench_moderation['current']->state == 'ukoncenezluene') {
        // $znode: the node $lnode is merged to
        $znode = node_load($lnode->field_zlucene_do[LANGUAGE_NONE][0]['target_id']);
        $newpath = $znode->path['alias'];
        // replace including the closing '"' to make the replacement string unique
        $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = str_replace($target . '"', $newpath . '"', $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
        watchdog('aktualizovany odkaz', 'Heslo "' . $node->title . '": aktualizovaný odkaz na zlúčené heslo (z <a href="/' . $target . '">' . $target . '</a> na <a href="/' . $newpath . '">' . $newpath . '</a>)');
      }
    }
  }
}

/*
 * Handle special transitions in the book workflow
 */
function handle_special_transitions(&$values) {
  // ensure corect state transitions if article is merged from other articles
  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;
  if (isset($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    // starting '1_korektura:' copy editor names to field_spravit_1_korekturu
    if (($cur_state === 'na_jazykovu_korekturu' && $new_state === '1_korektura'))
      _start_korektura($values);

    // transition 1_korektura >> u_vyst_redaktora_3 
    if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
      _transition_korektura($values, "1_korektura");
    }

    // update links in nodes referencing the merged articles (in zlucene >> u_jaz_redaktora_1 transition)
    if ($cur_state === 'zlucene' && $new_state === 'na_jazykovu_korekturu') {
      dpm("zlucene >> u_jaz_redaktora_1transitio");
      foreach ($values['node']->field_zlucene_z[LANGUAGE_NONE] as $item) {
        $query = db_query('SELECT node.nid AS nid FROM {node} node INNER JOIN {search_node_links} links ON node.nid = links.sid WHERE links.nid = :nid', array(':nid' => $item['target_id']));
        $result = $query->fetchAll();

        if (!empty($result)) {
          foreach ($result as $backlink) {
            if ($source = node_load($backlink->nid)) {
              node_save($source);
            }
          }
        }
      }
    }

    $run_as_1_korektura = true;  // choose between two ways how to run 2_korekt_ra - FIXME needs workflow change 
    if ($run_as_1_korektura) { // 2_korekt_ra: the same procedure as 1_korektura
      // starting 'korektura': copy editor names to field_spravit_1_korekturu
      if (($cur_state === 'u_vyst_redaktora_3' && $new_state === '2_korekt_ra'))
        _start_korektura($values);

      // transition 2_korekt_ra >> u_vyst_redaktora_4 
      if ($cur_state === '2_korekt_ra' && $new_state === 'u_vyst_redaktora_4')
        _transition_korektura($values, "2_korekt_ra");
    }
    else // korekt_ra: version with only one editor selected
      _run_2_korektura_single($values);
    node_save($values['node']);
    return;
  }

  // transition 1_korektura >> u_vyst_redaktora_3 
  if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
    _transition_vr2x($values);
    node_save($values['node']);
  }
}

/**
 * Helper function: start 'korektura'
 */
function _start_korektura(&$values) {
  // copy editor names to field_spravit_1_korekturu
  foreach ($values['node']->field_redaktori_zluceneho['und'] as $redaktor)
    $values['node']->field_spravit_1_korekturu['und'][]['tid'] = $redaktor['tid'];
  // take the next editor
  $values['node']->field_lexikalna_skupina['und'] = array();
  $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_korektura(&$values, $korektura) {
  if (!empty($values['node']->field_spravit_1_korekturu['und'])) {
    // return back to '$korektura'
    $values['node']->workbench_moderation_state_new = $korektura;
    // take the next editor
    $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
  }
  else {
    _transition_vr2x($values);
    // we are done, restore the initial status
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_vr2x(&$values) {
  // check if "heslo" was already seen by vr2x
  $already_seen_by_vr2x = FALSE;
  if (empty($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $values['node']->nid)
        ->execute()
        ->fetchAll();

    $already_seen_by_vr2x = !empty($transitions);
  }
  else {
    if (!empty($values['node']->field_atributy[LANGUAGE_NONE])) {
      $already_seen_by_vr2x = $values['node']->field_atributy[LANGUAGE_NONE][0]['value'] == 'VR2X';
    }
  }

  // if seen, move to vr4
  if ($already_seen_by_vr2x) {
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_4';
  }
}

/**
 * Helper function: transition to 2_korekt_ra
 */
function _run_2_korektura_single(&$values) {
  if ($values['state'] === '2_korekt_ra') {
    if (count($values['node']->field_lexikalna_skupina['und']) != 1) {
      //MS drupal_set_message('Ako lexikálnu skupinu zadajte meno požadovaného redaktora.', 'error');
      drupal_set_message('Heslo je zlúčené a má viacero lexikálnych skupín. Pri odosielaní na 2. korektúru však heslo môže mať len jednu lexikálnu skupinu.', 'error');
      drupal_set_message('Lexikálne skupiny upravte, heslo uložte a potom odošlite na 2. korektúru ešte raz. Po návrate z 2. korektúry sa lexikálne skupiny vrátia do pôvodného stavu.', 'error');
      $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
    }
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_vyst_redaktora_4' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U výstupného redaktora 4. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_jaz_redaktora_2' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U jazykového redaktora 2. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  if ($values['node']->workbench_moderation['current']->state === '2_korekt_ra' && $values['state'] === 'u_vyst_redaktora_3') {
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}
