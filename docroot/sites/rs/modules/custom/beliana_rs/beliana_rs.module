<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rs module.
 */


/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_rs_action_info() {
  return array(
    'beliana_merge' => array(
      'type' => 'entity',
      'label' => t('Merge'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function beliana_rs_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_profile_form':
      //disable browser remember password on user edit form
      $form['account']['current_pass']['#type'] = 'textfield';
      $form['account']['current_pass']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";
      break;
  }
}

/**
 * Implements hook_element_info_alter().
 */
function beliana_rs_element_info_alter(array &$types) {
  if (isset($types['password_confirm'])) {
    $types['password_confirm']['#process'][] = 'beliana_rs_form_process_password_confirm';
  }
}

/**
 * Process the password_confirm element.
 */
function beliana_rs_form_process_password_confirm($element) {
  $element['pass1']['#type'] = $element['pass2']['#type'] = 'textfield';
  $element['pass1']['#attributes']['onfocus'] = $element['pass2']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";

  return $element;
}

/**
 * Callback function for `beliana_merge` action.
 *
 * @inheritdoc
 *
 * @see beliana_action_info
 */
function beliana_merge(&$entity, $context = array()) {
  // If current entity is the first one,
  // create new entity `Heslo` and store its nid into session.
  if ($context['progress']['current'] === 1) {
    $master = new stdClass();
    $master->type = 'heslo';
    node_object_prepare($master);
    $master->title = $entity->title;
    $master->field_text_hesla = array(
      LANGUAGE_NONE => array(
        array(
          'value' => '',
          'format' => 'filtered_html',
        ),
      ),
    );
    $master->field_taxsubor = $entity->field_taxsubor;
    $master->language = 'sk';
    node_save($master);
    $_SESSION['master'] = $master->nid;
  }

  // Load master entity from session.
  $master = node_load($_SESSION['master']);

  // If master entity found, copy fields from current entity into it.
  if ($master != FALSE) {
    // Merge field_lexikalna_skupina.
    foreach ($entity->field_lexikalna_skupina[LANGUAGE_NONE] as $ls) {
      // find the top most parent (set to editor name)
      $parents = taxonomy_get_parents_all($ls['tid']);
      foreach ($parents as $parent) {
        if (count(taxonomy_get_parents_all($parent->tid)) == 1) {
          $top_parent = $parent;
        }
      }

      // store the top most parent (editor name) to field_redaktori_zluceneho
      $found = FALSE;
      if (isset($master->field_redaktori_zluceneho[LANGUAGE_NONE])) {
        foreach ($master->field_redaktori_zluceneho[LANGUAGE_NONE] as $tid) {
          if ($tid['tid'] === $top_parent->tid) {
            $found = TRUE;
          }
        }
      }
      if (!$found) {
        $master->field_redaktori_zluceneho[LANGUAGE_NONE][]['tid'] = $top_parent->tid;
      }
      // We want to preserve the original taxonomy values in further processing.
      $master->field_povodne_lexikalne_skupiny[LANGUAGE_NONE][]['tid'] = $ls;
    }

    // Merge field_komentar_instrukcie, use "\n" as separator.
    if (isset($entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value']) || empty($master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'])) {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_hesla, use "</p>\n<p>" as separator.
    if (!isset($master->field_text_hesla[LANGUAGE_NONE][0]['value']) || empty($master->field_text_hesla[LANGUAGE_NONE][0]['value'])) {
      $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
    }
    else {
      // special requirement: in merging put GEO articles in front of others
      if ($top_parent->tid === "390") {  // "390" is Lubica Krajcovicova, editor of GEO articles.
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] = $entity->field_text_hesla[LANGUAGE_NONE][0]['value'] . "<p>&nbsp;</p>" . $master->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_hesla[LANGUAGE_NONE][0]['value'] .= "<p>&nbsp;</p>" . $entity->field_text_hesla[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_text_z_gh, use "\n" as separator.
    if (isset($entity->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_text_z_gh[LANGUAGE_NONE][0]['value']) || empty($master->field_text_z_gh[LANGUAGE_NONE][0]['value'])) {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] = $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_text_z_gh[LANGUAGE_NONE][0]['value'] .= "\n" . $entity->field_text_z_gh[LANGUAGE_NONE][0]['value'];
      }
    }

    // Merge field_ilustracia.
    if (!empty($entity->field_ilustracia)) {
      foreach ($entity->field_ilustracia[LANGUAGE_NONE] as $img) {
        $master->field_ilustracia[LANGUAGE_NONE][] = $img;
      }
    }

    // Merge field_atributy, use "\n" as separator.
    if (isset($entity->field_atributy[LANGUAGE_NONE][0]['value'])) {
      if (!isset($master->field_atributy[LANGUAGE_NONE][0]['value']) || empty($master->field_atributy[LANGUAGE_NONE][0]['value'])) {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] = $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
      else {
        $master->field_atributy[LANGUAGE_NONE][0]['value'] .= "," . $entity->field_atributy[LANGUAGE_NONE][0]['value'];
      }
    }

    // Check if entity has moderation state history: u_vyst_redaktora_2x >> u_vyst_redaktora_2
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $entity->nid)
        ->execute()
        ->fetchAll();

    // If master has state u_vyst_redaktora_2x, write to merged entity as attribute
    if (!empty($transitions)) {
      $master->field_atributy[LANGUAGE_NONE][0]['value'] = 'VR2X';
    }

    $master->field_zlucene_z[LANGUAGE_NONE][]['target_id'] = $entity->nid;
    node_save($master);

    $entity->field_zlucene_do[LANGUAGE_NONE][0]['target_id'] = $_SESSION['master'];
    # remove links from the original
    _beliana_remove_links($entity);
    // Empty alias for original entity.
    //$entity->path['alias'] = '';
    // Set automatic alias creation to FALSE.
    //$entity->path['pathauto'] = FALSE;
    node_save($entity);
    workbench_moderation_moderate($entity, 'ukoncenezluene');
  }

  // If current entity is the last, make workflow transition.
  if ($context['progress']['current'] === $context['progress']['total']) {
    $master = node_load($_SESSION['master']);
    // Reset fields.
    $master->field_vyplatit = NULL;
    $master->field_errta = NULL;
    $master->field_datum = NULL;
    // Set automatic alias creation to FALSE.
    $master->path['pathauto'] = FALSE;
    // Set field_lexikalna_skupina to `Zlúčené heslo`.
    $term = taxonomy_get_term_by_name('Zlúčené heslo', 'lexikalne_skupiny');
    $term = array_shift($term);
    $master->field_lexikalna_skupina[LANGUAGE_NONE][]['tid'] = $term->tid;
    workbench_moderation_moderate($master, 'zlucene');
    # Synchtonize to the web editorial system
    if ($response = beliana_api_rest_create_node($master, 'rs', "Zlúčené heslo:", "Zlúčené heslo")) {
      $master->field_remote_id[LANGUAGE_NONE][0]['value'] = $response->nid;
    }
    node_save($master);
    $_SESSION['master'] = NULL;
  }
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  // no action required in the beliana_rs module
  //dpm("_beliana_process_links beliana-rs");
}


/*
 * modify links in text due to article merging
 * find links pointing to articles in Ukončené/Zlúčené (ukoncenezluene) state and replace them
 */
function modify_links_merged(&$node) {
  $dom = new \DOMDocument();
  $dom->loadHTML(mb_convert_encoding($node->field_text_hesla[LANGUAGE_NONE][0]['value'], 'HTML-ENTITIES', 'UTF-8'));
  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  foreach ($links as $item) {
    $target = substr($item->getAttribute('href'), 1); // we do not need the leading slash /
    $path = drupal_get_normal_path($target);
    $parts = explode("/", $path);
    if ($parts[0] === 'node') {
      $lnode = node_load($parts[1]); // the linked node
      if ($lnode->workbench_moderation['current']->state == 'ukoncenezluene') {
        // $znode: the node $lnode is merged to
        $znode = node_load($lnode->field_zlucene_do[LANGUAGE_NONE][0]['target_id']);
        $newpath = $znode->path['alias'];
        // replace including the closing '"' to make the replacement string unique
        $node->field_text_hesla[LANGUAGE_NONE][0]['value'] = str_replace($target . '"', $newpath . '"', $node->field_text_hesla[LANGUAGE_NONE][0]['value']);
        watchdog('aktualizovany odkaz', 'Heslo "' . $node->title . '": aktualizovaný odkaz na zlúčené heslo (z <a href="/' . $target . '">' . $target . '</a> na <a href="/' . $newpath . '">' . $newpath . '</a>)');
      }
    }
  }
}

/*
 * Handle special transitions in the book workflow
 */
function handle_special_transitions(&$values) {
  // ensure corect state transitions if article is merged from other articles
  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;
  if (isset($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    // starting '1_korektura:' copy editor names to field_spravit_1_korekturu
    if (($cur_state === 'na_jazykovu_korekturu' && $new_state === '1_korektura'))
      _start_korektura($values);

    // transition 1_korektura >> u_vyst_redaktora_3
    if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
      _transition_korektura($values, "1_korektura");
    }

    // update links in nodes referencing the merged articles (in zlucene >> u_jaz_redaktora_1 transition)
    if ($cur_state === 'zlucene' && $new_state === 'na_jazykovu_korekturu') {
      dpm("zlucene >> u_jaz_redaktora_1transitio");
      foreach ($values['node']->field_zlucene_z[LANGUAGE_NONE] as $item) {
        $query = db_query('SELECT node.nid AS nid FROM {node} node INNER JOIN {search_node_links} links ON node.nid = links.sid WHERE links.nid = :nid', array(':nid' => $item['target_id']));
        $result = $query->fetchAll();

        if (!empty($result)) {
          foreach ($result as $backlink) {
            if ($source = node_load($backlink->nid)) {
              node_save($source);
            }
          }
        }
      }
    }

    $run_as_1_korektura = true;  // choose between two ways how to run 2_korekt_ra - FIXME needs workflow change
    if ($run_as_1_korektura) { // 2_korekt_ra: the same procedure as 1_korektura
      // starting 'korektura': copy editor names to field_spravit_1_korekturu
      if (($cur_state === 'u_vyst_redaktora_3' && $new_state === '2_korekt_ra'))
        _start_korektura($values);

      // transition 2_korekt_ra >> u_vyst_redaktora_4
      if ($cur_state === '2_korekt_ra' && $new_state === 'u_vyst_redaktora_4')
        _transition_korektura($values, "2_korekt_ra");
    }
    else // korekt_ra: version with only one editor selected
      _run_2_korektura_single($values);
    node_save($values['node']);
    return;
  }

  // transition 1_korektura >> u_vyst_redaktora_3
  if ($cur_state === '1_korektura' && $new_state === 'u_vyst_redaktora_3') {
    _transition_vr2x($values);
    node_save($values['node']);
  }
}

/**
 * Helper function: start 'korektura'
 */
function _start_korektura(&$values) {
  // copy editor names to field_spravit_1_korekturu
  foreach ($values['node']->field_redaktori_zluceneho['und'] as $redaktor)
    $values['node']->field_spravit_1_korekturu['und'][]['tid'] = $redaktor['tid'];
  // take the next editor
  $values['node']->field_lexikalna_skupina['und'] = array();
  $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_korektura(&$values, $korektura) {
  if (!empty($values['node']->field_spravit_1_korekturu['und'])) {
    // return back to '$korektura'
    $values['node']->workbench_moderation_state_new = $korektura;
    // take the next editor
    $values['node']->field_lexikalna_skupina['und'][0] = array_shift($values['node']->field_spravit_1_korekturu['und']);
  }
  else {
    _transition_vr2x($values);
    // we are done, restore the initial status
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

/**
 * Helper function: transition korektura >>  next state
 */
function _transition_vr2x(&$values) {
  // check if "heslo" was already seen by vr2x
  $already_seen_by_vr2x = FALSE;
  if (empty($values['node']->field_zlucene_z[LANGUAGE_NONE])) {
    $transitions = db_select('workbench_moderation_node_history', 'w')
        ->fields('w')
        ->condition('state', 'u_vyst_redaktora_2x')
        ->condition('nid', $values['node']->nid)
        ->execute()
        ->fetchAll();

    $already_seen_by_vr2x = !empty($transitions);
  }
  else {
    if (!empty($values['node']->field_atributy[LANGUAGE_NONE])) {
      $already_seen_by_vr2x = $values['node']->field_atributy[LANGUAGE_NONE][0]['value'] == 'VR2X';
    }
  }

  // if seen, move to vr4
  if ($already_seen_by_vr2x) {
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_4';
  }
}

/**
 * Helper function: transition to 2_korekt_ra
 */
function _run_2_korektura_single(&$values) {
  if ($values['state'] === '2_korekt_ra') {
    if (count($values['node']->field_lexikalna_skupina['und']) != 1) {
      //MS drupal_set_message('Ako lexikálnu skupinu zadajte meno požadovaného redaktora.', 'error');
      drupal_set_message('Heslo je zlúčené a má viacero lexikálnych skupín. Pri odosielaní na 2. korektúru však heslo môže mať len jednu lexikálnu skupinu.', 'error');
      drupal_set_message('Lexikálne skupiny upravte, heslo uložte a potom odošlite na 2. korektúru ešte raz. Po návrate z 2. korektúry sa lexikálne skupiny vrátia do pôvodného stavu.', 'error');
      $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
    }
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_vyst_redaktora_4' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U výstupného redaktora 4. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  // If node is prepared by Vystupny redaktor 3 for the 2_korekt_ra state, but erroneously sent to other state
  if ($values['state'] === 'u_jaz_redaktora_2' && count($values['node']->field_lexikalna_skupina['und']) != count($values['node']->field_povodne_lexikalne_skupiny['und'])) {
    drupal_set_message('Heslo ste pravdepodobne chceli odoslať na 2. korektúru, zvolili ste však stav U jazykového redaktora 2. Zvoľte 2. korektúru a odošlite ešte raz.', 'error');
    $values['node']->workbench_moderation_state_new = 'u_vyst_redaktora_3';
  }

  if ($values['node']->workbench_moderation['current']->state === '2_korekt_ra' && $values['state'] === 'u_vyst_redaktora_3') {
    $values['node']->field_lexikalna_skupina = $values['node']->field_povodne_lexikalne_skupiny;
  }
}

// check if illustration should go to web
// dummy function here, used only in the web version
function il_display_on_web(&$ilu_node)
{
  return false;
}

/**
 * Callback function for `workbench_moderation_moderate_form` submit.
 *
 * @inheritdoc
 */
function rs_beliana_workflow_reaction(&$form, &$form_state) {
  $values = $form_state['values'];
  if (!isset($values['node']->workbench_moderation['current']->state)) {
    return;
  }

  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;

  //Handle special transitions in the book workflow
  handle_special_transitions($values);

  // check type heslo and importovane heslo 
  // (in RS importovane heslo is not processed and in WEBRS is processed (nearly) equaly as heslo)
  if ($values['node']->type === 'heslo' or $values['node']->type === 'importovane_heslo' ) {
    $fail = FALSE;
    // do not change state if LITE changes exist
    $publish_states = ["na_opakovane_zverejnenie", "na_zalomenie", "importovane_na_zverejnenie"];
    if (in_array($new_state, $publish_states)) {
      $text = $values['node']->field_text_hesla['und'][0]['value'];
      if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
        $fail = TRUE;
        drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . '</a> nebol zmenený, lebo v jeho texte sú uložené LITE zmeny', 'error');
      }
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $texttab = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (strpos($texttab, "ice-ins") or strpos($texttab, "ice-del")) {
          $fail = TRUE;
          drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo v poli 'Tabuľka pre geografické heslá' sú uložené LITE zmeny", 'error');
        }
      }
    }
    // check if payment information is stored
    if (($cur_state === "needs_review" and $new_state === "na_zverejnenie") and // u redaktora state u vr1/vr state transition
      _display_payment_fields($values['node']) == "showeditable") {
      $fail = TRUE;
      drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo nie je vyplnené pole 'Vyplatenie odmeny'", 'error');
    }
    if ($fail) {
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    # remove links from text of artices in state 'vyradene'
    if (in_array($new_state, ['vyradene']) and strpos($values['node']->field_text_hesla['und'][0]['value'], '</a>')) {
      _beliana_remove_links($values['node']);
      node_save($values['node']);
    }
  }

  // check types heslo and importovane_heslo, ignore for authors
  if (!($cur_state === "u_autora" and $new_state === "needs_review")) {
    if ($values['node']->type === 'importovane_heslo' or $values['node']->type === 'heslo') {
      // Check link correctness
      $skip = FALSE;
      if (!_check_links($values['node'])) {
        $skip = TRUE;
      }
      if ($new_state === 'vyradene') {
        if (!_check_transition_to_vyradene($values['node'])) {
          $skip = TRUE;
        }
      }
      // Check alternative text marker correctness in article body
      if (!_check_alternative_text_markers($values['node'], $values['node']->field_text_hesla['und'][0]['value'], "v hesle")) {
        $skip = TRUE;
      }
      // Check alternative text marker correctness in article table
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $text_table = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (!_check_alternative_text_markers($values['node'], $text_table, "v tabuľke pre geografické údaje hesla")) {
          $skip = TRUE;
        }
      }
      if ($skip) {
        drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
        $values['node']->workbench_moderation_state_new = $cur_state;
        node_save($values['node']);
        return;
      }
    }
  }

  // check illustration state on transition of 'importovane_heslo' to state 'importovane_u_jr2'
  if ($values['node']->type === 'importovane_heslo' and $new_state == 'importovane_u_jr2') {
    $skip = FALSE;
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    $skip = !check_ill_at_node_transition($values['node'], $ok_states, 'state change');
    if ($skip) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // restore id of the node author from the saved value
  if (($cur_state === "u_konzultanta" and $new_state === "needs_review"))
  {
    if (isset($values['node']->field_uid_autora['und'])) {
      $values['node']->uid = $values['node']->field_uid_autora['und'][0]['value'];
      unset($values['node']->field_uid_autora['und']);
      node_save($values['node']);
    }
  }

  // check illustrations
  if ($values['node']->type === 'ilustracia') {
    $skip = FALSE;
    if ($cur_state == 'ilustracia_u_redaktora' and $new_state == 'ilustracia_u_vyst_redaktora_5') {
      $ilu_node = $values['node'];

      // temporarily disabled
      //if (!_check_ilu_attached($ilu_node, 'state change')) {
        //$skip = TRUE;
      //}

      //if (!_check_field_pouzit($ilu_node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // ignore illustrations, which are not intended for web
      if (il_display_on_web($ilu_node)) { //false always returned in the print version
        if (is_null(_check_illustration_web($ilu_node, $ilu_node, 'state change'))) {
          $skip = TRUE;
        }
      }
    }

    // a problem with illustration, keep the current state
    if ($skip) {
      drupal_set_message('<strong>Stav ilustrácie nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    else {
      $values['node']->field_datum_zverejnenia[LANGUAGE_NONE][0]['value'] = date('Y-m-d H:i:s');
      node_save($values['node']);
    }
  }
}

/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */

function beliana_group_list() {
  $users = entity_load('user');
  $terms = taxonomy_get_tree(2);
  $output = '';
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    if ($term->depth == 0) {
      $output .= '<h1>' . $term->name . '</h1>';
    }
    else {
      //$output .= '<h3> Lexikálna skupina: <em>' . $term->name . '</em></h3>';
      $output .= '<strong>' . $term->name . '</strong>';
      $output .= '<ul>';
      foreach ($users as $user) {
        if (isset($user->workbench_access[$term->tid])) {
          $output .= '<li>'
            . $user->name . ', '
            . $user->field_meno['und'][0]['value'] . ', '
            . $user->field_priezvisko['und'][0]['value'] . ', ';
          if (isset($user->field_autorska_zmluva['und'])) {
            $output .= $user->mail . ', '
              . $user->field_autorska_zmluva['und'][0]['value'] . '</li>';
          }
          else {
            $output .= $user->mail . '</li>';
          }
        }
      }
      //$output .= '</ul><br><br>';
      $output .= '</ul>';
    }
  }
  return $output;
}

/**
 * access callback for beliana_editor_list
 */
function beliana_editor_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Redaktor",
    "Správca heslára",
    "Výstupný redaktor 1",
    "administrátor",
    "Výstupný redaktor 2",
    "Výstupný redaktor 2X",
    "useradmin",
    "Výstupný redaktor 3",
    "Výstupný redaktor 4",
    "Výstupný redaktor 5",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * access callback for beliana_group_list
 */
function beliana_group_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "administrátor",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

// transfer node from the web editorial system
function beliana_sync_from_remote_build($node, $remote_node) {
  global $user;

  $api_type = variable_get('rs_api_type');

  $label_type = $api_type == 'webrs' ? 'webov' : 'knižn';
  $label_state = $api_type == 'webrs' ? 'Zverejnené na webe' : 'Zalomené';

  if (in_array($remote_node->workbench_moderation->current->state, [
    'zaradene',
    'publikovane_na_webe',
    'ilustracia_na_webe',
  ])) {
    $fields_to_skip = [
      'field_remote_id',
      'field_ilustracia',
      'field_zlucene_z',
      'field_zlucene_do',
      'field_text_hesla',
      'field_komentar_instrukcie',
      'field_datum_autorovho_textu',
    ];

    // transfer field values from remote node to local node
    foreach ($remote_node as $field => $data) {
      $remote_field_value = empty($data) ? '' : json_decode(json_encode($data), TRUE);

      if (($field == 'uid' || $field == 'title' || strpos($field, 'field_') === 0) && !in_array($field, $fields_to_skip)) {
        $node->{$field} = $remote_field_value;
      }

      if ($field == 'field_text_hesla') {
        $matches = [];
        $imce_path = $api_type == 'webrs' ? 'rs' : 'webrs';

        // adjust paths to inline images
        // "[>]" used in the regexp to make the vim editor happy, otherwise '>' is OK
        preg_match_all('/<img.*?src=[\'"](.*?)[\'"].*?[>]/i', $remote_field_value[LANGUAGE_NONE][0]['value'], $matches);

        if (!empty($matches)) {
          foreach ($matches[1] as $src) {
            $data = file_get_contents(variable_get('rs_api_uri') . $src);
            $new_src = str_replace($api_type, $imce_path, $src);
            $file = file_save_data($data, str_replace('/sites/' . $imce_path . '/files/', 'public://', $new_src), FILE_EXISTS_REPLACE);

            $remote_field_value[LANGUAGE_NONE][0]['value'] = str_replace('src="' . $src, 'src="' . $new_src, $remote_field_value[LANGUAGE_NONE][0]['value']);
            $remote_field_value[LANGUAGE_NONE][0]['safe_value'] = str_replace('src="' . $src, 'src="' . $new_src, $remote_field_value[LANGUAGE_NONE][0]['safe_value']);
          }
        }

        $node->field_text_hesla = $remote_field_value;
      }

      if ($field == 'field_datum_autorovho_textu') {
        $node->field_datum_autorovho_textu[LANGUAGE_NONE][0]['value'] = '1970-01-01 00:00:00';
      }

      if ($field == 'field_komentar_instrukcie') {
        $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] = 'Obsah prevzatý z ' . $label_type . 'ého RS. ';

        if (!empty($remote_field_value)) {
          $node->field_komentar_instrukcie[LANGUAGE_NONE][0]['value'] .= $remote_field_value[0]['value'];
        }
      }

      if (in_array($field, [
        'field_subor_ilustracie',
        'field_obrazok_navrh_',
        'field_original',
      ])) {
        $node->{$field}[LANGUAGE_NONE] = [];

        if (!empty($remote_field_value)) {
          foreach ($remote_field_value[LANGUAGE_NONE] as $key => $remote_file) {
            $data = file_get_contents(variable_get('rs_api_uri') . '/sites/' . variable_get('rs_api_type') . '/files' . str_replace('public:/', '', $remote_file['uri']));
            $file = file_save_data($data, $remote_file['uri'], FILE_EXISTS_REPLACE);

            $node->{$field}[LANGUAGE_NONE][$key] = [
              'fid' => $file->fid,
              'uid' => $file->uid,
              'filename' => $file->filename,
              'uri' => $file->uri,
              'filemime' => $file->filemime,
              'filesize' => $file->filesize,
              'status' => 1,
              'display' => 1,
              'description' => '',
            ];
          }
        }
      }

      if (in_array($field, [
        'field_ilustracia',
        'field_zlucene_z',
        'field_zlucene_do',
      ])) {
        $node->{$field}[LANGUAGE_NONE] = [];

        if (!empty($remote_field_value)) {
          foreach ($remote_field_value[LANGUAGE_NONE] as $delta => $ilustracia) {
            if ($target_remote_node = beliana_api_rest_get_node($ilustracia['target_id'])) {
              // do not sync ilusracia bundle when syncing from node
              //beliana_sync_from_remote_build(node_load($ilustracia['target_id']), $target_remote_node);
              $node->{$field}[LANGUAGE_NONE][$delta]['target_id'] = empty($target_remote_node->field_remote_id->und) ? $target_remote_node->nid : $target_remote_node->field_remote_id->und[0]->value;
            }
          }
        }
      }

    }

    $node->field_datum_prebratia = [LANGUAGE_NONE => [['value' => date('Y-m-d H:i:s')]]];
    $node->revision = 1;

    $workbench_moderation = 'needs_review';
    if ($node->type == 'ilustracia') {
      $workbench_moderation = 'ilustracia_u_redaktora';
    }
    elseif ($label_type == 'knižn') {
      $workbench_moderation = 'prevzate_z_rs';
    }

    $message_log = 'Obsah prevzatý z ' . $label_type . 'ého RS (' . date('Y-m-d') . ', ' . $user->name . ')';
    if (strpos($node->log, $message_log) === FALSE) {
      $node->log .= '. ' . $message_log;
    }

    workbench_moderation_moderate($node, $workbench_moderation);
    drupal_set_message(t('Obsah hesla @id bol úspešne prebratý', ['@id' => $remote_node->nid]));
  }
  else {
    drupal_set_message(t('Nepodarilo sa prevziať obsah hesla @id (heslo nie je v stave @state)', [
      '@id' => $remote_node->nid,
      '@state' => $label_state,
    ]), 'error');
  }
}
