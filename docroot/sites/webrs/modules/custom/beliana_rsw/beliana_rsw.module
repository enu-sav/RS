<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rsw module.
 */

/**
 * Implements hook_action_info().
 *
 * @inheritdoc
 */
function beliana_rsw_action_info() {
  return array(
    'importovane_publish_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie'),
      'label' => t('Mark for publishing (editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_senior_editor' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (VR)'),
      'label' => t('Mark for publishing (senior editor)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
    'importovane_publish_proofreader' => array(
      'type' => 'entity',
      //'label' => t('Odoslať na zverejnenie (JR)'),
      'label' => t('Mark for publishing (proofreader)'),
      'configurable' => FALSE,
      'triggers' => array('any'),
      'behavior' => array('create_property'),
      'vbo_configurable' => FALSE,
      'pass rows' => TRUE,
    ),
  );
}

/**
 * Callback for 'importovane_publish_editor' action.
 *
 * changes workflow status to 'importovane_u_jr2'
 *
 * @inheritdoc
 */
function importovane_publish_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane') {
    $skip = false;
    if (!_check_links($node)) {
      $skip = true;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = true;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "importovane_u_jr2");
    }
  }
}

/**
 * Callback for 'importovane_publish_proofreader' action.
 *
 * changes workflow status to 'importovane_u_vr'
 *
 * @inheritdoc
 */
function importovane_publish_proofreader(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_jr2') {
    if (_check_links($node)) {
      workbench_moderation_moderate($node, "importovane_u_vr");
    }
  }
}

/**
 * Callback for 'importovane_publish_senior_editor' action.
 *
 * changes workflow status to 'na_zalomenie'
 *
 * @inheritdoc
 */
function importovane_publish_senior_editor(&$node, $context) {
  if ($node->type == 'importovane_heslo' && $node->workbench_moderation['current']->state === 'importovane_u_vr') {
    $skip = false;
    if (!_check_links($node)) {
      $skip = true;
    }
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    if (!check_ill_at_node_transition($node, $ok_states, 'state change')) {
      $skip = true;
    }
    if (!$skip) {
      workbench_moderation_moderate($node, "na_zalomenie");
    }
  }
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  #dpm("_beliana_process_links", $node->title);
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  db_delete('beliana_links')
      ->condition('origin', $nid)
      ->execute();
  // Extract links.
  $text = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
  // do not continue if text is empty
  if ($text === "")
    return;
  $dom = beliana_get_dom($node, $text, "Text hesla (beliana_process_links)");
  if (!$dom)
    return;

  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = $links->length - 1; $i >= 0; $i--) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      if (!url_is_external($target)) {
        // Get rid of leading slash.
        if ($target[0] === '/') {
          $target = substr($target, 1);
        }
        // Get non-alias path, so we can get nid from it.
        $path = drupal_get_normal_path($target);
        $path_elements = explode('/', $path);
        // If alias belong to node, then insert record into beliana_links table.
        if ($path_elements[0] === 'node' && is_numeric($path_elements[1])) {
          $link = db_select('beliana_links', 'l')
              ->fields('l', ['origin'])
              ->condition('origin', $nid)
              ->condition('target', $path_elements[1])
              ->execute()
              ->fetchCol(0);
          // We insert new item only if it already doesn't exist.
          if (empty($link)) {
            db_insert('beliana_links')
                ->fields([
                  'origin' => $nid,
                  'target' => $path_elements[1],
                ])
                ->execute();
          }
        }
      }
    }
  }
}

/*
 * modify links in text due to article merging
 */
function modify_links_merged(&$node) {
// currently no code here
}

/*
 * Create remote node (Heslo only) in the book editorial system
 * sets current nid in the remote_nid field of the remote node
 * sets nid of the remote node in the remote_nid of the current node
 * sets fields title_field, field_lexikalna_skupina and field_text_hesla od the remote node
 * sets remote node alias to be the same as alias of the current node
 */
function create_article_opposite(&$node) {
}

/*
 * Handle special transitions in the web workflow
 */
function handle_special_transitions(&$values) {
  // nothing special yer
}


/** 
 * access callback for beliana_editor_list
 * to be updated according to appropriate roles
 */
function beliana_editor_list_access() {
  global $user;
  // roles with allowed access
  $roles = array("Redaktor", "Správca heslára",  "Výstupný redaktor 1", "administrátor", "useradmin"); 
  foreach($roles as $role){
    if (in_array($role, $user->roles)) return true;
  }
  return false;
}
