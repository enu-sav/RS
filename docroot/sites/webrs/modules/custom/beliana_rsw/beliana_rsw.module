<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rsw module.
 */

/**
 * Implements hook_init().
 */
function beliana_rsw_init(){
  drupal_add_css(drupal_get_path('module', 'beliana_rsw') . '/css/admin_menu_override.css');
}


/**
 * Implements hook_form_alter().
 */
function beliana_rsw_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_profile_form':
      //disable browser remember password on user edit form
      $form['account']['current_pass']['#type'] = 'textfield';
      $form['account']['current_pass']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";
      break;
  }
}

/**
 * Implements hook_element_info_alter().
 */
function beliana_rsw_element_info_alter(array &$types) {
  if (isset($types['password_confirm'])) {
    $types['password_confirm']['#process'][] = 'beliana_rsw_form_process_password_confirm';
  }
}

/**
 * Process the password_confirm element.
 */
function beliana_rsw_form_process_password_confirm($element) {
  $element['pass1']['#type'] = $element['pass2']['#type'] = 'textfield';
  $element['pass1']['#attributes']['onfocus'] = $element['pass2']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";

  return $element;
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  #dpm("_beliana_process_links", $node->title);
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  db_delete('beliana_links')
      ->condition('origin', $nid)
      ->execute();
  // Extract links.
  $text = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
  // do not continue if text is empty
  if ($text === "")
    return;
  $dom = beliana_get_dom($node, $text, "Text hesla (beliana_process_links)");
  if (!$dom)
    return;

  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = $links->length - 1; $i >= 0; $i--) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      if (!url_is_external($target)) {
        // Get rid of leading slash.
        if ($target[0] === '/') {
          $target = substr($target, 1);
        }
        // Get non-alias path, so we can get nid from it.
        $path = drupal_get_normal_path($target);
        $path_elements = explode('/', $path);
        // If alias belong to node, then insert record into beliana_links table.
        if ($path_elements[0] === 'node' && is_numeric($path_elements[1])) {
          $link = db_select('beliana_links', 'l')
              ->fields('l', ['origin'])
              ->condition('origin', $nid)
              ->condition('target', $path_elements[1])
              ->execute()
              ->fetchCol(0);
          // We insert new item only if it already doesn't exist.
          if (empty($link)) {
            db_insert('beliana_links')
                ->fields([
                  'origin' => $nid,
                  'target' => $path_elements[1],
                ])
                ->execute();
          }
        }
      }
    }
  }
}

/*
 * modify links in text due to article merging
 */
function modify_links_merged(&$node) {
// currently no code here
}

/*
 * Handle special transitions in the web workflow
 */
function handle_special_transitions(&$values) {
  // nothing special yet
}


/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */

function beliana_group_list() {
  $users = entity_load('user'); 
  $terms = taxonomy_get_tree(2);
  $output = '';
  $ls0="";
  $ls1="";
  $ls2="";
  //foreach ($terms as $term) {
  $output="";
  $output .='<table style="border: 1px solid gray;">';
  $output .= "<tr><th>"."Hl. kategória"."</th><th>"."Podkategória/LS"."</th><th>"."LS"."</th>";
  $output .= "<th>".'Redaktor'."</th><th>".'Výst. redaktor'."</th><th>".'Autori'."</th><th>".'Konzultanti'."</th><tr>";
  //foreach (array_slice($terms,0,100) as $term) {
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    
    if ($term->depth == 0) {
      $ls0 = $term->name;
      $ls1="-";
      $ls2="-";
    } else if ($term->depth == 1) {
      $ls1 = $term->name;
      $ls2="-";
    } else if ($term->depth == 2) {
      $ls2 = $term->name;
    }
    $ausers = _get_users($users,$term->tid); 
    $output .= '<tr style="border: 1px solid gray;"><td>'.$ls0."</td><td>".$ls1."</td><td>".$ls2."</td>";
    $output .= "<td>".$ausers['redaktor']."</td><td>".$ausers['vr']."</td><td>".$ausers['autor']."</td><td>".$ausers['konzultant']."</td><tr>\n";
  }
  $output.="</table>";
  return $output;
}

/* helper sunction to be called in beliana_group_list */
function _get_users(&$users, $tid)
{
	$roles=array(
		"autor" => '',
		"konzultant" => '',
		"redaktor" => '',
		"vr" => ''
	);
	foreach ($users as $user) {
		//if (strpos($user->name, 'test') !== null) continue;
		if (substr($user->name,0,5) == 'test_') continue;
		if (isset($user->workbench_access[$tid])) {
			if (in_array("Autor", $user->roles)) {
				$roles["autor"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a>, ';
			} else if (in_array("Redaktor", $user->roles)) {
				$roles["redaktor"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a> ';
			} else if (in_array("Konzultant", $user->roles)) {
				$roles["konzultant"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a>, ';
			} else if (in_array("Výstupný redaktor", $user->roles)) {
				$roles["vr"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a> ';
			}
		}
	}
	return $roles;
}

/**
 * access callback for beliana_editor_list
 */
function beliana_editor_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Redaktor",
    "administrátor",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * access callback for beliana_group_list
 */
function beliana_group_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Správca heslára",
    "Výstupný redaktor",
    "administrátor",
    "useradmin",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}
