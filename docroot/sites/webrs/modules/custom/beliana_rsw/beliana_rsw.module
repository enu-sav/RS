<?php
# vim: ai ts=2 sts=2 et sw=2 ft=php

/**
 * @file
 * Module file for beliana_rsw module.
 */

/**
 * Implements hook_init().
 */
function beliana_rsw_init(){
  drupal_add_css(drupal_get_path('module', 'beliana_rsw') . '/css/admin_menu_override.css');
}


/**
 * Implements hook_form_alter().
 */
function beliana_rsw_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'user_profile_form':
      //disable browser remember password on user edit form
      $form['account']['current_pass']['#type'] = 'textfield';
      $form['account']['current_pass']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";
      break;
  }
}

/**
 * Implements hook_element_info_alter().
 */
function beliana_rsw_element_info_alter(array &$types) {
  if (isset($types['password_confirm'])) {
    $types['password_confirm']['#process'][] = 'beliana_rsw_form_process_password_confirm';
  }
}

/**
 * Process the password_confirm element.
 */
function beliana_rsw_form_process_password_confirm($element) {
  $element['pass1']['#type'] = $element['pass2']['#type'] = 'textfield';
  $element['pass1']['#attributes']['onfocus'] = $element['pass2']['#attributes']['onfocus'] = "this.setAttribute('type', 'password')";

  return $element;
}

/**
 * Extract links from node and insert them into beliana_links table.
 * name "beliana_process_links" is not OK, it is called in unexpected situations with funny arguments
 *
 * @param $nid
 */
function _beliana_process_links(&$node) {
  #dpm("_beliana_process_links", $node->title);
  // Extract links from field_text_hesla.
  $nid = $node->nid;
  db_delete('beliana_links')
      ->condition('origin', $nid)
      ->execute();
  // Extract links.
  $text = $node->field_text_hesla[LANGUAGE_NONE][0]['value'];
  // do not continue if text is empty
  if ($text === "")
    return;
  $dom = beliana_get_dom($node, $text, "Text hesla (beliana_process_links)");
  if (!$dom)
    return;

  /** @var \DOMElement[] $links */
  $links = $dom->getElementsByTagName('a');
  if (!empty($links)) {
    for ($i = $links->length - 1; $i >= 0; $i--) {
      $item = $links->item($i);
      $target = $item->getAttribute('href');
      if (!url_is_external($target)) {
        // Get rid of leading slash.
        if ($target[0] === '/') {
          $target = substr($target, 1);
        }
        // Get non-alias path, so we can get nid from it.
        $path = drupal_get_normal_path($target);
        $path_elements = explode('/', $path);
        // If alias belong to node, then insert record into beliana_links table.
        if ($path_elements[0] === 'node' && is_numeric($path_elements[1])) {
          $link = db_select('beliana_links', 'l')
              ->fields('l', ['origin'])
              ->condition('origin', $nid)
              ->condition('target', $path_elements[1])
              ->execute()
              ->fetchCol(0);
          // We insert new item only if it already doesn't exist.
          if (empty($link)) {
            db_insert('beliana_links')
                ->fields([
                  'origin' => $nid,
                  'target' => $path_elements[1],
                ])
                ->execute();
          }
        }
      }
    }
  }
}

/*
 * modify links in text due to article merging
 */
function modify_links_merged(&$node) {
// currently no code here
}

/*
 * Handle special transitions in the web workflow
 */
function handle_special_transitions(&$values) {
  // nothing special yet
}


/**
 * Menu callback for `admin/group-list` path.
 *
 * We are printing users grouped by terms assigned to users.
 *
 * @return string
 *   HTML output of users.
 */

function beliana_group_list() {
  $users = entity_load('user'); 
  $terms = taxonomy_get_tree(2);
  $output = '';
  $ls0="";
  $ls1="";
  $ls2="";
  //foreach ($terms as $term) {
  $output="";
  $output .='<table style="border: 1px solid gray;">';
  $output .= "<tr><th>"."Hl. kategória"."</th><th>"."Podkategória/LS"."</th><th>"."LS"."</th>";
  $output .= "<th>".'Redaktor'."</th><th>".'Výst. redaktor'."</th><th>".'Autori'."</th><th>".'Konzultanti'."</th><tr>";
  //foreach (array_slice($terms,0,100) as $term) {
  foreach ($terms as $term) {
    // The list seems to be sorted according to the hierarchy, so print items with depth==0 as H1 headers
    
    if ($term->depth == 0) {
      $ls0 = $term->name;
      $ls1="-";
      $ls2="-";
    } else if ($term->depth == 1) {
      $ls1 = $term->name;
      $ls2="-";
    } else if ($term->depth == 2) {
      $ls2 = $term->name;
    }
    $ausers = _get_users($users,$term->tid); 
    $output .= '<tr style="border: 1px solid gray;"><td>'.$ls0."</td><td>".$ls1."</td><td>".$ls2."</td>";
    $output .= "<td>".$ausers['redaktor']."</td><td>".$ausers['vr']."</td><td>".$ausers['autor']."</td><td>".$ausers['konzultant']."</td><tr>\n";
  }
  $output.="</table>";
  return $output;
}


/**
 * Callback function for `workbench_moderation_moderate_form` submit.
 *
 * @inheritdoc
 */
function webrs_beliana_workflow_reaction(&$form, &$form_state) {
  $values = $form_state['values'];
  if (!isset($values['node']->workbench_moderation['current']->state)) {
    return;
  }

  $new_state = $values['state'];
  $cur_state = $values['node']->workbench_moderation['current']->state;

  //Handle special transitions in the book workflow
  handle_special_transitions($values);

  // check type heslo and importovane heslo 
  // (in RS importovane heslo is not processed and in WEBRS is processed (nearly) equaly as heslo)
  if ($values['node']->type === 'heslo' or $values['node']->type === 'importovane_heslo' ) {
    $fail = FALSE;
    // do not change state if article has more that one editor
    // applies on to webrs
    if (count($values['node']->field_lexikalna_skupina[LANGUAGE_NONE]) > 1 and
       (($cur_state === "importovane" and $new_state === "zaradene"))) {
      $eds=array(); // highest level parent terms
      foreach ($values['node']->field_lexikalna_skupina[LANGUAGE_NONE] as $ls){
        $ed = end(taxonomy_get_parents_all($ls['tid']));
        if(!in_array($ed->tid, $eds)) {
          $eds[$ed->tid]=$ed->name;
        }
      }
      if( count($eds) > 1 ){
        $fail = TRUE;
        drupal_set_message('Stav hesla <a href="/' . 
          $values['node']->path['alias'] . '">' . 
          $values['node']->title . 
          "</a> nebol zmenený, lebo jeho lexikálne skupiny majú rôznych redaktorov (".
          implode(", ",$eds).
          "). Do stavu 'Zaradené' možno heslá odosielať len ak majú jedného redaktora.", 
          'error');
      }
    }
    // do not change state if LITE changes exist
    $publish_states = ["na_opakovane_zverejnenie", "na_zalomenie", "importovane_na_zverejnenie"];
    if (in_array($new_state, $publish_states)) {
      $text = $values['node']->field_text_hesla['und'][0]['value'];
      if (strpos($text, "ice-ins") or strpos($text, "ice-del")) {
        $fail = TRUE;
        drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . '</a> nebol zmenený, lebo v jeho texte sú uložené LITE zmeny', 'error');
      }
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $texttab = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (strpos($texttab, "ice-ins") or strpos($texttab, "ice-del")) {
          $fail = TRUE;
          drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo v poli 'Tabuľka pre geografické heslá' sú uložené LITE zmeny", 'error');
        }
      }
    }
    // check if payment information is stored
    if (($cur_state === "needs_review" and $new_state === "na_zverejnenie") and // u redaktora state u vr1/vr state transition
      _display_payment_fields($values['node']) == "showeditable") {
      $fail = TRUE;
      drupal_set_message('Stav hesla <a href="/' . $values['node']->path['alias'] . '">' . $values['node']->title . "</a> nebol zmenený, lebo nie je vyplnené pole 'Vyplatenie odmeny'", 'error');
    }
    if ($fail) {
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    # remove links from text of artices in state 'vyradene'
    if (in_array($new_state, ['vyradene']) and strpos($values['node']->field_text_hesla['und'][0]['value'], '</a>')) {
      _beliana_remove_links($values['node']);
      node_save($values['node']);
    }
  }

  // check types heslo and importovane_heslo, ignore for authors
  if (!($cur_state === "u_autora" and $new_state === "needs_review")) {
    if ($values['node']->type === 'importovane_heslo' or $values['node']->type === 'heslo') {
      // Check link correctness
      $skip = FALSE;
      if (!_check_links($values['node'])) {
        $skip = TRUE;
      }
      if ($new_state === 'vyradene') {
        if (!_check_transition_to_vyradene($values['node'])) {
          $skip = TRUE;
        }
      }
      // Check alternative text marker correctness in article body
      if (!_check_alternative_text_markers($values['node'], $values['node']->field_text_hesla['und'][0]['value'], "v hesle")) {
        $skip = TRUE;
      }
      // Check alternative text marker correctness in article table
      if (isset($values['node']->field_table[LANGUAGE_NONE][0])) {
        $text_table = $values['node']->field_table[LANGUAGE_NONE][0]['value'];
        if (!_check_alternative_text_markers($values['node'], $text_table, "v tabuľke pre geografické údaje hesla")) {
          $skip = TRUE;
        }
      }
      if ($skip) {
        drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
        $values['node']->workbench_moderation_state_new = $cur_state;
        node_save($values['node']);
        return;
      }
    }
  }

  // check illustration state on transition of 'importovane_heslo' to state 'importovane_u_jr2'
  if ($values['node']->type === 'importovane_heslo' and $new_state == 'importovane_u_jr2') {
    $skip = FALSE;
    $ok_states = ['ilustracia_u_vyst_redaktora_5'];
    $skip = !check_ill_at_node_transition($values['node'], $ok_states, 'state change');
    if ($skip) {
      drupal_set_message('<strong>Stav hesla nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
  }

  // restore id of the node author from the saved value
  if (($cur_state === "u_konzultanta" and $new_state === "needs_review"))
  {
    if (isset($values['node']->field_uid_autora['und'])) {
      $values['node']->uid = $values['node']->field_uid_autora['und'][0]['value'];
      unset($values['node']->field_uid_autora['und']);
      node_save($values['node']);
    }
  }

  // check illustrations
  if ($values['node']->type === 'ilustracia') {
    $skip = FALSE;
    if ($cur_state == 'ilustracia_u_redaktora' and $new_state == 'ilustracia_u_vyst_redaktora_5') {
      $ilu_node = $values['node'];

      // temporarily disabled
      //if (!_check_ilu_attached($ilu_node, 'state change')) {
        //$skip = TRUE;
      //}

      //if (!_check_field_pouzit($ilu_node, $ilu_node, 'state change')) {
      //$skip = TRUE;
      //}
      // ignore illustrations, which are not intended for web
      if (il_display_on_web($ilu_node)) { //false always returned in the print version
        if (is_null(_check_illustration_web($ilu_node, $ilu_node, 'state change'))) {
          $skip = TRUE;
        }
      }
    }

    // a problem with illustration, keep the current state
    if ($skip) {
      drupal_set_message('<strong>Stav ilustrácie nebol zmenený</strong>', 'error');
      $values['node']->workbench_moderation_state_new = $cur_state;
      node_save($values['node']);
      return;
    }
    else {
      $values['node']->field_datum_zverejnenia[LANGUAGE_NONE][0]['value'] = date('Y-m-d H:i:s');
      node_save($values['node']);
    }
  }
}

/* helper function to be called in beliana_group_list */
function _get_users(&$users, $tid)
{
	$roles=array(
		"autor" => '',
		"konzultant" => '',
		"redaktor" => '',
		"vr" => ''
	);
	foreach ($users as $user) {
		//if (strpos($user->name, 'test') !== null) continue;
		if (substr($user->name,0,5) == 'test_') continue;
		if (isset($user->workbench_access[$tid])) {
			if (in_array("Autor", $user->roles)) {
				$roles["autor"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a>, ';
			} else if (in_array("Redaktor", $user->roles)) {
				$roles["redaktor"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a> ';
			} else if (in_array("Konzultant", $user->roles)) {
				$roles["konzultant"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a>, ';
			} else if (in_array("Výstupný redaktor", $user->roles)) {
				$roles["vr"] .= '<a href="/user/'.$user->uid.'">'.$user->name.'</a> ';
			}
		}
	}
	return $roles;
}

/**
 * access callback for beliana_editor_list
 */
function beliana_editor_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Redaktor",
    "administrátor",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * access callback for beliana_group_list
 */
function beliana_group_list_access() {
  global $user;
  // roles with allowed access
  $roles = [
    "Správca heslára",
    "Výstupný redaktor",
    "administrátor",
    "useradmin",
  ];
  foreach ($roles as $role) {
    if (in_array($role, $user->roles)) {
      return TRUE;
    }
  }
  return FALSE;
}
